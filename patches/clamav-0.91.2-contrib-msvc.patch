diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/README.txt clamav-release/contrib/msvc/README.txt
--- clamav-0.91.2/contrib/msvc/README.txt	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/README.txt	2007-07-12 12:36:20.046875000 +1000
@@ -0,0 +1,49 @@
+*** ClamAV native win32 port ***
+
+Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this software; if not, write to the
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+
+***
+
+[what is working]
+- libclamav dll linkable from external applications
+- freshclam with dns query support (silent disabled on Win95 and NT4 due to missing os functionalities)
+- sigtool
+- no need for cygwin dlls or registry keys to handle temp directory (it's a native port)
+- db path and config path can be optionally stored in the registry (see notes)
+- The patch applies to current cvs and it doesn't affect unix compilation
+  (autoconf should be called before building it on unix)
+- basic 7zip archives handling (only lzma codec supported) and command line --7zip to use 7z.exe
+- memory scan using --memory command line switch
+
+[what is not ported]
+- clamd/clamdscan - probabily they will never ported
+
+[todo]
+- implement other methods in 7zip archives
+- support for maxfiles maxspace checks while unpacking with external programs
+
+- You can store database and config paths in the registry using the clamav.reg file
+  (I may make a nsis installer in the future), paths can be also REG_EXPAND_SZ,
+  environment variables are permitted (i.e. you can use paths like %HomeDrive%\Clamav).
+
+- To use binaries compiled with Visual Studio 2005, you need the msvcrt80 side by side assembly,
+  the "simple way" is uncompress Microsoft.VC80.CRT.zip in the directory of executables,
+  the directory Microsoft.VC80.CRT must be placed as is, putting directly dlls in the same directory
+  of the executable will not work. On windows 9x you should put the dll and the manifest in windows
+  system directory without the Microsoft.VC80.CRT directory. For more info about this refer to the
+  relative msdn-page. You can also download the redist package directly from Microsoft.
+
+!!!! Please report bugs to sherpya@netfarm.it and not to bugs@clamav.net !!!!
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamav-config.h clamav-release/contrib/msvc/clamav-config.h
--- clamav-0.91.2/contrib/msvc/clamav-config.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamav-config.h	2007-08-21 20:59:08.953125000 +1000
@@ -0,0 +1,313 @@
+/* clamav-config.h.  Generated by Sherpya  */
+
+/* enable bind8 compatibility */
+/* #undef BIND_8_COMPAT */
+
+/* Define if your snprintf is busted */
+/* #undef BROKEN_SNPRINTF */
+
+/* "build clamd" */
+/* #undef BUILD_CLAMD */
+
+/* name of the clamav user */
+#define CLAMAVUSER "ClamWin"
+
+/* enable experimental code */
+/* #undef CL_EXPERIMENTAL */
+
+/* thread safe */
+#define CL_THREAD_SAFE 1
+
+/* where to look for the config file */
+#define CONFDIR "."
+
+/* Path to virus database directory. */
+#define DATADIR "."
+
+/* "default FD_SETSIZE value" */
+#define DEFAULT_FD_SETSIZE 64
+
+/* file i/o buffer size */
+#define FILEBUFF 8192
+
+/* enable workaround for broken DNS servers */
+/* #undef FRESHCLAM_DNS_FIX */
+
+/* use "Cache-Control: no-cache" in freshclam */
+/* #undef FRESHCLAM_NO_CACHE */
+
+/* access rights in msghdr */
+/* #undef HAVE_ACCRIGHTS_IN_MSGHDR */
+
+/* attrib aligned */
+/* undef HAVE_ATTRIB_ALIGNED */
+
+/* attrib packed */
+/* #define HAVE_ATTRIB_PACKED */
+
+/* have bzip2 */
+#define HAVE_BZLIB_H 1
+
+/* ancillary data style fd pass */
+/* #undef HAVE_CONTROL_IN_MSGHDR */
+
+/* Define to 1 if you have the `ctime_r' function. */
+/* #undef HAVE_CTIME_R */
+
+/* ctime_r takes 2 arguments */
+/* #undef HAVE_CTIME_R_2 */
+
+/* ctime_r takes 3 arguments */
+/* #undef HAVE_CTIME_R_3 */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+/* #undef HAVE_DLFCN_H */
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+/* #undef HAVE_FSEEKO */
+
+/* gethostbyname_r takes 3 arguments */
+/* #undef HAVE_GETHOSTBYNAME_R_3 */
+
+/* gethostbyname_r takes 5 arguments */
+/* #undef HAVE_GETHOSTBYNAME_R_5 */
+
+/* gethostbyname_r takes 6 arguments */
+/* #undef HAVE_GETHOSTBYNAME_R_6 */
+
+/* Define to 1 if you have the `getpagesize' function. */
+/* #undef HAVE_GETPAGESIZE */
+
+/* have gmp installed */
+#define HAVE_GMP 1
+
+/* Define to 1 if you have the <grp.h> header file. */
+/* #undef HAVE_GRP_H */
+
+/* Define to 1 if you have the <iconv.h> header file. */
+/* #undef HAVE_ICONV_H */
+
+/* Define to 1 if you have the `inet_ntop' function. */
+/* #undef HAVE_INET_NTOP */
+
+/* Define to 1 if you have the `initgroups' function. */
+/* #undef HAVE_INITGROUPS */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* in_addr_t is defined */
+#define HAVE_IN_ADDR_T 1
+
+/* in_port_t is defined */
+#define HAVE_IN_PORT_T 1
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the `memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have a working `mmap' system call. */
+#define HAVE_MMAP 1
+
+/* Support for NodalCore acceleration */
+/* #undef HAVE_NCORE */
+
+/* Define to 1 if you have the <ndir.h> header file. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the `poll' function. */
+/* #undef HAVE_POLL */
+
+/* Define to 1 if you have the <poll.h> header file. */
+/* #undef HAVE_POLL_H */
+
+/* "pragma pack" */
+#define HAVE_PRAGMA_PACK 1
+
+/* "pragma pack hppa/hp-ux style" */
+/* #undef HAVE_PRAGMA_PACK_HPPA */
+
+/* Define to 1 if you have the <pwd.h> header file. */
+/* #undef HAVE_PWD_H */
+
+/* readdir_r takes 2 arguments */
+/* #undef HAVE_READDIR_R_2 */
+
+/* readdir_r takes 3 arguments */
+/* #undef HAVE_READDIR_R_3 */
+
+/* Define to 1 if you have the `recvmsg' function. */
+/* #undef HAVE_RECVMSG */
+
+/* Define to 1 if you have the <regex.h> header file. */
+#define HAVE_REGEX_H 1
+
+/* have resolv.h */
+/* #undef HAVE_RESOLV_H */
+
+/* Define signed right shift implementation */
+#define HAVE_SAR 1
+
+/* Define to 1 if you have the `sendmsg' function. */
+/* #undef HAVE_SENDMSG */
+
+/* Define to 1 if you have the `setgroups' function. */
+/* #undef HAVE_SETGROUPS */
+
+/* Define to 1 if you have the `setsid' function. */
+/* #undef HAVE_SETSID */
+
+/* Define to 1 if you have the `snprintf' function. */
+/* #undef HAVE_SNPRINTF */
+
+/* Define to 1 if you have the <stdbool.h> header file. */
+/* #define HAVE_STDBOOL_H */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+/* #undef HAVE_STRERROR_R */
+
+/* Define to 1 if you have the <strings.h> header file. */
+/* HAVE_STRINGS_H */
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the <sys/filio.h> header file. */
+/* #undef HAVE_SYS_FILIO_H */
+
+/* Define to 1 if you have the <sys/inttypes.h> header file. */
+/* #undef HAVE_SYS_INTTYPES_H */
+
+/* Define to 1 if you have the <sys/int_types.h> header file. */
+/* #undef HAVE_SYS_INT_TYPES_H */
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+/* #undef HAVE_SYS_PARAM_H */
+
+/* "have <sys/select.h>" */
+/* #undef HAVE_SYS_SELECT_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+/* #undef HAVE_SYS_UIO_H */
+
+/* Define to 1 if you have the <tcpd.h> header file. */
+/* #undef HAVE_TCPD_H */
+
+/* Define to 1 if you have the <termios.h> header file. */
+/* #undef HAVE_TERMIOS_H */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+/* #undef HAVE_VSNPRINTF */
+
+/* zlib installed */
+#define HAVE_ZLIB_H 1
+
+/* Early Linux doesn't set cmsg fields */
+/* #undef INCOMPLETE_CMSG */
+
+/* bzip funtions do not have bz2 prefix */
+/* #undef NOBZ2PREFIX */
+
+/* "no fd_set" */
+#define NO_FD_SET 1
+
+/* Name of package */
+#define PACKAGE "ClamWin"
+
+/* scan buffer size */
+#define SCANBUFF 131072
+
+/* location of Sendmail binary */
+/* #undef SENDMAIL_BIN */
+
+/* major version of Sendmail */
+/* #undef SENDMAIL_VERSION_A */
+
+/* minor version of Sendmail */
+/* #undef SENDMAIL_VERSION_B */
+
+/* subversion of Sendmail */
+/* #undef SENDMAIL_VERSION_C */
+
+/* Define to 1 if the `setpgrp' function takes no argument. */
+#define SETPGRP_VOID 1
+
+/* The number of bytes in type int */
+#define SIZEOF_INT 4
+
+/* The number of bytes in type long */
+#define SIZEOF_LONG 4
+
+/* The number of bytes in type long long */
+#define SIZEOF_LONG_LONG 8
+
+/* The number of bytes in type short */
+#define SIZEOF_SHORT 2
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* use syslog */
+/* #undef USE_SYSLOG */
+
+/* Version number of package */
+#define VERSION "0.91.2"
+
+/* endianess */
+#define WORDS_BIGENDIAN 0
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* POSIX compatibility */
+/* #undef _POSIX_PII_SOCKET */
+
+/* thread safe */
+/* #undef _REENTRANT */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+
+#ifndef __cplusplus
+#define inline _inline
+#endif
+
+#include <osdeps.h>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamav.dsw clamav-release/contrib/msvc/clamav.dsw
--- clamav-0.91.2/contrib/msvc/clamav.dsw	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamav.dsw	2007-07-12 12:36:20.000000000 +1000
@@ -0,0 +1,98 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "clamscan"=".\clamscan.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name libclamav
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "exeScanner"=".\exeScanner.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "freshclam"=".\freshclam.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name libclamav
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "libclamav"=".\libclamav.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "sigtool"=".\sigtool.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name libclamav
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "unscrambler"=".\unscrambler.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamav.rc clamav-release/contrib/msvc/clamav.rc
--- clamav-0.91.2/contrib/msvc/clamav.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamav.rc	2007-08-21 20:59:08.968750000 +1000
@@ -0,0 +1,39 @@
+#include <windows.h>
+
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+
+VS_VERSION_INFO VERSIONINFO
+	FILEVERSION 0,91,2,0
+	PRODUCTVERSION 0,91,2,0
+	FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+	FILEFLAGS 0x1L
+#else
+	FILEFLAGS 0x0L
+#endif
+	FILEOS 0x4L
+	FILETYPE 0x2L
+	FILESUBTYPE 0x0L
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "00000409"
+		BEGIN
+			VALUE "FileDescription", "ClamWin Antivirus"
+			VALUE "FileVersion", "0, 91, 2, 0"
+			VALUE "InternalName", __MODULE__
+			VALUE "LegalCopyright", "Copyright (C) 2007 ClamAV Team / ClamWin Pty Ltd"
+			VALUE "OriginalFilename", __MODULE__
+			VALUE "ProductName", "ClamWin Antivirus"
+			VALUE "ProductVersion", "0, 91, 2, 0"
+		END
+	END
+	BLOCK "VarFileInfo"
+	BEGIN
+		VALUE "Translation", 0x0, 1033
+	END
+END
+
+#ifdef __ICON__
+100	ICON	__ICON__
+#endif
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamav.reg clamav-release/contrib/msvc/clamav.reg
--- clamav-0.91.2/contrib/msvc/clamav.reg	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamav.reg	2007-07-12 12:36:19.875000000 +1000
@@ -0,0 +1,6 @@
+REGEDIT4
+
+[HKEY_LOCAL_MACHINE\SOFTWARE\ClamAV]
+"ConfigDir"="C:\\Clamav"
+"DataDir"="C:\\Clamav\\db"
+
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamav.sln clamav-release/contrib/msvc/clamav.sln
--- clamav-0.91.2/contrib/msvc/clamav.sln	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamav.sln	2007-07-12 12:36:20.000000000 +1000
@@ -0,0 +1,78 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "clamscan", "clamscan.vcproj", "{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B} = {0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libclamav", "libclamav.vcproj", "{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "freshclam", "freshclam.vcproj", "{F88905DF-1BED-4C69-9F48-1B20FF7B084E}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B} = {0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sigtool", "sigtool.vcproj", "{5163901E-4C74-421E-A053-7599C3A9D9B8}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unscrambler", "unscrambler.vcproj", "{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "exeScanner", "exeScanner.vcproj", "{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Debug|Win32.Build.0 = Debug|Win32
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Debug|x64.ActiveCfg = Debug|x64
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Debug|x64.Build.0 = Debug|x64
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Release|Win32.ActiveCfg = Release|Win32
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Release|Win32.Build.0 = Release|Win32
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Release|x64.ActiveCfg = Release|x64
+		{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}.Release|x64.Build.0 = Release|x64
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Debug|Win32.ActiveCfg = Debug|Win32
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Debug|Win32.Build.0 = Debug|Win32
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Debug|x64.ActiveCfg = Debug|x64
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Debug|x64.Build.0 = Debug|x64
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Release|Win32.ActiveCfg = Release|Win32
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Release|Win32.Build.0 = Release|Win32
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Release|x64.ActiveCfg = Release|x64
+		{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}.Release|x64.Build.0 = Release|x64
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Debug|Win32.Build.0 = Debug|Win32
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Debug|x64.ActiveCfg = Debug|x64
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Debug|x64.Build.0 = Debug|x64
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Release|Win32.ActiveCfg = Release|Win32
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Release|Win32.Build.0 = Release|Win32
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Release|x64.ActiveCfg = Release|x64
+		{F88905DF-1BED-4C69-9F48-1B20FF7B084E}.Release|x64.Build.0 = Release|x64
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Debug|Win32.ActiveCfg = Debug|Win32
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Debug|Win32.Build.0 = Debug|Win32
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Debug|x64.ActiveCfg = Debug|x64
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Debug|x64.Build.0 = Debug|x64
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Release|Win32.ActiveCfg = Release|Win32
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Release|Win32.Build.0 = Release|Win32
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Release|x64.ActiveCfg = Release|x64
+		{5163901E-4C74-421E-A053-7599C3A9D9B8}.Release|x64.Build.0 = Release|x64
+		{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}.Debug|Win32.ActiveCfg = Debug|Win32
+		{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}.Debug|Win32.Build.0 = Debug|Win32
+		{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}.Debug|x64.ActiveCfg = Debug|Win32
+		{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}.Release|Win32.ActiveCfg = Release|Win32
+		{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}.Release|Win32.Build.0 = Release|Win32
+		{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}.Release|x64.ActiveCfg = Release|Win32
+		{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}.Debug|Win32.ActiveCfg = Debug|Win32
+		{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}.Debug|Win32.Build.0 = Debug|Win32
+		{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}.Debug|x64.ActiveCfg = Debug|Win32
+		{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}.Release|Win32.ActiveCfg = Release|Win32
+		{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}.Release|Win32.Build.0 = Release|Win32
+		{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}.Release|x64.ActiveCfg = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamscan.dsp clamav-release/contrib/msvc/clamscan.dsp
--- clamav-0.91.2/contrib/msvc/clamscan.dsp	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamscan.dsp	2007-07-12 12:36:20.031250000 +1000
@@ -0,0 +1,247 @@
+# Microsoft Developer Studio Project File - Name="clamscan" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=clamscan - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "clamscan.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "clamscan.mak" CFG="clamscan - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "clamscan - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "clamscan - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "clamscan - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "clamscan_Objs_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release\clamscan"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /O2 /I "." /I "include" /I "../.." /I "../../libclamav" /I "../../shared" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /J /FD /c
+# SUBTRACT CPP /Fr /YX
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x417 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib advapi32.lib pthreadVC2.lib /nologo /subsystem:console /machine:I386
+# SUBTRACT LINK32 /nodefaultlib
+
+!ELSEIF  "$(CFG)" == "clamscan - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "clamscan_Objs_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug\clamscan"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /I "." /I "include" /I "../.." /I "../../libclamav" /I "../../shared" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /J /FD /GZ /c
+# SUBTRACT CPP /Fr /YX
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x417 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib advapi32.lib pthreadVC2.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# SUBTRACT LINK32 /nodefaultlib
+
+!ENDIF 
+
+# Begin Target
+
+# Name "clamscan - Win32 Release"
+# Name "clamscan - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\..\clamscan\clamscan.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\clamscan\manager.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\clamscan\others.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\clamscan\treewalk.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\..\clamscan\clamscan_opt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\clamscan\global.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\clamscan\manager.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\options.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\clamscan\others.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\clamscan\treewalk.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\clamscan.rc
+
+!IF  "$(CFG)" == "clamscan - Win32 Release"
+
+# ADD BASE RSC /l 0x410
+# ADD RSC /l 0x410 /fo"Release\clamscan\clamscan.res"
+
+!ELSEIF  "$(CFG)" == "clamscan - Win32 Debug"
+
+# ADD BASE RSC /l 0x410
+# ADD RSC /l 0x410 /fo"Debug\clamscan\clamscan.res"
+
+!ENDIF 
+
+# End Source File
+# End Group
+# Begin Group "Shared"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\shared\cfgparser.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\misc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\options.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\output.c
+# End Source File
+# End Group
+# Begin Group "Compat Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\src\dirent.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\exeScanner.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\flock.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\gettimeofday.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\platform.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\regex.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\scanmem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\winstat.c
+# End Source File
+# End Group
+# Begin Group "libclamav"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\libclamav\cvd.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\dsig.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\md5.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\sha256.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\snprintf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\str.c
+# End Source File
+# End Group
+# End Target
+# End Project
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamscan.ico clamav-release/contrib/msvc/clamscan.ico
--- clamav-0.91.2/contrib/msvc/clamscan.ico	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamscan.ico	2007-07-12 12:36:19.953125000 +1000
@@ -0,0 +1,12 @@
+        h  F         ¨  ®       h  V         ¨  ¾  (                @                      ~qq |uu ),, âœœ ÿÿÿ ÑÄÄ Ñ¼¼ ÿóó ÜÍÍ % Í³³ rmm 6'' add hjj L== Ş¯¯ vv  7,,  ÙÛÛ ¼¸¸ trr bXX V33 ÿÛÛ ÿòò ;77 ®ªª ÛÚÚ –ˆˆ  *++ *-- ,'' Ş•• }qq ÿïï £ƒƒ {yy ßÜÜ ™ŠŠ  122 333 033 6"" «ee ™œœ öÂÂ ''' ½¼¼ ™˜˜  444 /00 9// Å†† ““  ÿõõ ¥uu Y[[ ¶³³     "   677 +.. aLL ÿŞŞ 366 aJJ öÈÈ \FF ¯©© ­©© %&& 000   '++ œ}} [EE ôÎÎ Y>> ½¿¿ maa +,, 888 "!!     îÎÎ fNN ÿØØ TII ´²² C>> 111 666  h[[ …77 œxx /66 ÿ×× |qq …… .// 222 -.. ÿ÷÷ à±± …?? t$$ Ä–– ‰WW èèè PAA 011 022 &** ×ÇÇ îÜÜ + í°° İ¬¬ «ll ÿêê ibb  ## /22 -44 $ ­tt óÉÉ ™{{ ¤ ÿøø ¤ŒŒ G&& R ªcc Â fRR †vv ƒqq                                                                                                                                                                                                                                                                                                                                                                                                                                                      ‘’“         „…†‡ˆ‰Š‹   Œ   yz{qf|}~ ‚ƒ  mnopqq.rqst‚‚w  bcde9f.ghi‚‚   WXYZ[.\]^_`    LMNOPQR STU    >?@ABCDEFGHI    34567.8.9:;     '()*+,-./01      !"#$%                                          ÿÿ  ğ?  à  à  À   À  À  À  À  À  à  à  ğ  ø  ü  ÿÿ  (       @         €                                                            		 
+
+              "!! ### &%% *(( ,** -,, ... /// 000 111 111 222 222 222 222 222 222 222 222 322 333 333 333 333 433 544 655 777 877 988 :99 ;;; <<< === ?>> @?? B@@ D@@ E?? G>> H;; I77 K33 L// N)) N%% R## T## Z## `$$ d"" j$$ r&& t)) v** y,, {00 }44 ~88 €;; €>> ~BB zDD wFF uGG pII jLL cNN ]NN YPP ZQQ ]SS _VV aYY d[[ f]] jaa kcc mdd ngg qii tjj wll |jj €ii ‰ff •dd œdd £dd ¨gg «ii ­jj ­oo ®tt ªxx «|| § ¥ƒƒ ­…… ¶†† ·ˆˆ º‹‹ ¼ ½ ¾’’ ½”” º•• ²–– ©•• ¡”” ›““ ›•• œ–– ˜˜ šš   ¢   £¡¡ ¤££ ¦¤¤ ¦¥¥ §¦¦ §¦¦ ¨§§ ©¨¨ «©© ­«« °­­ ±¯¯ ²°° ³²² ´³³ µµµ ··· ¹¹¹ »ºº ½½½ À¿¿ ÁÀÀ ÄÂÂ ÅÂÂ ÇÂÂ ÉÁÁ Ë¿¿ Í½½ Î¼¼ Î»» Ïºº Î·· Ïµµ Ï²² Ñ°° Ñ¯¯ Ô®® Õ«« ×©© ×§§ Ö§§ Ù¨¨ Üªª İ­­ ß®® á°° á³³ â¶¶ ä¹¹ ä¼¼ ä¿¿ äÁÁ åÄÄ çÇÇ æÉÉ çÊÊ èÊÊ èËË çÌÌ êÌÌ ìËË ğÌÌ ñÎÎ ñÏÏ ñĞĞ ñÑÑ îÒÒ íÒÒ êÓÓ éÔÔ çÕÕ èÕÕ éÖÖ ëÖÖ ïÖÖ óÖÖ öÖÖ ùÖÖ ù×× úØØ ûÙÙ úÛÛ úÜÜ ûŞŞ úßß úàà ùáá úââ úãã úää úåå ùææ ùçç øèè ùéé ùêê úìì ûîî ûğğ üññ üòò ûóó üõõ üöö ü÷÷ ıøø ÿÿÿ ıúú ıúú ıùù ×××××å×ÓÓÓÓÓ½òÌe/10!KLÓÁ½ôÚB111111#KVÁÁeûi;:/1///11`}ºÎ¹¹¹¹ÿ¦1h:/1///1//g˜×ä¹u¹¼uºÓñm?}:/1///1///oÌøÕ¹{¿†zY€ÓÓÛ;h‹=1111111111‹ØôÀQYuuWQ†ÓÆ³/o‹B/1///1///1 ™ÛïÓuXWQsóÄÁ‰/‹d/1///1////7Çìì€Vs|öÓÖ¹~1’”m/1///1///‹ÌëyXºÓì†|1˜›~11111111 a®âÃÖÓÓ‚{/”›81///1//ˆÇïıÓÓ€|1¢¢g1///$'/nÁåşÓº‚:p¤¤‹/'"$//BºÒıÓÃ†aBš™“/$1111ƒ»ûóÓ¹zŒŒl/1///1r|æıìÀº l‘8 %//1///1^tÅıîÎÂp7¡¢˜8/1///1///1FV·ûëãÇ´:oªª¨Œ6111111111IOºùæİÏ}7™ª©¨~1///1///1JP½ûäâãÑaA£ª¨§~7//1///1HX¼áåç¬<a¥©¨¥B/1///1Fv½ßßïî³9a ¨¦¤oB1115]|ÄÓßôò²<?‹§¥¢Ÿ›~oEyğĞßøõËc/b~—Ÿœ•}@iºÁğøùòB//6:66q½¾öğçşùò±‹pp‹±ÇÄğğğıùõòíçâİö×××éíóøÿÿÿÿÿàÿÿÿÀ?ÿÿ ÿş ùş ğü Àø  €ğ   ğ   ğ  à  à  à  à  ğ  ğ  ğ  ø  ø  ø  ü  ü  ş  ş  ÿ  ÿ€ ÿà ÿğ ?ÿü ÿÿÿÿÿÿÿ(                 @                                  Ÿ¿’’ÚÂ††ıÃ••à©  :ĞĞĞ                                ˆˆˆ+%%fÎ¼¼á}}¯T44±Z%%ÕHHıee½…&                        ___!  eÍ¸¸ìqmm¤444r333e333[<--{„WWéÃ¡¡â@<<X@ÄS!!ğe,,í™ZZ¢ŸŸŸS~DDÌÈÄÄŞTTT‚555f333V222J333A?==P¶­­áËººåf$$ï¡[[÷Æ‚‚ÿ£[[ø444>P??pÎ¤¤ırSSå~~~‹:::]333I333:333.333*GFFRİÓÓùÕ¤¤ş™MMÿ;;ÿ©jj˜W|oo¦ß¼¼ıa<<ğ•III\333?222.333222Dmeeº÷ßßÿ•DDÿ²||„ıûûM¢ŸŸÎá¼¼şa88ğªªª›gggh333<333(222   			v.,,HÚ¾¾òğİİ„        rrr£ŸŸËçÃÃşj==ó¡¡¡œ˜˜˜ƒ222>,,,5KzN222+˜‚‚¶şéé½            Å¾¾ôÛÛşŒ]]÷jjj¾ŸŸŸÂ222–“†   K222+3336fVVá¿¿ğ            şøøOşèèşã¶¶ıS::İœ••Î‹‹‹±(((f///B2229333<222EG99}²}}şşüü        ÿıı	ÿääïöÕÕşnnÜs\\ÉÅÅÅ¯„„„333O333M333O333V<..…^^ııûû            ÿííşÚÚş÷ÚÚıbCCİ¢¢¢«ÃÃÃ³„„„‹777b333b222hB22 Ÿeeô                ÿııÿÛÛÒşÙÙşïİİö]AAÓ~kkÉ¾¾¾º¥¥¥ªppp‘XXX‹`<<ãÙ¬¬§                    şøø ûÍÍáóÎÎşçØØÿv``ÛV;;ÜdJJßbCCğ[>>àÃ••õöéé1                        ûôôÓ¼Â††ıîÛÛıïåå÷Ã¶¶âÅ±±åëËËñöææZ                                    ×½½E­wwÆ££“êŞŞ†öííc÷õõ                ğ?  À  €                     €  €  €  À  À  à  ğ  ü  (       @          €                                                          ÒÒÒ§§§¥££²­­!¡ŸŸ¦¦¦ÒÒÒ                                                                                        ···WWW,))B‘¡âÃÃåşØØşşÖÖşşÓÓıÛµµß‘vv B::Fggg                                                                        ¹¹¹///   LdYY£õÜÜøúŞŞø±ĞHHäi##øiı€11ı©bbıâ¬¬ü¨‰‰¿ Exxx	                                                            iiiB  k|ddÅşììÿßÎÎéZVV}222u333t322r9**‘DÉTı^ş—EEıÜ¬¬óO@@~SSS                                                    BBB   X   _]44´üğğÿäØØîDCCŠ333y333r333l333f333a333]8--vR##×s44ÿŸ]]şä¶¶üo\\’AAARRR"888/=J   N2VVVœœœ            MMM   ^   S3  ‹İÅÅşşøøşb``999|888t222k333d222^222Y222T333P333PaKK¨Ÿ~~şÊ¨¨şîËËın\\©   |   |   |   |  ‚4¬J¶O&&šÜÍÍ    ˆˆˆ   R   ]+UŠ==úüùùşÀ¿¿×333|___„888n222d333]222V222P222K333G222D222Cd[[‹·§§ıãÔÔş÷İİüNBB¥   }”X$$É¨__÷Üÿåªªş¢QQşÍ¥¥È    
+
+
+1   p-//äÅ™™üöëëşnkk¤>>>{Œ888h222^333V222O222H222B333>222:22292229qnn‰ÏÍÍşøõõşíÓÓõ_İvş¿wwşê°°ş×——ÿ¾vvş•??ş·ë   `   Y{\\m¦eeÿâÄÄüêØØû:99€___„ŠŠŠ<<<d333X333P333H333A333:33353331333/333/3331ŒŒ§ÛÕÕÿığğÿá³³ı%%ÿ??ÿ¯bbÿ«\\ÿ77ÿ{  ÿÅššhBBB   u@Å¡¡ºÌ¢¢ıåÅÅşÈ±±æ222x{{{”””EEEd222S333J222B222:2223333,222(222%222%333()))I°¨¨èêİİşÿèèÿôÒÒş¤ccş;;şŒ66ÿ{!!ş•OOÂõîî/   {=Ú¼¼óŞ¿¿ıß¶¶ş®””×222u’’’•œœœTTTg222O333F222=2224222,333$222222222222W855§ÖÆÆıúååÿşååşÂ††ş…33ş˜TTı²~~‹÷òò    8   |%""jé××şèÒÒüØ§§ş¡ƒƒÑ333s¡¡¡›¤¤¤“jjjn222L333C22292220222'333222222222&&&$w†—‹‹¿æÏÏÿşääş­nnşˆ::íÆ¡¡N               -   {@>>–øóóÿòååıÑ˜˜ÿ¡||Ó333r§§§«««–ˆˆˆ{333J333A3337333-333#333333333	(((U			ˆhOJJSÕ¼¼şûÚÚÿß¼¼äãÑÑ                OOO   sPPP¤şüüş÷ììıË‰‰ş©yyŞ222r¤¤¤±±±›«««777L333@2226222,222#333222   I€
+
+
+|###9222,®™™ÎêÈÈşşèèøşıı                £££   TOMM¤şùùşıõõşÉ……ş¹zzğ333r–––™··· ···•\\\_333A2228222.222$///-`€H111%222.vhh‰Ù¶¶şşŞŞüşúú^                    ---@>>şööşÿõõÿÕşÌ‰‰ş?88†}}}‘»»»¥»»»›‘‘‘|222D111=,,,<!!!Gc
+
+
+ˆN///$222)2221GBBRÊ§§şüĞĞüşûû                    ×××?==>ÿòòÿÿòòÿä»»şÓ——ÿ]HHÇHHH¬©©©Â¨¨¨¸£££°222~ˆ‘}H///&333(333/3337333?°èŞ¨¨şüøøĞ                        ÚÚÚşğğõÿîîÿñÓÓşÛ¤¤ş–rræ!!!·•••ÕšššÓ•••Îfff¼ œ˜Œk&&&=222+333,22212226222=333E„ddÇ¹}}şğßßõşşş                        şğğÂÿëëÿüååşâ³³şÖ¥¥û*''ºfffÈ   Ö›››Ò–––Ì777¦‹o'''M00082224222433362229222>222D333KeII±™WWşàÁÁüıüü                        şóó|ÿèèÿşççşîÊÊıå¸¸ş{gg¿666±±±Â¶¶¶¾···³§§§777V222G333B222?222>222>333?222B222G222L333RR88§~33şÓªªıüøø!                        ÿúú'ÿååşÿääÿùÛÛşíÆÆşÖ±±ğ988{yyy”ÇÇÇ¶ÆÆÆ¯ÄÄÄ§•••ˆ444P333K333I333H333H333I333L333O333T333ZF++§fÿÏ££üûöö!                            ÿèèÀşààşşßßşôÔÔşğÌÌÿ}}»555v¨¨¨¬ÇÇÇ·ÅÅÅ°ÃÃÃ¨„„„‚333U222S222R222R333S222U222X222]333bC&&±jşØ­­üüøø                            ÿôôGşİİşşÜÜşüÚÚş÷ÚÚşîÏÏûTNN’CCC~¹¹¹¶ÆÆÆ¸ÄÄÄ²ÁÁÁ«………ˆ555]222[222\333]222_222b222f333jJ,,Ã‰;;üÚ««ñ                                    şãã¹şÙÙşşØØşüŞŞıûààş×¿¿é=;;„MMM…¼¼¼ºÅÅÅºÂÂÂ´¾¾¾¯™™™™DDDn222e333f222h222k222o333sZ66Ş¬eeüÛ­­Â                                    ÿøø"ÿ××òÿÕÕÿşÕÕşşèèşıççÿÄ±±Ü877„LLLˆ´´´¹ÃÃÃ½¿¿¿¸»»»³±±±¬zzz‘GGGy333r333t333x533‚wGGúÂ||ıãÀÀ~                                        şííZşÒÒşÿÑÑÿıÖÖşşïïşşììşÄ´´Ü<;;Œ>>>‡’’’­ÀÀÀÀ¼¼¼¼···¸²²²´¬¬¬±›››©‡‡‡¢rrrœF;;³¢nnüÌˆˆıõéé$                                            şää‚ÿÎÎÿşÍÍşüÖÖşşôôşÿññÿÚËËêTQQŸ222ŠPPP•†††¬¦¦¦¹²²²¾®®®»¥¥¥¸€€€«@??•|``ëÓššşàµµ¨                                                    üŞŞˆò»»şë±±şé½½ıüõõışööşùììû ——ÍECC222“222’444“888•444•544™ƒnnÍİ­­şß®®íùòò                                                        ïÓÓiÒ’’øÊ……ÿËıñààıÿúúÿÿööÿùììüÄ··â”ŠŠË|ssÁttÃŒŒÓ×¸¸òìÅÅÿé¿¿õöééA                                                                ğàà0¿€€Ê©YYÿ£RRşÄ’’üõééıÿûûÿşööşşññşşëëşıææÿúààş÷ÙÙşô×××ûòò4                                                                        ıüüØ¸¸U¢ZZÂ€##ı}  ş ]]üÊ¥¥ıèÔÔşóââüøææáıíí«şôôXşşş                                                                                        âØØÓ¿¿*ÔÀÀ,ÙÉÉ'âØØìéé                                                ÿÀÿş ÿø ÿğ ÿà  À   €   €                          €  €  À  à  à  à  ğ  ğ  ø  ø  ü  ş  ÿ  ÿ€ ?ÿÀ ÿà ÿÿüÿ
\ No newline at end of file
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamscan.rc clamav-release/contrib/msvc/clamscan.rc
--- clamav-0.91.2/contrib/msvc/clamscan.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamscan.rc	2007-07-12 12:36:19.906250000 +1000
@@ -0,0 +1,3 @@
+#define __MODULE__	"clamscan.exe"
+#define __ICON__	"clamscan.ico"
+#include <clamav.rc>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/clamscan.vcproj clamav-release/contrib/msvc/clamscan.vcproj
--- clamav-0.91.2/contrib/msvc/clamscan.vcproj	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/clamscan.vcproj	2007-07-12 12:36:19.906250000 +1000
@@ -0,0 +1,548 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="clamscan"
+	ProjectGUID="{6F92200A-5A5A-43E5-9DC4-34BE604F7CF7}"
+	RootNamespace="clamav"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\clamscan"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../shared"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				MinimalRebuild="true"
+				ExceptionHandling="1"
+				BasicRuntimeChecks="3"
+				SmallerTypeCheck="false"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="pthreadVC2.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\clamscan"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../shared"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				MinimalRebuild="true"
+				ExceptionHandling="1"
+				BasicRuntimeChecks="3"
+				SmallerTypeCheck="false"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="pthreadVC2.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\clamscan"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../shared"
+				PreprocessorDefinitions="WIN32;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="pthreadVC2.lib"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\clamscan"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../shared"
+				PreprocessorDefinitions="WIN32;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="pthreadVC2.lib"
+				LinkIncremental="1"
+				GenerateDebugInformation="false"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+		<ProjectReference
+			ReferencedProjectIdentifier="{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}"
+			RelativePathToProject=".\libclamav.vcproj"
+		/>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\clamscan\clamscan.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\clamscan\manager.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\clamscan\others.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\..\clamscan\treewalk.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\clamscan\clamscan_opt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\clamscan\global.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\clamscan\manager.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\misc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\options.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\clamscan\others.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\clamscan\treewalk.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\clamscan.rc"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Shared"
+			>
+			<File
+				RelativePath="..\..\shared\cfgparser.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\getopt.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\misc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\options.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\output.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Compat Files"
+			>
+			<File
+				RelativePath=".\src\dirent.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\exeScanner.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\flock.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gettimeofday.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\platform.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\regex.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\scanmem.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\winstat.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="libclamav"
+			>
+			<File
+				RelativePath="..\..\libclamav\cvd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\dsig.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\md5.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\sha256.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\snprintf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\str.c"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/exeScanner.dsp clamav-release/contrib/msvc/exeScanner.dsp
--- clamav-0.91.2/contrib/msvc/exeScanner.dsp	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/exeScanner.dsp	2007-07-12 12:36:19.890625000 +1000
@@ -0,0 +1,114 @@
+# Microsoft Developer Studio Project File - Name="exeScanner" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=exeScanner - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "exeScanner.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "exeScanner.mak" CFG="exeScanner - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "exeScanner - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "exeScanner - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "exeScanner - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "tools" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "exeScanner - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "tools" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "exeScanner - Win32 Release"
+# Name "exeScanner - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\src\exeScanner.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\tools\exeScanner_app.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\tools\exeScanner.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\tools\exeScanner.rc
+# End Source File
+# End Group
+# End Target
+# End Project
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/exeScanner.vcproj clamav-release/contrib/msvc/exeScanner.vcproj
--- clamav-0.91.2/contrib/msvc/exeScanner.vcproj	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/exeScanner.vcproj	2007-07-12 12:36:19.984375000 +1000
@@ -0,0 +1,211 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="exeScanner"
+	ProjectGUID="{B60E2DB6-5FFB-4C08-BD9E-2142EB3FD377}"
+	RootNamespace="exeScanner"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="tools"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;$(NOINHERIT)"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="tools"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;$(NOINHERIT)"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\src\exeScanner.c"
+				>
+			</File>
+			<File
+				RelativePath=".\tools\exeScanner_app.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\tools\exeScanner.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\tools\exeScanner.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/freshclam.dsp clamav-release/contrib/msvc/freshclam.dsp
--- clamav-0.91.2/contrib/msvc/freshclam.dsp	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/freshclam.dsp	2007-07-12 12:36:19.937500000 +1000
@@ -0,0 +1,265 @@
+# Microsoft Developer Studio Project File - Name="freshclam" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=freshclam - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "freshclam.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "freshclam.mak" CFG="freshclam - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "freshclam - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "freshclam - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "freshclam - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "freshclam_Objs_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release\freshclam"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "." /I "include" /I "../.." /I "../../libclamav" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /J /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x417 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib ws2_32.lib iphlpapi.lib advapi32.lib pthreadVC2.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "freshclam - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "freshclam_Objs_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug\freshclam"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "." /I "include" /I "../.." /I "../../libclamav" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /J /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x417 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib ws2_32.lib iphlpapi.lib advapi32.lib pthreadVC2.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "freshclam - Win32 Release"
+# Name "freshclam - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\..\freshclam\dns.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\execute.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\freshclam.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\manager.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\mirman.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\nonblock.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\notify.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\..\freshclam\dns.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\execute.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\manager.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\mirman.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\nonblock.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\freshclam\notify.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\options.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\freshclam.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\freshclam.rc
+
+!IF  "$(CFG)" == "freshclam - Win32 Release"
+
+# ADD BASE RSC /l 0x410
+# ADD RSC /l 0x410 /fo"Release\freshclam\freshclam.res"
+
+!ELSEIF  "$(CFG)" == "freshclam - Win32 Debug"
+
+# ADD BASE RSC /l 0x410
+# ADD RSC /l 0x410 /fo"Debug\freshclam\freshclam.res"
+
+!ENDIF 
+
+# End Source File
+# End Group
+# Begin Group "Compat Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\src\dirent.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\dnsquery.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\flock.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\gettimeofday.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\platform.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\winstat.c
+# End Source File
+# End Group
+# Begin Group "Shared"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\shared\cdiff.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\cfgparser.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\misc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\options.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\output.c
+# End Source File
+# End Group
+# Begin Group "libclamav"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\libclamav\cvd.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\dsig.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\lockdb.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\md5.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\sha256.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\snprintf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\str.c
+# End Source File
+# End Group
+# End Target
+# End Project
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/freshclam.ico clamav-release/contrib/msvc/freshclam.ico
--- clamav-0.91.2/contrib/msvc/freshclam.ico	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/freshclam.ico	2007-07-12 12:36:20.046875000 +1000
@@ -0,0 +1,12 @@
+        h  F         ¨  ®       h  V         ¨  ¾  (                @                      tss ‰„„ ÊÃÃ ÖÏÏ —”” wxx "$$ ÿøø ¸®® ÚÒÒ ĞÎÎ ÈÅÅ àŞŞ âââ ÿÿÿ  !!  ñéé Şáá ÙÍÍ » ¬™™ ´tt ¬ii ­]] §ss € $$$ ûıı ÙÏÏ ÇÁÁ ÎÀÀ Æ–– Ç Æ•• Ç LL €** %&& õõõ ììì ¹¬¬ íññ Ã Ëœœ µpp ¡NN ™DD KK ™FF 11 ÂÌÌ ‘‘ ÚÕÕ ¿¶¶ çéé éòò Ã ¤RR ¤TT ¨XX ¨VV §VV ¨UU EE èÌÌ VSS îëë İÜÜ ÕĞĞ éîî ØÇÇ ©ii ²jj «YY Ê¡¡ ÚÎÎ âÉÉ ÑÏÏ ©UU È¤¤ ÿúú óóó Á²² æææ ØĞĞ ©RR «\\ èââ ïöö íïï êğğ àËË ²dd É¥¥ %"" xll ¦tt çîî ÙÈÈ Æ¨¨ Â££ Ì¤¤ óúú ñòò ñóó âÚÚ ¸qq äÅÅ ;99 ‘‡‡ „ Æšš ¶ŠŠ KK ¥SS Â‰‰ êññ öúú Ú¼¼ Î…… ¨ŸŸ [XX ›‘‘ åéé šHH ª]] ¼~~ Ê ¸kk ¿}} Õ²² úÿÿ Ó¶¶ à¡¡ |„„ _[[ š‘‘ ¬«« Í¦¦ ‹22 ¼}} Ï Ú¤¤ æ¿¿ İ«« ëññ Ó A<< èïï •AA £QQ °ii ºyy È‹‹ Ôœœ İ¬¬ á³³ Ê§§ üåå '++ -)) MHH ¦ ˜ íææ ¤OO ¨WW ´mm ½~~ Ò Õ˜˜ í¬¬ ²›› &"" 666 MGG €zz ’‰‰ ÎÒÒ âÀÀ Í““ Ó‘‘ Ó®® Øµµ QUU YRR  \UU SLL soo unn uoo )&&                                                                                                                                                                                                                                                          ¶¶¶¶¶         ²³´µ¶·¸¹¶      ¤¥¦§¨©ª«¬­®    zo–—˜™š›œŸ    Š‹Œ?J‘’“”  |}~>J€‚ƒ„…†‡  opqrstuvwxyz abcdefghiSjklm RSTUVW/XYZ[\]^_  DEFGHIJKLMNOPQ  6789:;<=>?@AB  ()*+,-./01234    !"#$%&            	
+               ø?  à  À  €  €  €  €   €   €   À   À   À   à  ğ  ø  ü?  (       @         €                                                  
+
+
+      """ $$$ ''' +** .-- 0// 322 544 955 ?88 C:: K:: S:: [77 f33 m22 t00 z.. -- ƒ-- †// ˆ11 ‰22 Œ66 99 ;; == ‘?? “AA ”CC –DD —EE ˜FF ˜GG ™HH šII ›JJ LL MM  OO  PP ¡QQ ¢QQ ¢RR £RR ¤SS ¤TT ¥TT ¥UU ¦WW §XX ¨YY ¨ZZ ©[[ ©[[ ¨[[ ¥[[  [[ ›[[ –[[ Œ\\ ‚]] x`` qcc off qmm wqq }qq †pp ’ll hh §ee «dd ®dd ¯ee ±ff ±gg ²hh ²ii ²kk ³mm ´nn ´pp ´qq µqq ·rr ·ss ¹tt »uu »ww ¼xx ½{{ ¼}} »~~ » ½€€ ½€€ ¾‚‚ ¿ƒƒ À…… Ã†† Ä‡‡ Æˆˆ Ç‰‰ È‰‰ ÇŠŠ ÆŒŒ Ä ÂŒŒ ¾ŒŒ ¸ ³ ® © ¢  — š’’ ”” Ÿ•• ¡–– ¥˜˜ °—— ¸—— ¾—— À—— Â—— Ä—— Ç–– Ê•• Î”” Ò““ Ó”” Õ•• Õ—— Õ˜˜ Õšš Ô ÓŸŸ Ó¡¡ ×££ Ù¤¤ Ú§§ Õ¨¨ Ò¨¨ É©© Àªª ¶ªª ¹¬¬ ½®® Ç°° È²² Èµµ É¸¸ É»» Æ½½ Å¿¿ ÄÀÀ ÅÁÁ ÅÂÂ ÇÃÃ ÌÂÂ ÑÁÁ Ø¿¿ ß¼¼ ã»» ã¼¼ á¿¿ İÃÃ ÜÅÅ ×ÇÇ ÖÉÉ ÕËË ÔÌÌ ÔÍÍ ÕÎÎ ØÎÎ ÚÏÏ ÚĞĞ ÚĞĞ ÜÑÑ İÓÓ İÔÔ ÜÕÕ ÜÖÖ Ü×× ÜÙÙ İÙÙ ŞÚÚ ßÛÛ áÜÜ áİİ âİİ áŞŞ âßß áàà âàà âáá âáá âââ ãââ ããã ããã äää ååå ååå æææ æææ ççç èèè ééé êêê ëëë ììì îíí îíí îîî ïïï ğïï ğğğ ñññ ñññ òòò òòò óóó óóó ôôô õõõ õõõ ööö ÷÷÷ ùøø úúú ûûû üüü ııı ııı ÿÿÿ ııı PPPPPS¤…………R……TP‰T…………†×Õ´¡¡©¼¿T¦±…………TáÂwZ]bilrw|Ÿ½TT¤	…………¥åAGZaglry”•˜™Ÿ¬…¦…………¤ær7BZ]ckqw”–šœŸ¢……………ê29DZ`glu{•šŸŸŸz§º¬T…………Šè¼-3=GZajov”™œŸ¶¶¶¢ÁŸÄı…………­ğ`-4>G[bjqy”™Ÿ¶·ŸÙ´Õÿ………QèÉ)-5>G[bkrz”š¶¶¸Ÿìè›Ÿ÷………Šõ(-<>G[bjqy”™Ÿ—™ªòìÁ™ºÿ……Š­÷b(Yw`GZajov|`AcœøõîÄœ˜—÷R……SÆø>(mtk*6`gluq©èöùûøöğŞ™•{ÄŠ…Òù04§³£q(3;gºèîõøø÷óîè{”vŸÿ¤‰Øú3¥³Ô×¢~Ç£ŒaÌæêğóõóğêæ¨wrrı¦ŠÔıa±Ô×ØD¬tu´äèêîîìêæäµrlièóŠÍÿ¯Ï×Øb_=_b|áäåèèèåãá¡libÏû¥ÀÿÅ®ÈØÛÆoGd/6b›ÄâãããâàÜœgb^È­±ÿæ­½ØÛÜ»dW~n>[f´ÜŞŞÜÛ×`]ZÌÈ­õÿ±¯ÒÛÜÜÌqAGm_^`f‘¢œš««ZZEåè±Ûÿá­¿ÛÜÜÓ~i>CGZZZ[[[ZZZGBYÿÿÀÊûÿ¾®ËÜÜÜ¢‘n?>BDGGGGGDB>8|ÿèÎêÿõ­­ÒÜÜ¢‘|\89=>>>=974-ÅÿÿŞØøÿà‹­ÏÜª‘|t_?55442/#rúøĞĞúûĞ‹¯ÎĞ||||~slc/(#¤ÑıèÀËğğÎª­­§¢||~wtqg$-ÄóØ±ÀàáÏ‚­Œ­hqqo`9'?±ÀâÓ¬®ËÏÍ½q­M‚qLqqq¿¦ÀÔıâª¦¯ÀÀÀ°°­¤¿¿¿¿«¿àøÀŠŠ©±¾¾¾¾¾¾¾¿Ò÷öÀ¥…‰Š¤¤¥±ŞûûèÛ×åıÿÀÿş ÿø  à  ?À  €  €                    €   €   À   À   À   à   à   à   à   ğ   ğ  ø  ü  ş  ÿ  ÿ€ ÿÀ ?ÿğ ÿÿşÿ(                 @                              àààŠŠŠOOO2DDDPmmmorrrllllI†††ããã                        ddd]‹Ÿ››ÖÍ««ıÅÿÈÿÒ¢¢ÿ¿¡¡êfaaŒ                ,,,5   x---•ÏÁÁõ¬eeÿ¯aaÿ»rrÿÇÿÒÿÚššÿß¤¤ÿ§Í¯¯¯        aaa   yĞËËó¤YYÿ¦UUÿ³ggÿÁyyÿÎŠŠÿÚššÿå©©ÿë²²ÿÏ¬¬ÿÛ¾¾Çşşş    L   }ŒŒŒßÄ››ÿšEEÿ¨WWÿµjjÿÃ||ÿÑÿŞ  ÿì²²ÿêµµÿæààÿİ££ÿòßß‰    P—ÓÓÓÿ¤^^ÿ¨__ÿ«]]ÿµiiÿÂ{{ÿÏŒŒÿÅÿÊ““ÿÛ»»ÿòòòÿâ¸¸ÿÛ¤¤øıııUUU$AAAµéééÿ•FFÿ¾““ÿµ††ÿ¢[[ÿ°bbÿÈÿçààÿ÷÷÷ÿùùùÿóóóÿŞ¾¾ÿĞÿïİİv    ~~~™ïïïÿ¯‰‰ÿİÙÙÿÓÀÀÿÂÿÀ™™ÿÉ¡¡ÿìììÿñññÿóóóÿïïïÿáÑÑÿÇ‚‚ÿŞ¸¸µ    ĞĞĞƒéééÿÆ¹¹ÿİİİÿÖÉÉÿ¯llÿ¦\\ÿ¶nnÿßĞĞÿêêêÿëëëÿéééÿÚÄÄÿ½ttÿÑ¢¢Ò    äääVİİİÿÜÜÜÿÓÓÓÿãããÿĞ½½ÿ¯ssÿ¯jjÿµjjÿË  ÿØÂÂÿÖÁÁÿÑ¼¼ÿ²eeÿÎ  Î    úúúÕÕÕõøøøÿÆÆÆÿáááÿäããÿÂ‘‘ÿ«__ÿ©YYÿ­^^ÿ¯aaÿ®``ÿ«\\ÿ¦UUÿÛ»»§        ëëëòòòÿæææÿ·¡¡ÿâââÿÈ££ÿÄ““ÿ´ssÿ¦XXÿ¡OOÿ NNÿJJÿ™LLÿ÷òòW        ıııŞŞŞ×ğğğÿÖÑÑÿÀ··ÿÈ¯¯ÿÃ˜˜ÿÁÿ¾ŠŠÿ¹ÿ TTÿIIÿÚÑÑÑşşş            ÷÷÷ ÌÌÌÜÙÙÙÿĞÉÉÿµ££ÿ›aaÿ¬‚‚ÿ¡bbÿ“BBÿ–WWÿÒÑÑçøøø&                    ùùùËËË¶¶¶ûÇÇÇÿÈÇÇÿÃ¿¿ÿ®ŒŒÿ¶ûÙ××ªøøø                                ñññÎÎÎjÂÂÂ’ÈÈÈ’ÛÛÛg÷÷÷                à  À  €                €   €   €   €   À   À   à  ğ  ü  (       @          €                                                          ´´´‡‡‡
+ccc______!___"______vvv§§§                                                                            •••;;;8   T   e
+
+
+uBBB™nnnµ‡‡‡ÃŒŒŒÄ€€€¹aaaŸ000s>444–––                                                        |||*   W   r   {$$$’’’Íáááùåààÿ×¾¾ÿĞªªÿÎ££ÿÑ¨¨ÿ×µµÿßÉÉÿÓÍÍñ¹a±±±                                        ÇÇÇ      V   w   |~zzz¿çççüŞÏÏÿ¾ˆˆÿ¯bbÿ³ggÿ¹nnÿ¾uuÿÃ||ÿÈ‚‚ÿÌˆˆÿĞÿÙ©©ÿßËËû¶@zzz                                ªªª-   k   |   }
+
+
+‚¬¬¬ÚìëëÿÅ››ÿ¥UUÿ«[[ÿ±ddÿ·llÿ½ssÿÂ{{ÿÈ‚‚ÿÍ‰‰ÿÑÿÕ””ÿØ˜˜ÿÚ››ÿß¯¯ÿÈ½½ç+++Y                        ³³³2   r   |   }~ªªªØíììÿ¸‚‚ÿ MMÿ§VVÿ­__ÿ´ggÿºppÿÀxxÿÆ€€ÿÌˆˆÿÑÿ×––ÿÛœœÿŞ  ÿá¤¤ÿá¥¥ÿá¦¦ÿÇ§§õMMMW                        !   n   |   }~‡‡‡ÑïïïÿÁ””ÿ›GGÿ¢PPÿ©YYÿ¯bbÿ¶jjÿ¼ssÿÃ||ÿÉ„„ÿÏŒŒÿÕ””ÿÛœœÿà££ÿä©©ÿç¬¬ÿè®®ÿÉŠŠÿÈ°°ÿâÅÅö¼¼¼>                ‚‚‚   T   |   }   }PPPÂíííÿİÊÊÿ—AAÿœHHÿ£RRÿª[[ÿ±ddÿ·mmÿ¾vvÿÅÿÌ‡‡ÿÒÿÙ™™ÿß¡¡ÿå©©ÿê°°ÿîµµÿï··ÿÉ¦¦ÿãÎÎÿä¨¨ÿëĞĞëııı            444   p   }   }œ¿¿¿şòòòÿªjjÿ—AAÿIIÿ¤SSÿ«\\ÿ²eeÿ¹nnÿÀwwÿÆ€€ÿÍ‰‰ÿÔ’’ÿÛ››ÿá¤¤ÿè­­ÿîµµÿó½½ÿç­­ÿçââÿÕ¿¿ÿá¤¤ÿá¤¤ÿğààÁşşş        (((-   y   }   }gggãíííÿäÖÖÿ88ÿ—AAÿJJÿ¤SSÿ«\\ÿ²eeÿ¹nnÿÀxxÿÇÿÎŠŠÿÔ““ÿÛœœÿâ¥¥ÿé¯¯ÿğ¸¸ÿöÀÀÿÙ¨¨ÿğğğÿíííÿÓŸŸÿá¤¤ÿŞ§§ÿú÷÷c        (((0   z   }š¢¢¢ÿõõõÿÄ››ÿ77ÿ—AAÿ¢RRÿ¤SSÿ«\\ÿ²eeÿ¹nnÿÀwwÿÆ€€ÿÍ‰‰ÿÔ’’ÿÛ››ÿá¤¤ÿæªªÿ×——ÿÚššÿÕ¹¹ÿóóóÿğğğÿçÎÎÿà££ÿÚššÿçÇÇäşşş    ***"   s   }MMMÇ¿¿¿ÿ÷÷÷ÿ¬ooÿ77ÿ©ccÿ¿ˆˆÿ±kkÿª[[ÿ±ddÿ¸mmÿ¾vvÿÅÿÌ‡‡ÿĞÿµjjÿ¢UUÿªppÿÂœœÿÅ¡¡ÿøøøÿõõõÿñññÿãĞĞÿŞ  ÿØ˜˜ÿÔ——ÿú÷÷b    jjj   \   |tttéÓÓÓÿøøøÿSSÿ77ÿµ||ÿ¼……ÿ´xxÿ’::ÿKKÿ¶jjÿ¼ssÿÃ||ÿÉ„„ÿ½€€ÿÎ¶¶ÿïííÿöööÿúúúÿüüüÿùùùÿöööÿòòòÿêååÿÚššÿÕ””ÿÏŒŒÿéĞĞÅ        'süŞŞŞÿúúúÿ•EEÿ“IIÿÇ®®ÿÀœœÿÏ¿¿ÿ¾§§ÿ©€€ÿŠ77ÿœHHÿ£QQÿ¼ssÿÜÇÇÿíííÿñññÿõõõÿøøøÿùùùÿ÷÷÷ÿôôôÿñññÿíííÿÉŒŒÿÑÿË‡‡ÿ×¦¦ışşş    ¨¨¨E–––ÿâââÿûûûÿ–HHÿ»¬¬ÿÒÄÄÿàààÿáááÿÆ¤¤ÿ»‹‹ÿÖÔÔÿÃ¬¬ÿ¸““ÿ¨mmÿáØØÿìììÿïïïÿòòòÿôôôÿõõõÿôôôÿòòòÿïïïÿìììÿÕ³³ÿÌˆˆÿÇ‚‚ÿÆ‚‚ÿşııU        ²²²#ÿàààÿıııÿ¨mmÿÃÃÃÿàààÿáááÿâââÿÄ™™ÿ©YYÿÎ½½ÿ¾††ÿÅÿÄ††ÿØ¹¹ÿêêêÿíííÿïïïÿñññÿñññÿğğğÿïïïÿìììÿêêêÿÚ¼¼ÿÇ‚‚ÿÃ||ÿ¾uuÿöííƒ        ôôô£££ÿÚÚÚÿşşşÿ¼’’ÿÁÁÁÿÜÜÜÿáááÿâââÿºÿ²nnÿ¯iiÿ¤RRÿµiiÿºooÿÆÿçççÿêêêÿëëëÿíííÿíííÿíííÿëëëÿéééÿçççÿÑ¥¥ÿÂ{{ÿ¾uuÿ¹nnÿîÜÜ         üüü¬¬¬÷ÏÏÏÿÿÿÿÿÜÑÑÿÀÀÀÿÕÕÕÿâââÿãããÿÛÓÓÿ´ÿ©[[ÿ¬qqÿ“DDÿKKÿ¹ooÿÌŸŸÿßĞĞÿèèèÿéééÿéééÿéééÿèèèÿæææÿäääÿÌ  ÿ¼ssÿ¸nnÿ´hhÿêÕÕ¬            ¾¾¾ÌÃÃÃÿşşşÿìììÿ¿¿¿ÿËËËÿâââÿãããÿäääÿÕÆÆÿ¨rrÿ¡jjÿ¼‹‹ÿº~~ÿŸSSÿ²eeÿ»rrÿ×ÀÀÿåääÿåååÿåååÿäääÿãããÿáááÿÂœœÿ·kkÿ³ggÿ¯aaÿìÙÙ¨            ÕÕÕ¿¿¿ÿõõõÿşşşÿÇÇÇÿÁÁÁÿŞŞŞÿãããÿäääÿäääÿßÙÙÿºÿ¦UUÿª[[ÿ¹}}ÿ³iiÿ´hhÿ¶kkÿºrrÿÆ••ÿÎ««ÿÊ  ÿÈÿÑ»»ÿĞººÿ±ccÿ­__ÿªZZÿôëë“            ííí>ÆÆÆÿãããÿÿÿÿÿçççÿ¿¿¿ÿÍÍÍÿãããÿäääÿäääÿâßßÿ¿ÿ¶uuÿ¥SSÿ¨XXÿ«\\ÿ­__ÿ°bbÿ±ddÿ²eeÿ²eeÿ²eeÿ±ddÿ¯bbÿ­__ÿ«[[ÿ¨WWÿ¬aaÿşşşl            şşşÒÒÒØ×××ÿüüüÿşşşÿÌÌÌÿÀÀÀÿÙÙÙÿäääÿäääÿäääÿË¨¨ÿÇ——ÿº~~ÿ¤TTÿ¥SSÿ§WWÿ©YYÿª[[ÿ«\\ÿ«\\ÿ«\\ÿª[[ÿ©YYÿ§VVÿ¤SSÿ¡OOÿÂÿÿÿÿ2                íííbÛÛÛÿïïïÿÿÿÿÿõõõÿÀ¿¿ÿÁ¿¿ÿŞŞŞÿäääÿäääÿÈ¦¦ÿÆ——ÿÆ––ÿÁÿ­ffÿ¡OOÿ¢PPÿ¤RRÿ¤SSÿ¥SSÿ¤SSÿ£RRÿ¢PPÿ MMÿIIÿ—AAÿæÑÑàÿÿÿ                şşşåååÏâââÿùùùÿÿÿÿÿæææÿ°  ÿ‹HHÿİÜÜÿäääÿÏ¹¹ÿÄ––ÿÅ––ÿÄ””ÿÄ’’ÿ½††ÿ®iiÿ£TTÿJJÿJJÿIIÿIIÿ›GGÿ™DDÿ|##ÿ´‚‚ÿûûû{                        øøø2İİİøİİİÿûûûÿüüüÿİİİÿ­ššÿÂÁÁÿÛÛÛÿàİİÿÁ””ÿÀÿÃ““ÿÂ‘‘ÿÁÿÀÿ¿ŠŠÿ¼„„ÿ¶zzÿ°ppÿ˜DDÿ66ÿ|ÿ¸¤¤ÿäİİêııı                            íííhÒÒÒşØØØÿòòòÿòòòÿÛÛÛÿ»··ÿ¨‹‹ÿ¸ÿÈ¯¯ÿÇªªÿÂ““ÿÁ‘‘ÿÀÿ¾‹‹ÿ½ˆˆÿ»……ÿ¹ÿ±ssÿ…**ÿ…AAÿ«ÿÖĞĞşôôô\                                    âââƒÇÇÇşÎÎÎÿæææÿçççÿÜÜÜÿ­‘‘ÿ§‰‰ÿ¾¹¹ÿ¹ÿ¥ddÿ­ttÿµ€€ÿ¶ÿ·ÿ«kkÿœPPÿ‹22ÿ‘TTÿÅÅÅÿÒÑÑÿèèè˜                                            ßßßv¼¼¼üÀÀÀÿØØØÿÜÜÜÿÚÚÚÿËËËÿ¥€€ÿ~((ÿYYÿ«““ÿ¢€€ÿ˜bbÿ$$ÿ‚%%ÿ‚%%ÿƒ))ÿ¼®®ÿÏÏÏÿààà ııı                                                èèèF¸¸¸ä¯¯¯ÿÁÁÁÿÑÑÑÿĞĞĞÿÏÏÏÿÆÂÂÿÂÂÂÿ¿¾¾ÿ¶§§ÿ•YYÿ‹??ÿ—YYÿª‚‚ÿÃººÿÍÍÍõæææo                                                            øøøÎÎÎ‡¥¥¥ò£££ÿµµµÿÈÈÈÿÌÌÌÿÌÌÌÿÌÌÌÿÌÌÌÿÌÌÌÿÌÌÌÿÌÌÌÿÍÍÍòŞŞŞ–÷÷÷                                                                        öööÑÑÑg¬¬¬·ñ–––ÿ¡¡¡ÿ©©©ÿ«««ş¬¬¬îÃÃÃ­åååTüüü	                                                                                            üüüíííããã0ááá0ëëëııı                                            ÿÀÿş ÿø  à  ?À  €  €                    €   €   À   À   À   à   à   à   à   ğ   ğ  ø  ü  ş  ÿ  ÿ€ ÿÀ ?ÿğ ÿÿşÿ
\ No newline at end of file
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/freshclam.rc clamav-release/contrib/msvc/freshclam.rc
--- clamav-0.91.2/contrib/msvc/freshclam.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/freshclam.rc	2007-07-12 12:36:20.031250000 +1000
@@ -0,0 +1,3 @@
+#define __MODULE__	"freshclam.exe"
+#define __ICON__	"freshclam.ico"
+#include <clamav.rc>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/freshclam.vcproj clamav-release/contrib/msvc/freshclam.vcproj
--- clamav-0.91.2/contrib/msvc/freshclam.vcproj	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/freshclam.vcproj	2007-07-12 12:36:20.031250000 +1000
@@ -0,0 +1,552 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="freshclam"
+	ProjectGUID="{F88905DF-1BED-4C69-9F48-1B20FF7B084E}"
+	RootNamespace="freshclam"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\freshclam"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib iphlpapi.lib pthreadVC2.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\freshclam"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib iphlpapi.lib pthreadVC2.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\freshclam"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				RuntimeLibrary="2"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib iphlpapi.lib pthreadVC2.lib"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\freshclam"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				RuntimeLibrary="2"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib iphlpapi.lib pthreadVC2.lib"
+				LinkIncremental="1"
+				GenerateDebugInformation="false"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+		<ProjectReference
+			ReferencedProjectIdentifier="{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}"
+			RelativePathToProject=".\libclamav.vcproj"
+		/>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\freshclam\dns.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\execute.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\freshclam.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\manager.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\mirman.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\nonblock.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\notify.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\freshclam\dns.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\execute.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\manager.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\mirman.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\misc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\nonblock.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\freshclam\notify.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\options.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\freshclam.rc"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Shared"
+			>
+			<File
+				RelativePath="..\..\shared\cdiff.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\cfgparser.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\getopt.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\misc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\options.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						ObjectFile="$(IntDir)\$(InputName)1.obj"
+						XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\..\shared\output.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Compat Files"
+			>
+			<File
+				RelativePath=".\src\dirent.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\dnsquery.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\flock.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gettimeofday.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\platform.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\winstat.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="libclamav"
+			>
+			<File
+				RelativePath="..\..\libclamav\cvd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\dsig.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\lockdb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\md5.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\sha256.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\snprintf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\str.c"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/dirent.h clamav-release/contrib/msvc/include/dirent.h
--- clamav-0.91.2/contrib/msvc/include/dirent.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/dirent.h	2007-07-12 12:36:18.562500000 +1000
@@ -0,0 +1,57 @@
+/*
+ * Clamav Native Windows Port : dirent win32 compatibility layer
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * Dirent for win32 is part of GNU Make
+ * Wrapped Unicode version by Alex Cherney <alch@sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _DIRENT_H
+#define _DIRENT_H
+
+#include <stdlib.h>
+#include <windows.h>
+#include <limits.h>
+#include <sys/types.h>
+
+#define __DIRENT_COOKIE 0xfefeabab
+
+struct dirent
+{
+    char d_name[MAX_PATH + 1];
+};
+
+typedef struct dir_struct
+{
+    ULONG dir_ulCookie;
+    HANDLE dir_hDirHandle;
+    DWORD dir_nNumFiles;
+    char dir_pDirectoryName[MAX_PATH + 1];
+    struct dirent dir_sdReturn;
+} DIR;
+
+DIR *opendir(const char* pDirName);
+int closedir(DIR *pDir);
+struct dirent *readdir_w(DIR* pDir);
+struct dirent *readdir_a(DIR* pDir);
+struct dirent *readdir(DIR* pDir);
+void rewinddir(DIR* pDir);
+int telldir(DIR* pDir);
+void seekdir(DIR* pDir, long nPosition);
+
+#endif /* _DIRENT_H */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/exeScanner.h clamav-release/contrib/msvc/include/exeScanner.h
--- clamav-0.91.2/contrib/msvc/include/exeScanner.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/exeScanner.h	2007-07-12 12:36:18.531250000 +1000
@@ -0,0 +1,46 @@
+/*
+ * executable modules analyzer
+ *
+ * Copyright (c) 2006-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _EXESCANNER_H_
+#define _EXESCANNER_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <osdeps.h>
+#include <output.h>
+
+#define ENTROPY_THRESHOLD   4.0
+#define EP_SIGNATURE_SIZE   16
+
+#ifndef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#endif
+
+typedef struct _sigs_t
+{
+    int16_t sig[16];
+    const char *name;
+    uint8_t packed;
+} sigs_t;
+
+extern int is_packed(const char *filename);
+
+#endif /* _EXESCANNER_H_ */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/filelist.h clamav-release/contrib/msvc/include/filelist.h
--- clamav-0.91.2/contrib/msvc/include/filelist.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/filelist.h	2007-07-12 12:36:18.531250000 +1000
@@ -0,0 +1,76 @@
+/*
+ * Clamav Native Windows Port: cheap list implementation
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __FILELIST_H__
+#define __FILELIST_H__
+
+#include <windows.h> /* For MAX_PATH */
+typedef struct _filelist_t
+{
+    char filename[MAX_PATH];
+    struct _filelist_t *next;
+} filelist_t;
+
+__inline int insert_file(filelist_t **list, const char *filename)
+{
+    filelist_t *current = *list, *prev = NULL;
+
+    if (!current) /* New */
+        *list = current = (filelist_t *) malloc(sizeof(filelist_t));
+    else
+    {
+        while (current && current->next)
+        {
+            if (!_stricmp(filename, current->filename)) return 0; /* Already in */
+            current = current->next;
+        }
+        prev = current;
+        prev->next = current = (filelist_t *) malloc(sizeof(filelist_t));
+    }
+
+    current->next = NULL;
+    current->filename[0] = 0;
+    strncat(current->filename, filename, MAX_PATH);
+    return 1;
+}
+
+__inline void freelist(filelist_t **list)
+{
+    filelist_t *current, *prev;
+    current = prev = *list;
+
+    if (!current) return;
+
+    do
+    {
+        prev = current;
+        current = prev->next;
+        free(prev);
+    } while (current);
+}
+__inline void dumplist(filelist_t *list)
+{
+    if (!list) return;
+    do
+        printf("Filename %s\n", list->filename);
+    while (list = list->next);
+}
+
+#endif /* __FILELIST_H__ */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/flock.h clamav-release/contrib/msvc/include/flock.h
--- clamav-0.91.2/contrib/msvc/include/flock.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/flock.h	2007-07-12 12:36:18.546875000 +1000
@@ -0,0 +1,46 @@
+#ifndef _FLOCK_H
+#define _FLOCK_H
+
+#include <clamav-config.h>
+
+/* For F_[GET|SET]FL */
+#define FD_CLOEXEC  1   /* actually anything with low bit set goes */
+
+/* Values for the second argument to 'fcntl'.  */
+#define F_DUPFD     0   /* Duplicate file descriptor */
+#define F_GETFD     1   /* Get file descriptor flags */
+#define F_SETFD     2   /* Set file descriptor flags */
+#define F_GETFL     3   /* Get file status flags */
+#define F_SETFL     4   /* Set file status flags */
+#if _INTEGRAL_MAX_BITS < 64
+# define F_GETLK    5   /* Get record locking info */
+# define F_SETLK    6   /* Set record locking info (non-blocking) */
+# define F_SETLKW   7   /* Set record locking info (blocking) */
+#else
+# define F_GETLK    F_GETLK64  /* Get record locking info */
+# define F_SETLK    F_SETLK64  /* Set record locking info (non-blocking) */
+# define F_SETLKW   F_SETLKW64 /* Set record locking info (blocking) */
+#endif
+#define F_GETLK64   12  /* Get record locking info */
+#define F_SETLK64   13  /* Set record locking info (non-blocking) */
+#define F_SETLKW64  14  /* Set record locking info (blocking) */
+
+/* For posix fcntl() and 'l_type' field of a 'struct flock' for lockf() */
+#define F_RDLCK     0   /* Read lock */
+#define F_WRLCK     1   /* Write lock */
+#define F_UNLCK     2   /* Remove lock */
+
+#define F_SETOWN   8   /* Get owner of socket (receiver of SIGIO) */
+#define F_GETOWN   9   /* Set owner of socket (receiver of SIGIO) */
+
+struct flock
+{
+    short int l_type;    /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK */
+    short int l_whence;  /* Where 'l_start' is relative to (like 'lseek') */
+    off_t l_start;       /* Offset where the lock begins */
+    off_t l_len;         /* Size of the locked area; zero means until EOF */
+    pid_t l_pid;         /* Process holding the lock */
+  };
+
+extern int fcntl(int fd, int cmd, ...);
+#endif /* _FLOCK_H */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/gethostbyname.h clamav-release/contrib/msvc/include/gethostbyname.h
--- clamav-0.91.2/contrib/msvc/include/gethostbyname.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/gethostbyname.h	2007-07-12 12:36:18.531250000 +1000
@@ -0,0 +1,66 @@
+/*
+ * Clamav Native Windows Port: gethostbyname win32 workaround
+ *
+ * Copyright (c) 1996-2006 Red Hat, Inc. (source code of cygwin)
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _GETHOSTBYNAME_WIN32_H
+#define _GETHOSTBYNAME_WIN32_H
+
+#include <winsock2.h>
+#include <inttypes.h>
+#include <string.h>
+
+inline struct hostent *win32_gethostbyname(const char *name)
+{
+    uint32_t a, b, c, d;
+    char dummy;
+
+    if ((sscanf(name, "%u.%u.%u.%u%c", &a, &b, &c, &d, &dummy) != 4) ||
+        (a >= 0xff) || (b >= 0xff) || (c >= 0xff) || (d >= 0xff))
+        return gethostbyname(name);
+
+    else
+    {
+        static struct hostent he;
+        static unsigned char ip_addr[4];
+        static char *ip_aliases[1] = {0};
+        static char *ip_addr_list[2] = {0,0};
+
+        memset(&he, 0, sizeof(struct hostent));
+
+        /* fill it */
+        ip_addr[0] = a;
+        ip_addr[1] = b;
+        ip_addr[2] = c;
+        ip_addr[3] = d;
+
+        he.h_name = (char *) name;
+        he.h_addr_list = ip_addr_list;
+        he.h_addr_list[0] = (char *) ip_addr;
+        he.h_aliases = ip_aliases;
+        he.h_addrtype = AF_INET;
+        he.h_length = 4;
+        return &he;
+    }
+}
+
+/* on win32 gethostbyname doesn't always work with ip numbers */
+#define gethostbyname win32_gethostbyname
+
+#endif /* _GETHOSTBYNAME_WIN32_H */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/inttypes.h clamav-release/contrib/msvc/include/inttypes.h
--- clamav-0.91.2/contrib/msvc/include/inttypes.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/inttypes.h	2007-07-12 12:36:18.546875000 +1000
@@ -0,0 +1,24 @@
+#ifndef _INTTYPES_H_
+#define _INTTYPES_H_
+
+typedef unsigned __int64 uint64_t;
+typedef signed   __int64 int64_t;
+
+typedef unsigned __int32 uint32_t;
+typedef signed   __int32 int32_t;
+
+typedef unsigned __int16 uint16_t;
+typedef signed   __int16 int16_t;
+
+typedef unsigned __int8  uint8_t;
+typedef signed   __int8  int8_t;
+
+typedef uint64_t u_int64_t;
+typedef uint32_t u_int32_t;
+typedef uint16_t u_int16_t;
+typedef uint8_t  u_int8_t;
+
+typedef uint32_t mode_t, pid_t;
+typedef size_t ssize_t;
+
+#endif /* _INTTYPES_H */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/osdeps.h clamav-release/contrib/msvc/include/osdeps.h
--- clamav-0.91.2/contrib/msvc/include/osdeps.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/osdeps.h	2007-07-12 12:36:18.546875000 +1000
@@ -0,0 +1,291 @@
+/*
+ * Clamav Native Windows Port
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _OSDEPS_H_
+#define _OSDEPS_H_
+
+#ifdef _MSC_VER
+
+#define BREAKPOINT() { __asm { int 3 }; }
+
+#pragma warning(disable: 4996)      /* Deprecated stuff */
+#pragma warning(disable: 4005)      /* Macro redefinition */
+#pragma warning(disable: 4244 4267) /* Conversion, possible loss of data */
+#pragma warning(disable: 4146)      /* Minus operator applied to unsigned */
+#pragma warning(disable: 4129)      /* Unrecognized character escape seq % in PDF */
+#pragma warning(disable: 4101)      /* Unreferenced local variable */
+#pragma warning(disable: 4018)      /* Signed/Unsigned mismatch */
+#pragma warning(disable: 4026)      /* Function declared with formal parameter list */
+#pragma warning(disable: 4311)      /* 'type cast' pointer truncation */
+
+/* #pragma warning(disable: 4013) */     /* Function undefined - disable with care */
+#endif
+
+#if _MSC_VER >= 1400 /* Visual Studio 6 = 1200 - Visual Studio 2005 = 1400 */
+#define _CRT_SECURE_NO_DEPRECATE 1
+#define HAVE_VSNPRINTF 1
+#endif
+
+/* Tell linked to add needed libs */
+#ifdef _DEBUG
+#define CL_DEBUG 1
+#define LIBSUFFIX "d"
+#else
+#define LIBSUFFIX
+#endif
+
+#ifdef HAVE_ZLIB_H
+#pragma comment (lib, "zlib"LIBSUFFIX".lib")
+#endif
+
+#ifdef HAVE_BZLIB_H
+#pragma comment (lib, "libbz2"LIBSUFFIX".lib")
+#endif
+
+#ifdef HAVE_GMP
+#pragma comment (lib, "gmp"LIBSUFFIX".lib")
+#endif
+
+#define WIN32_LEAN_AND_MEAN /* Avoids name Clash between DATADIR define and enum in objidl.h */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <io.h>
+#include <windows.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <winsock2.h>
+#include <sys/stat.h>
+#include <sys/utime.h>
+#include <sys/types.h>
+#include <direct.h>
+#include <process.h>
+#include <inttypes.h>
+
+#include <win32proc.h>
+
+#define LODWORD(l)  ((DWORD)((uint64_t)(l) & 0xffffffff))
+#define HIDWORD(l)  ((DWORD)((uint64_t)(l) >> 32))
+
+/* Windows Version Detection */
+#ifdef LIBCLAMAV_EXPORTS
+#define LIBCLAMAV_API __declspec(dllexport)
+#else
+#define LIBCLAMAV_API __declspec(dllimport)
+#endif
+
+extern uint32_t LIBCLAMAV_API Platform; /* dllmain */
+extern memhelpers_t LIBCLAMAV_API memhelpers; /* dllmain */
+
+#define PlatformId(p)       ((p >> 16) & 0x000000ff)
+#define PlatformMajor(p)    ((p >> 8 ) & 0x000000ff)
+#define PlatformMinor(p)    (p & 0x000000ff)
+#define isWin9x()           (PlatformId(Platform) == VER_PLATFORM_WIN32_WINDOWS)
+#define isOldOs()           (PlatformMajor(Platform) == 4) && (PlatformMinor(Platform) == 0)
+
+/* DataDir and ConfigDir from Registry */
+const char *GetDataDir(void);
+const char *GetClamdConfig(void);
+const char *GetFreshClamConfig(void);
+
+/* internals */
+#include <flock.h>
+
+/* <netinet/in.h> */
+typedef uint32_t in_addr_t;
+typedef uint16_t in_port_t;
+
+/* <sys/socket.h> */
+#define SHUT_RD     SD_RECEIVE
+#define SHUT_WR     SD_SEND
+#define SHUT_RDWR   SD_BOTH
+
+/* <sys/stat.h> */
+#define S_IRWXU S_IREAD | S_IWRITE
+#define S_IWUSR S_IWRITE
+#define S_IRUSR S_IREAD
+#define S_IWUSR S_IWRITE
+
+#define S_IRWXG S_IRWXU
+#define S_IROTH S_IREAD
+
+#define S_ISLNK(x) (0)
+#define S_ISREG(x) (((x) & S_IFMT) == S_IFREG)
+#define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)
+
+/* <strings.h> */
+#ifndef strcasecmp
+#define strcasecmp stricmp
+#endif
+
+#ifndef strncasecmp
+#define strncasecmp strnicmp
+#endif
+
+/* Thread safety */
+#ifdef CL_THREAD_SAFE
+/* MSVC 6 doesn't have a strtok_r equivalent but pthread win32 defines it for us */
+#if _MSC_VER >= 1400
+#define strtok_r strtok_s
+/*
+#else
+#define strtok_r(_s, _sep, _lasts) (*(_lasts) = strtok((_s), (_sep)))
+*/
+#endif
+#endif
+
+/* MVC6 doesn't have _strdup_dbg */
+#if _MSC_VER <= 1200
+#define _strdup_dbg(s, block, file, line) strdup(s)
+#endif
+
+/* Re_routing */
+
+#if _MSC_VER > 1200
+extern int win32_stat(const char *path, struct _stat64 *buf);
+#define stat _stat64
+#define fstat _fstat64
+#define _stat64(p, b) win32_stat(p, b)
+#define lstat(p, b) win32_stat(p, b)
+#else
+/* vs6 misses stat64 stuff */
+extern int win32_stat(const char *path, struct _stati64 *buf);
+#define _stat64 _stati64
+#define stat _stati64
+#define fstat _fstati64
+#define _stati64(p, b) win32_stat(p, b)
+#define lstat(p, b) win32_stat(p, b)
+#endif
+
+#define fsync _commit
+#define mkdir(a, b) mkdir(a)
+
+/* Process execution */
+#define WIFSIGNALED(x) (x)
+#define WIFEXITED(x) (1)
+#define WTERMSIG(x) (x)
+
+/* UNC Path Handling on win32 */
+#define UNC_PREFIX "\\\\?\\"
+#define UN2_PREFIX "\\??\\"
+#define DEV_PREFIX "\\\\.\\"
+#define NET_PREFIX "\\\\"
+#define UNC_OFFSET(x) (&x[4])
+#define PATH_ISUNC(path)  (!strncmp(path, UNC_PREFIX, 4))
+#define PATH_ISUN2(path)  (!strncmp(path, UN2_PREFIX, 4))
+#define PATH_ISDEV(path)  (!strncmp(path, DEV_PREFIX, 4))
+#define PATH_ISNET(path)  (!strncmp(path, NET_PREFIX, 2))
+#define PATH_PLAIN(path)  (PATH_ISUNC(path) ? UNC_OFFSET(path) : path)
+
+extern const char *unc_prefix(const char *filename);
+
+static inline void unixpath_to_win32(char *name)
+{
+    /* UNC Paths need to have only backslashes */
+    char *p = name;
+    while (*p)
+    {
+        if (*p == '/') *p = '\\';
+        p++;
+    }
+}
+
+static inline void strip_trailing_slashes(char *path)
+{
+    size_t i = strlen(path) - 1;
+    while ((i > 0) && ((path[i] == '/') || (path[i] == '\\')))
+        path[i--] = 0;
+}
+
+/* tmpfile() on win32 uses root dir, not suitable if non-admin */
+#define tmpfile() fopen(cli_gentemp(NULL), "w+bD")
+
+/* scan memory */
+extern int scanmem(struct cl_engine *trie, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
+
+/* on win32 gethostbyname doesn't always work with ip numbers */
+#include <gethostbyname.h>
+
+/* nonblock.c */
+typedef int socklen_t;
+#define EALREADY WSAEALREADY
+#define EINPROGRESS WSAEINPROGRESS
+#define EISCONN WSAEISCONN
+
+/* Control+C Handlers */
+/* Avoid crash if Control+C is pressed */
+#define DECLARE_CTRL_C_HANDLER() \
+    static void console_ctrl_handler(DWORD ctrl_type) \
+    { \
+        logg("Control+C pressed, aborting...\n"); \
+        exit(1); \
+    } \
+    static void stop_console_handler(void) \
+    { \
+        SetConsoleCtrlHandler((PHANDLER_ROUTINE) console_ctrl_handler, FALSE); \
+    }
+
+#define INSTALL_CTRL_C_HANDLER() \
+    SetConsoleCtrlHandler((PHANDLER_ROUTINE) console_ctrl_handler, TRUE); \
+    atexit(stop_console_handler);
+
+/* made as macro to avoid explicit link of winsock lib when only ntohl is needed */
+#define ntohl(x) (((uint32_t)x >> 24) | \
+                 (((uint32_t)x >> 8) & 0xff00) | \
+                 (((uint32_t)x << 8) & 0xff0000) | \
+                 ((uint32_t)x << 24))
+
+extern int snprintf(char *str, size_t count, const char *fmt, ...);
+
+#ifdef NO_CONSOLE_IO /* Rip off console i/o */
+
+/* Ugly hack since Visual Studio before 2005
+ * doesn't support var args in macros
+ * Remember to remove these functions from the .def file */
+#if _MSC_VER >= 1400
+#define cli_warnmsg(...)
+#define cli_errmsg(...)
+#define cli_dbgmsg(...)
+#else
+#define cli_warnmsg
+#define cli_errmsg
+#define cli_dbgmsg
+#endif
+
+#else
+extern void cli_warnmsg(const char *str, ...);
+extern void cli_errmsg(const char *str, ...);
+extern void cli_dbgmsg(const char *str, ...);
+#endif
+
+#define HAVE_MKSTEMP 1
+extern int mkstemp(char *tmpl);
+
+#ifndef HAVE_VSNPRINTF
+extern int vsnprintf(char *str, size_t count, const char *fmt, va_list args);
+#endif
+
+/* yes msvc 6 sucks... */
+#ifndef _INTPTR_T_DEFINED
+typedef long int intptr_t;
+#define _INTPTR_T_DEFINED
+#endif
+
+#endif /* _OSDEPS_H_ */
\ No newline at end of file
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/regex.h clamav-release/contrib/msvc/include/regex.h
--- clamav-0.91.2/contrib/msvc/include/regex.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/regex.h	2007-07-12 12:36:18.531250000 +1000
@@ -0,0 +1,490 @@
+/* Definitions for data structures and routines for the regular
+   expression library, version 0.12.
+
+   Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this software; if not, write to the
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#ifndef __REGEXP_LIBRARY_H__
+#define __REGEXP_LIBRARY_H__
+
+/* POSIX says that <sys/types.h> must be included (by the caller) before
+   <regex.h>.  */
+
+#ifdef VMS
+/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it
+   should be there.  */
+#include <stddef.h>
+#endif
+
+
+/* The following bits are used to determine the regexp syntax we
+   recognize.  The set/not-set meanings are chosen so that Emacs syntax
+   remains the value 0.  The bits are given in alphabetical order, and
+   the definitions shifted by one from the previous bit; thus, when we
+   add or remove a bit, only one other definition need change.  */
+typedef unsigned reg_syntax_t;
+
+/* If this bit is not set, then \ inside a bracket expression is literal.
+   If set, then such a \ quotes the following character.  */
+#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
+
+/* If this bit is not set, then + and ? are operators, and \+ and \? are
+     literals.
+   If set, then \+ and \? are operators and + and ? are literals.  */
+#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
+
+/* If this bit is set, then character classes are supported.  They are:
+     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+   If not set, then character classes are not supported.  */
+#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
+
+/* If this bit is set, then ^ and $ are always anchors (outside bracket
+     expressions, of course).
+   If this bit is not set, then it depends:
+        ^  is an anchor if it is at the beginning of a regular
+           expression or after an open-group or an alternation operator;
+        $  is an anchor if it is at the end of a regular expression, or
+           before a close-group or an alternation operator.
+
+   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+   POSIX draft 11.2 says that * etc. in leading positions is undefined.
+   We already implemented a previous draft which made those constructs
+   invalid, though, so we haven't changed the code back.  */
+#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
+
+/* If this bit is set, then special characters are always special
+     regardless of where they are in the pattern.
+   If this bit is not set, then special characters are special only in
+     some contexts; otherwise they are ordinary.  Specifically,
+     * + ? and intervals are only special when not after the beginning,
+     open-group, or alternation operator.  */
+#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
+
+/* If this bit is set, then *, +, ?, and { cannot be first in an re or
+     immediately after an alternation or begin-group operator.  */
+#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
+
+/* If this bit is set, then . matches newline.
+   If not set, then it doesn't.  */
+#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
+
+/* If this bit is set, then . doesn't match NUL.
+   If not set, then it does.  */
+#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
+
+/* If this bit is set, nonmatching lists [^...] do not match newline.
+   If not set, they do.  */
+#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
+
+/* If this bit is set, either \{...\} or {...} defines an
+     interval, depending on RE_NO_BK_BRACES.
+   If not set, \{, \}, {, and } are literals.  */
+#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
+
+/* If this bit is set, +, ? and | aren't recognized as operators.
+   If not set, they are.  */
+#define RE_LIMITED_OPS (RE_INTERVALS << 1)
+
+/* If this bit is set, newline is an alternation operator.
+   If not set, newline is literal.  */
+#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
+
+/* If this bit is set, then `{...}' defines an interval, and \{ and \}
+     are literals.
+  If not set, then `\{...\}' defines an interval.  */
+#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
+
+/* If this bit is set, (...) defines a group, and \( and \) are literals.
+   If not set, \(...\) defines a group, and ( and ) are literals.  */
+#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
+
+/* If this bit is set, then \<digit> matches <digit>.
+   If not set, then \<digit> is a back-reference.  */
+#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
+
+/* If this bit is set, then | is an alternation operator, and \| is literal.
+   If not set, then \| is an alternation operator, and | is literal.  */
+#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
+
+/* If this bit is set, then an ending range point collating higher
+     than the starting range point, as in [z-a], is invalid.
+   If not set, then when ending range point collates higher than the
+     starting range point, the range is ignored.  */
+#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
+
+/* If this bit is set, then an unmatched ) is ordinary.
+   If not set, then an unmatched ) is invalid.  */
+#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
+
+/* This global variable defines the particular regexp syntax to use (for
+   some interfaces).  When a regexp is compiled, the syntax used is
+   stored in the pattern buffer, so changing this does not affect
+   already-compiled regexps.  */
+extern reg_syntax_t re_syntax_options;
+
+/* Define combinations of the above bits for the standard possibilities.
+   (The [[[ comments delimit what gets put into the Texinfo file, so
+   don't delete them!)  */
+/* [[[begin syntaxes]]] */
+#define RE_SYNTAX_EMACS 0
+
+#define RE_SYNTAX_AWK							\
+  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL			\
+   | RE_NO_BK_PARENS            | RE_NO_BK_REFS				\
+   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES			\
+   | RE_UNMATCHED_RIGHT_PAREN_ORD)
+
+#define RE_SYNTAX_POSIX_AWK 						\
+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
+
+#define RE_SYNTAX_GREP							\
+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
+   | RE_NEWLINE_ALT)
+
+#define RE_SYNTAX_EGREP							\
+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
+   | RE_NO_BK_VBAR)
+
+#define RE_SYNTAX_POSIX_EGREP						\
+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
+
+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
+
+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
+
+/* Syntax bits common to both basic and extended POSIX regex syntax.  */
+#define _RE_SYNTAX_POSIX_COMMON						\
+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
+   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
+
+#define RE_SYNTAX_POSIX_BASIC						\
+  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
+
+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
+   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+   isn't minimal, since other operators, such as \`, aren't disabled.  */
+#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
+  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
+
+#define RE_SYNTAX_POSIX_EXTENDED					\
+  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR				\
+   | RE_UNMATCHED_RIGHT_PAREN_ORD)
+
+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
+   replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
+   | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
+/* [[[end syntaxes]]] */
+
+/* Maximum number of duplicates an interval can allow.  Some systems
+   (erroneously) define this in other header files, but we want our
+   value, so remove any previous define.  */
+#ifdef RE_DUP_MAX
+#undef RE_DUP_MAX
+#endif
+#define RE_DUP_MAX ((1 << 15) - 1)
+
+
+/* POSIX `cflags' bits (i.e., information for `regcomp').  */
+
+/* If this bit is set, then use extended regular expression syntax.
+   If not set, then use basic regular expression syntax.  */
+#define REG_EXTENDED 1
+
+/* If this bit is set, then ignore case when matching.
+   If not set, then case is significant.  */
+#define REG_ICASE (REG_EXTENDED << 1)
+
+/* If this bit is set, then anchors do not match at newline
+     characters in the string.
+   If not set, then anchors do match at newlines.  */
+#define REG_NEWLINE (REG_ICASE << 1)
+
+/* If this bit is set, then report only success or fail in regexec.
+   If not set, then returns differ between not matching and errors.  */
+#define REG_NOSUB (REG_NEWLINE << 1)
+
+
+/* POSIX `eflags' bits (i.e., information for regexec).  */
+
+/* If this bit is set, then the beginning-of-line operator doesn't match
+     the beginning of the string (presumably because it's not the
+     beginning of a line).
+   If not set, then the beginning-of-line operator does match the
+     beginning of the string.  */
+#define REG_NOTBOL 1
+
+/* Like REG_NOTBOL, except for the end-of-line.  */
+#define REG_NOTEOL (1 << 1)
+
+
+/* If any error codes are removed, changed, or added, update the
+   `re_error_msg' table in regex.c.  */
+typedef enum
+{
+  REG_NOERROR = 0,	/* Success.  */
+  REG_NOMATCH,		/* Didn't find a match (for regexec).  */
+
+  /* POSIX regcomp return error codes.  (In the order listed in the
+     standard.)  */
+  REG_BADPAT,		/* Invalid pattern.  */
+  REG_ECOLLATE,		/* Not implemented.  */
+  REG_ECTYPE,		/* Invalid character class name.  */
+  REG_EESCAPE,		/* Trailing backslash.  */
+  REG_ESUBREG,		/* Invalid back reference.  */
+  REG_EBRACK,		/* Unmatched left bracket.  */
+  REG_EPAREN,		/* Parenthesis imbalance.  */
+  REG_EBRACE,		/* Unmatched \{.  */
+  REG_BADBR,		/* Invalid contents of \{\}.  */
+  REG_ERANGE,		/* Invalid range end.  */
+  REG_ESPACE,		/* Ran out of memory.  */
+  REG_BADRPT,		/* No preceding re for repetition op.  */
+
+  /* Error codes we've added.  */
+  REG_EEND,		/* Premature end.  */
+  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
+  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
+} reg_errcode_t;
+
+/* This data structure represents a compiled pattern.  Before calling
+   the pattern compiler, the fields `buffer', `allocated', `fastmap',
+   `translate', and `no_sub' can be set.  After the pattern has been
+   compiled, the `re_nsub' field is available.  All other fields are
+   private to the regex routines.  */
+
+struct re_pattern_buffer
+{
+/* [[[begin pattern_buffer]]] */
+	/* Space that holds the compiled pattern.  It is declared as
+          `unsigned char *' because its elements are
+           sometimes used as array indexes.  */
+  unsigned char *buffer;
+
+	/* Number of bytes to which `buffer' points.  */
+  unsigned long allocated;
+
+	/* Number of bytes actually used in `buffer'.  */
+  unsigned long used;
+
+        /* Syntax setting with which the pattern was compiled.  */
+  reg_syntax_t syntax;
+
+        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
+           the fastmap, if there is one, to skip over impossible
+           starting points for matches.  */
+  char *fastmap;
+
+        /* Either a translate table to apply to all characters before
+           comparing them, or zero for no translation.  The translation
+           is applied to a pattern when it is compiled and to a string
+           when it is matched.  */
+  char *translate;
+
+	/* Number of subexpressions found by the compiler.  */
+  size_t re_nsub;
+
+        /* Zero if this pattern cannot match the empty string, one else.
+           Well, in truth it's used only in `re_search_2', to see
+           whether or not we should use the fastmap, so we don't set
+           this absolutely perfectly; see `re_compile_fastmap' (the
+           `duplicate' case).  */
+  unsigned can_be_null : 1;
+
+        /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+             for `max (RE_NREGS, re_nsub + 1)' groups.
+           If REGS_REALLOCATE, reallocate space if necessary.
+           If REGS_FIXED, use what's there.  */
+#define REGS_UNALLOCATED 0
+#define REGS_REALLOCATE 1
+#define REGS_FIXED 2
+  unsigned regs_allocated : 2;
+
+        /* Set to zero when `regex_compile' compiles a pattern; set to one
+           by `re_compile_fastmap' if it updates the fastmap.  */
+  unsigned fastmap_accurate : 1;
+
+        /* If set, `re_match_2' does not return information about
+           subexpressions.  */
+  unsigned no_sub : 1;
+
+        /* If set, a beginning-of-line anchor doesn't match at the
+           beginning of the string.  */
+  unsigned not_bol : 1;
+
+        /* Similarly for an end-of-line anchor.  */
+  unsigned not_eol : 1;
+
+        /* If true, an anchor at a newline matches.  */
+  unsigned newline_anchor : 1;
+
+/* [[[end pattern_buffer]]] */
+};
+
+typedef struct re_pattern_buffer regex_t;
+
+
+/* search.c (search_buffer) in Emacs needs this one opcode value.  It is
+   defined both in `regex.c' and here.  */
+#define RE_EXACTN_VALUE 1
+
+/* Type for byte offsets within the string.  POSIX mandates this.  */
+typedef int regoff_t;
+
+
+/* This is the structure we store register match data in.  See
+   regex.texinfo for a full description of what registers match.  */
+struct re_registers
+{
+  unsigned num_regs;
+  regoff_t *start;
+  regoff_t *end;
+};
+
+
+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+   `re_match_2' returns information about at least this many registers
+   the first time a `regs' structure is passed.  */
+#ifndef RE_NREGS
+#define RE_NREGS 30
+#endif
+
+
+/* POSIX specification for registers.  Aside from the different names than
+   `re_registers', POSIX uses an array of structures, instead of a
+   structure of arrays.  */
+typedef struct
+{
+  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */
+  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */
+} regmatch_t;
+
+/* Declarations for routines.  */
+
+/* To avoid duplicating every routine declaration -- once with a
+   prototype (if we are ANSI), and once without (if we aren't) -- we
+   use the following macro to declare argument types.  This
+   unfortunately clutters up the declarations a bit, but I think it's
+   worth it.  */
+
+#if __STDC__
+
+#define _RE_ARGS(args) args
+
+#else /* not __STDC__ */
+
+#define _RE_ARGS(args) ()
+
+#endif /* not __STDC__ */
+
+/* Sets the current default syntax to SYNTAX, and return the old syntax.
+   You can also simply assign to the `re_syntax_options' variable.  */
+extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));
+
+/* Compile the regular expression PATTERN, with length LENGTH
+   and syntax given by the global `re_syntax_options', into the buffer
+   BUFFER.  Return NULL if successful, and an error string if not.  */
+extern const char *re_compile_pattern
+  _RE_ARGS ((const char *pattern, int length,
+             struct re_pattern_buffer *buffer));
+
+
+/* Compile a fastmap for the compiled pattern in BUFFER; used to
+   accelerate searches.  Return 0 if successful and -2 if was an
+   internal error.  */
+extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));
+
+
+/* Search in the string STRING (with length LENGTH) for the pattern
+   compiled into BUFFER.  Start searching at position START, for RANGE
+   characters.  Return the starting position of the match, -1 for no
+   match, or -2 for an internal error.  Also return register
+   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
+extern int re_search
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
+            int length, int start, int range, struct re_registers *regs));
+
+
+/* Like `re_search', but search in the concatenation of STRING1 and
+   STRING2.  Also, stop searching at index START + STOP.  */
+extern int re_search_2
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
+             int length1, const char *string2, int length2,
+             int start, int range, struct re_registers *regs, int stop));
+
+
+/* Like `re_search', but return how many characters in STRING the regexp
+   in BUFFER matched, starting at position START.  */
+extern int re_match
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
+             int length, int start, struct re_registers *regs));
+
+
+/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
+extern int re_match_2
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
+             int length1, const char *string2, int length2,
+             int start, struct re_registers *regs, int stop));
+
+
+/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
+   ENDS.  Subsequent matches using BUFFER and REGS will use this memory
+   for recording register information.  STARTS and ENDS must be
+   allocated with malloc, and must each be at least `NUM_REGS * sizeof
+   (regoff_t)' bytes long.
+
+   If NUM_REGS == 0, then subsequent matches should allocate their own
+   register data.
+
+   Unless this function is called, the first search or match using
+   PATTERN_BUFFER will allocate its own register data, without
+   freeing the old data.  */
+extern void re_set_registers
+  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,
+             unsigned num_regs, regoff_t *starts, regoff_t *ends));
+
+/* 4.2 bsd compatibility.  */
+extern char *re_comp _RE_ARGS ((const char *));
+extern int re_exec _RE_ARGS ((const char *));
+
+/* POSIX compatibility.  */
+extern int regcomp _RE_ARGS ((regex_t *preg, const char *pattern, int cflags));
+extern int regexec
+  _RE_ARGS ((const regex_t *preg, const char *string, size_t nmatch,
+             regmatch_t pmatch[], int eflags));
+extern size_t regerror
+  _RE_ARGS ((int errcode, const regex_t *preg, char *errbuf,
+             size_t errbuf_size));
+extern void regfree _RE_ARGS ((regex_t *preg));
+
+#endif /* not __REGEXP_LIBRARY_H__ */
+
+/*
+Local variables:
+make-backup-files: t
+version-control: t
+trim-versions-without-asking: nil
+End:
+*/
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/stdint.h clamav-release/contrib/msvc/include/stdint.h
--- clamav-0.91.2/contrib/msvc/include/stdint.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/stdint.h	2007-07-12 12:36:18.562500000 +1000
@@ -0,0 +1,2 @@
+/* Why not directly inttypes? */
+#include <inttypes.h>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/sys/mman.h clamav-release/contrib/msvc/include/sys/mman.h
--- clamav-0.91.2/contrib/msvc/include/sys/mman.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/sys/mman.h	2007-07-12 12:36:18.500000000 +1000
@@ -0,0 +1,22 @@
+#ifndef _SYS_MMAN_H
+#define _SYS_MMAN_H
+
+#include <io.h>
+#include <sys/types.h>
+
+#define PROT_READ   0x1     /* Page can be read */
+#define PROT_WRITE  0x2     /* Page can be written */
+#define PROT_EXEC   0x4     /* Page can be executed */
+#define PROT_NONE   0x0     /* Page can not be accessed */
+
+#define MAP_SHARED  0x01    /* Share changes */
+#define MAP_PRIVATE 0x02    /* Changes are private */
+#define MAP_FIXED   0x10    /* Interpret addr exactly */
+
+/* Return value of 'mmap' in case of an error */
+#define MAP_FAILED  ((void *) -1)
+
+extern void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
+extern int munmap(void *addr, size_t len);
+
+#endif /* _SYS_MMAN_H */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/sys/time.h clamav-release/contrib/msvc/include/sys/time.h
--- clamav-0.91.2/contrib/msvc/include/sys/time.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/sys/time.h	2007-07-12 12:36:18.500000000 +1000
@@ -0,0 +1,11 @@
+#ifndef _SYS_TIME_H
+#define _SYS_TIME_H
+
+struct timezone
+{
+    int tz_minuteswest; /* minutes W of Greenwich */
+    int tz_dsttime;     /* type of dst correction */
+};
+
+extern int gettimeofday(struct timeval *tv, struct timezone *tz);
+#endif /* _SYS_TIME_H */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/target.h clamav-release/contrib/msvc/include/target.h
--- clamav-0.91.2/contrib/msvc/include/target.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/target.h	2007-07-12 12:36:18.562500000 +1000
@@ -0,0 +1,13 @@
+/* Clamav specific */
+
+#ifndef TARGET_OS_TYPE
+#define TARGET_OS_TYPE "win32"
+#endif
+
+#ifndef TARGET_ARCH_TYPE
+#define TARGET_ARCH_TYPE "x86"
+#endif
+
+#ifndef TARGET_CPU_TYPE
+#define TARGET_CPU_TYPE "i686"
+#endif
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/unistd.h clamav-release/contrib/msvc/include/unistd.h
--- clamav-0.91.2/contrib/msvc/include/unistd.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/unistd.h	2007-07-12 12:36:18.562500000 +1000
@@ -0,0 +1,16 @@
+#ifndef _UNISTD_H
+#define _UNISTD_H
+
+#include <io.h>
+
+#define R_OK    4               /* Test for read permission */
+#define W_OK    2               /* Test for write permission */
+#define X_OK    0               /* Test for execute permission - 1 bombs msvcrt */
+#define F_OK    0               /* Test for existence */
+
+#define sleep(x) Sleep(x / 1000)
+#define alarm(x)
+
+extern char *getpass(const char * prompt);
+
+#endif /* _UNISTD_H */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/win32proc.h clamav-release/contrib/msvc/include/win32proc.h
--- clamav-0.91.2/contrib/msvc/include/win32proc.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/win32proc.h	2007-07-12 12:36:18.562500000 +1000
@@ -0,0 +1,60 @@
+/*
+ * Clamav Native Windows Port: memory related stuff
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _WIN32PROC_H_
+#define _WIN32PROC_H_
+
+#include <osdeps.h>
+#include <tlhelp32.h>
+
+/* kernel32 */
+typedef HANDLE (WINAPI *imp_CreateToolhelp32Snapshot)(DWORD, DWORD);
+typedef BOOL (WINAPI *imp_Process32First)(HANDLE, PROCESSENTRY32 *);
+typedef BOOL (WINAPI *imp_Process32Next)(HANDLE, PROCESSENTRY32 *);
+typedef BOOL (WINAPI *imp_Module32First)(HANDLE, MODULEENTRY32 *);
+typedef BOOL (WINAPI *imp_Module32Next)(HANDLE, MODULEENTRY32 *);
+
+/* advapi32 */
+typedef BOOL (WINAPI *imp_OpenProcessToken)(HANDLE, DWORD, PHANDLE);
+typedef BOOL (WINAPI *imp_LookupPrivilegeValueA)(LPCSTR, LPCSTR, PLUID);
+typedef BOOL (WINAPI *imp_AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES, DWORD, PTOKEN_PRIVILEGES, PDWORD);
+
+typedef HANDLE (WINAPI *imp_CreateRemoteThread)(HANDLE,
+                LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
+
+typedef struct _memhelpers_t
+{
+    BOOL ok;
+    imp_CreateToolhelp32Snapshot CreateToolhelp32Snapshot;
+    imp_Process32First Process32First;
+    imp_Process32Next Process32Next;
+    imp_Module32First Module32First;
+    imp_Module32Next Module32Next;
+    imp_CreateRemoteThread CreateRemoteThread;
+
+    imp_OpenProcessToken OpenProcessToken;
+    imp_LookupPrivilegeValueA LookupPrivilegeValueA;
+    imp_AdjustTokenPrivileges AdjustTokenPrivileges;
+
+} memhelpers_t;
+
+typedef int (*proc_callback)(PROCESSENTRY32 ProcStruct, MODULEENTRY32 me32, void *data);
+
+#endif /* _WIN32PROC_H_ */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/include/zzip-msvc.h clamav-release/contrib/msvc/include/zzip-msvc.h
--- clamav-0.91.2/contrib/msvc/include/zzip-msvc.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/include/zzip-msvc.h	2007-07-12 12:36:18.546875000 +1000
@@ -0,0 +1,124 @@
+#ifndef _ZZIP__MSVC_H
+#define _ZZIP__MSVC_H 1
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef ZZIP__FILE_OFFSET_BITS */
+
+/* Define if you have the <dirent.h> header file, and it defines `DIR'. */
+#define ZZIP_HAVE_DIRENT_H 1
+
+/* Define if you have the <inttypes.h> header file. */
+#define ZZIP_HAVE_INTTYPES_H 1
+
+/* Define if you have the <io.h> header file. */
+#define ZZIP_HAVE_IO_H 1
+
+/* Define if you have the <memory.h> header file. */
+#ifndef ZZIP_HAVE_MEMORY_H
+#define ZZIP_HAVE_MEMORY_H  1
+#endif
+
+/* Define if you have the <stdlib.h> header file. */
+#ifndef ZZIP_HAVE_STDLIB_H
+#define ZZIP_HAVE_STDLIB_H  1
+#endif
+
+/* Define if you have the <string.h> header file. */
+#ifndef ZZIP_HAVE_STRING_H
+#define ZZIP_HAVE_STRING_H  1
+#endif
+
+/* Define if you have the <sys/mman.h> header file. */
+#ifndef ZZIP_HAVE_SYS_MMAN_H
+#define ZZIP_HAVE_SYS_MMAN_H 1
+#endif
+
+/* Define if you have the <sys/stat.h> header file. */
+#ifndef ZZIP_HAVE_SYS_STAT_H
+#define ZZIP_HAVE_SYS_STAT_H  1
+#endif
+
+/* Define if you have the <sys/types.h> header file. */
+#ifndef ZZIP_HAVE_SYS_TYPES_H
+#define ZZIP_HAVE_SYS_TYPES_H  1
+#endif
+
+/* Define if you have the <winbase.h> header file. */
+#ifndef ZZIP_HAVE_WINBASE_H
+#define ZZIP_HAVE_WINBASE_H  1  /* hmm, is that win32 ? */
+#endif
+
+/* Define if you have the <windows.h> header file. */
+#ifndef ZZIP_HAVE_WINDOWS_H
+#define ZZIP_HAVE_WINDOWS_H  1  /* yes, this is windows */
+#endif
+
+/* Define if you have the <winnt.h> header file. */
+#ifndef ZZIP_HAVE_WINNT_H
+#define ZZIP_HAVE_WINNT_H  1      /* is that always true? */
+#endif
+
+/* Define if you have the <zlib.h> header file. */
+#ifndef ZZIP_HAVE_ZLIB_H
+#define ZZIP_HAVE_ZLIB_H  1      /* you do have it, right? */
+#endif
+
+/* Define as `__inline' if that's what the C compiler calls it, or to nothing
+   if it is not supported. */
+#ifndef _zzip_inline
+#define _zzip_inline  __inline
+#endif
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef ZZIP__LARGE_FILES */
+
+/* whether the system defaults to 32bit off_t but can do 64bit when requested
+   */
+/* #undef ZZIP_LARGEFILE_SENSITIVE */
+
+/* Define to `long' if <sys/types.h> does not define. */
+#ifndef _zzip_off_t
+#define _zzip_off_t  long
+#endif
+
+/* Name of package */
+#ifndef ZZIP_PACKAGE
+#define ZZIP_PACKAGE  "zziplib-msvc"     /* yes, make it known */
+#endif
+
+/* The number of bytes in type int */
+#ifndef ZZIP_SIZEOF_INT
+#define ZZIP_SIZEOF_INT  4
+#endif
+
+/* The number of bytes in type long */
+#ifndef ZZIP_SIZEOF_LONG
+#define ZZIP_SIZEOF_LONG  4
+#endif
+
+/* The number of bytes in type short */
+#ifndef ZZIP_SIZEOF_SHORT
+#define ZZIP_SIZEOF_SHORT  2
+#endif
+
+/* Define to `unsigned' if <sys/types.h> does not define. */
+/* #undef _zzip_size_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+#ifndef _zzip_ssize_t
+#define _zzip_ssize_t  int
+#endif
+
+/* Define if you have the ANSI C header files. */
+#ifndef ZZIP_STDC_HEADERS
+#define ZZIP_STDC_HEADERS  1
+#endif
+
+/* Version number of package */
+/* #undef ZZIP_VERSION */
+
+/* io-wrap needs to wrap systemcalls */
+/* #undef ZZIP_WRAPWRAP */
+
+/* once: _ZZIP__MSVC_H */
+#endif
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/libclamav.def clamav-release/contrib/msvc/libclamav.def
--- clamav-0.91.2/contrib/msvc/libclamav.def	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/libclamav.def	2007-07-12 12:36:19.937500000 +1000
@@ -0,0 +1,55 @@
+EXPORTS
+; file scanning
+cl_scandesc
+cl_scanfile
+
+; software versions
+cl_retflevel
+cl_retver
+
+; database
+cl_loaddb
+cl_loaddbdir
+cl_load
+cl_retdbdir
+cl_dup
+
+; CVD
+cl_cvdhead
+cl_cvdparse
+cl_cvdverify
+cl_cvdfree
+
+; data dir stat functions
+cl_statinidir
+cl_statchkdir
+cl_statfree
+
+; logging functions
+cl_debug
+
+cl_settempdir
+cl_build
+cl_free
+cl_strerror
+
+; internals :(
+cli_warnmsg
+cli_errmsg
+cli_dbgmsg
+cli_rmdirs
+cli_gettempdir
+cli_gentemp
+cli_filecopy
+cli_calloc
+cli_malloc
+cli_realloc
+cli_readn
+cli_writen
+cli_md5stream
+cli_md5file
+cli_bitset_init
+cli_bitset_free
+cli_bitset_set
+cli_filetype2
+cli_scanbuff
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/libclamav.dsp clamav-release/contrib/msvc/libclamav.dsp
--- clamav-0.91.2/contrib/msvc/libclamav.dsp	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/libclamav.dsp	2007-07-12 12:36:19.890625000 +1000
@@ -0,0 +1,927 @@
+# Microsoft Developer Studio Project File - Name="libclamav" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=libclamav - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "libclamav.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "libclamav.mak" CFG="libclamav - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "libclamav - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "libclamav - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "libclamav - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "libclamav_Objs_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release\libclamav"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBCLAMAV_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /O2 /I "." /I "include" /I "../.." /I "../../libclamav" /I "../../libclamav/mspack" /I "../../libclamav/unrar" /I "../../libclamav/nsis" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBCLAMAV_EXPORTS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /D "_LZMA_IN_CB" /J /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x417 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib advapi32.lib ws2_32.lib pthreadVC2.lib /nologo /dll /machine:I386 /nodefaultlib:"libcmt" /def:"libclamav.def"
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "libclamav - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "libclamav_Objs_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug\libclamav"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBCLAMAV_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /I "." /I "include" /I "../.." /I "../../libclamav" /I "../../libclamav/mspack" /I "../../libclamav/unrar" /I "../../libclamav/nsis" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBCLAMAV_EXPORTS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /D "_LZMA_IN_CB" /J /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x417 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib advapi32.lib ws2_32.lib pthreadVC2.lib /nologo /dll /debug /machine:I386 /nodefaultlib:"libcmt" /def:"libclamav.def" /out:"Debug/libclamavd.dll" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none /nodefaultlib
+
+!ENDIF 
+
+# Begin Target
+
+# Name "libclamav - Win32 Release"
+# Name "libclamav - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Group "unrar"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrar.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrar.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrar15.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrar15.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrar20.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrar20.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarcmd.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarcmd.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarfilter.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarfilter.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarppm.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarppm.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarvm.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unrar\unrarvm.h
+# End Source File
+# End Group
+# Begin Group "7zip"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zAlloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zAlloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zBuffer.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zBuffer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zCrc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zCrc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zExtract.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zExtract.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zHeader.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zHeader.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zIn.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zip.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zItem.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zItem.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zMethodID.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zMethodID.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\7zTypes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\LzmaDecode_cw.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\LzmaDecode_cw.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\7zip\LzmaTypes.h
+# End Source File
+# End Group
+# Begin Group "nsis"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\bzlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\bzlib_private.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\infblock.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\LZMADecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\LZMADecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\nsis_bzlib.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\nsis_zconf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\nsis_zlib.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\nsis_zutil.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\nulsft.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\nsis\nulsft.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\..\libclamav\aspack.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\binhex.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\blob.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\cab.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\chmunpack.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\cvd.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\dconf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\dsig.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\elf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\entconv.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\filetypes.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\fsg.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\hashtab.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\htmlnorm.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\is_tar.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\line.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\lockdb.c
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\libclamav\matcher-ac.c"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\libclamav\matcher-bm.c"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\libclamav\matcher-ncore.c"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\matcher.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\mbox.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\md5.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\message.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\mew.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\msexpand.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\mspack.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\ole2_extract.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\others.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\packlibs.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\pdf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\pe.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\petite.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\phish_domaincheck_db.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\phish_whitelist.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\phishcheck.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\readdb.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\rebuildpe.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\regex_list.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\rtf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\scanners.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\sha256.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\sis.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\snprintf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\special.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\spin.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\str.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\suecrypt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\table.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\text.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\tnef.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unsp.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\untar.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unzip.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\upack.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\upx.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\uuencode.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\vba_extract.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\wwunpack.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\yc.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\..\libclamav\aspack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\binhex.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\blob.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\cab.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\chmunpack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\clamav.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\cltypes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\cvd.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\dconf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\dsig.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\elf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\encoding_aliases.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\entconv.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\entitylist.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\execs.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\filetypes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\fsg.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\hashtab.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\htmlnorm.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\iana_tld.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\is_tar.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\line.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\lockdb.h
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\libclamav\matcher-ac.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\libclamav\matcher-bm.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\libclamav\matcher-ncore.h"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\matcher.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\mbox.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\md5.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\message.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\mew.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\msexpand.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\mspack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\ole2_extract.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\others.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\packlibs.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\pdf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\pe.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\petite.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\phish_domaincheck_db.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\phish_whitelist.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\phishcheck.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\readdb.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\rebuildpe.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\regex_list.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\rtf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\scanners.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\sha256.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\sis.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\snprintf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\special.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\spin.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\str.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\suecrypt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\table.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\text.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\tnef.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unsp.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\untar.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\unzip.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\upack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\upx.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\uuencode.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\vba_extract.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\wwunpack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\yc.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\libclamav.def
+# End Source File
+# Begin Source File
+
+SOURCE=.\libclamav.rc
+# End Source File
+# End Group
+# Begin Group "Compat Files"
+
+# PROP Default_Filter ""
+# Begin Group "Headers"
+
+# PROP Default_Filter ""
+# Begin Group "sys"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\include\sys\mman.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\sys\time.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=".\clamav-config.h"
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\dirent.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\filelist.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\flock.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\gethostbyname.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\inttypes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\osdeps.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\stdint.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\unistd.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\include\win32proc.h
+# End Source File
+# Begin Source File
+
+SOURCE=".\include\zzip-msvc.h"
+# End Source File
+# End Group
+# Begin Group "Sources"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\src\dirent.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\dllmain.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\flock.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\gettimeofday.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\mkstemp.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\mmap.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\platform.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\regex.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\winstat.c
+# End Source File
+# End Group
+# End Group
+# End Target
+# End Project
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/libclamav.rc clamav-release/contrib/msvc/libclamav.rc
--- clamav-0.91.2/contrib/msvc/libclamav.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/libclamav.rc	2007-07-12 12:36:19.984375000 +1000
@@ -0,0 +1,2 @@
+#define __MODULE__	"libclamav.dll"
+#include <clamav.rc>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/libclamav.vcproj clamav-release/contrib/msvc/libclamav.vcproj
--- clamav-0.91.2/contrib/msvc/libclamav.vcproj	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/libclamav.vcproj	2007-07-12 12:36:19.984375000 +1000
@@ -0,0 +1,1256 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="libclamav"
+	ProjectGUID="{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}"
+	RootNamespace="clamav"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\libclamav"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../libclamav/mspack;../../libclamav/unrar;../../libclamav/nsis"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBCLAMAV_EXPORTS;HAVE_CONFIG_H;_CRT_SECURE_NO_DEPRECATE;_USE_INT64;_INTEGRAL_MAX_BITS=64;_LZMA_IN_CB;$(NOINHERIT)"
+				MinimalRebuild="true"
+				ExceptionHandling="1"
+				BasicRuntimeChecks="3"
+				SmallerTypeCheck="false"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				OutputFile="$(OutDir)\$(ProjectName)d.dll"
+				LinkIncremental="2"
+				IgnoreDefaultLibraryNames=""
+				ModuleDefinitionFile="libclamav.def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				EnableCOMDATFolding="1"
+				ImportLibrary="$(TargetDir)$(TargetName).lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\libclamav"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../libclamav/mspack;../../libclamav/unrar;../../libclamav/nsis"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBCLAMAV_EXPORTS;HAVE_CONFIG_H;_CRT_SECURE_NO_DEPRECATE;_USE_INT64;_INTEGRAL_MAX_BITS=64;_LZMA_IN_CB;$(NOINHERIT)"
+				MinimalRebuild="true"
+				ExceptionHandling="1"
+				BasicRuntimeChecks="3"
+				SmallerTypeCheck="false"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				OutputFile="$(OutDir)\$(ProjectName)d.dll"
+				LinkIncremental="2"
+				IgnoreDefaultLibraryNames=""
+				ModuleDefinitionFile="libclamav.def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				EnableCOMDATFolding="1"
+				ImportLibrary="$(TargetDir)$(TargetName).lib"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\libclamav"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../libclamav/mspack;../../libclamav/unrar;../../libclamav/nsis"
+				PreprocessorDefinitions="WIN32;_WINDOWS;_USRDLL;LIBCLAMAV_EXPORTS;HAVE_CONFIG_H;_CRT_SECURE_NO_DEPRECATE;_USE_INT64;_INTEGRAL_MAX_BITS=64;_LZMA_IN_CB;$(NOINHERIT)"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				FloatingPointExceptions="false"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				ShowProgress="0"
+				LinkIncremental="1"
+				IgnoreDefaultLibraryNames=""
+				ModuleDefinitionFile="libclamav.def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\libclamav"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav;../../libclamav/mspack;../../libclamav/unrar;../../libclamav/nsis"
+				PreprocessorDefinitions="WIN32;_WINDOWS;_USRDLL;LIBCLAMAV_EXPORTS;HAVE_CONFIG_H;_CRT_SECURE_NO_DEPRECATE;_USE_INT64;_INTEGRAL_MAX_BITS=64;_LZMA_IN_CB;$(NOINHERIT)"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				FloatingPointExceptions="false"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				ShowProgress="0"
+				LinkIncremental="1"
+				IgnoreDefaultLibraryNames="libcmt.lib"
+				ModuleDefinitionFile="libclamav.def"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="1"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\libclamav\aspack.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\binhex.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\blob.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\cab.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\chmunpack.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\cvd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\dconf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\dsig.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\elf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\entconv.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\filetypes.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\fsg.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\hashtab.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\htmlnorm.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\is_tar.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\line.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\lockdb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher-ac.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher-bm.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher-ncore.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\mbox.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\md5.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\message.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\mew.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\msexpand.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\mspack.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\ole2_extract.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\others.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\packlibs.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\pdf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\pe.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\petite.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\phish_domaincheck_db.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\phish_whitelist.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\phishcheck.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\readdb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\rebuildpe.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\regex_list.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\rtf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\scanners.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\sha256.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\sis.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\snprintf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\special.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\spin.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\str.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\suecrypt.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\table.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\text.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\tnef.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\unsp.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\untar.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\unzip.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\upack.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\upx.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\uuencode.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\vba_extract.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\wwunpack.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\yc.c"
+				>
+			</File>
+			<Filter
+				Name="unrar"
+				>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrar.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrar.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrar15.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrar15.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrar20.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrar20.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarcmd.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarcmd.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarfilter.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarfilter.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarppm.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarppm.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarvm.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\unrar\unrarvm.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="7zip"
+				>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zAlloc.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zAlloc.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zBuffer.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zBuffer.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zCrc.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zCrc.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zDecode.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zDecode.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zExtract.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zExtract.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zHeader.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zHeader.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zIn.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zIn.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zip.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zItem.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zItem.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zMethodID.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zMethodID.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\7zTypes.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\LzmaDecode_cw.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\LzmaDecode_cw.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\7zip\LzmaTypes.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="nsis"
+				>
+				<File
+					RelativePath="..\..\libclamav\nsis\bzlib.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\bzlib_private.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\infblock.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\LZMADecode.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|x64"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|x64"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\LZMADecode.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\nsis_bzlib.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\nsis_zconf.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\nsis_zlib.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\nsis_zutil.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\nulsft.c"
+					>
+				</File>
+				<File
+					RelativePath="..\..\libclamav\nsis\nulsft.h"
+					>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\libclamav\aspack.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\binhex.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\blob.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\cab.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\chmunpack.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\clamav.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\cltypes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\cvd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\dconf.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\dsig.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\elf.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\encoding_aliases.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\entconv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\entitylist.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\execs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\filetypes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\fsg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\hashtab.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\htmlnorm.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\iana_tld.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\is_tar.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\line.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\lockdb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher-ac.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher-bm.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher-ncore.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\matcher.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\mbox.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\md5.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\mew.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\msexpand.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\mspack.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\ole2_extract.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\others.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\packlibs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\pdf.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\pe.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\petite.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\phish_domaincheck_db.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\phish_whitelist.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\phishcheck.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\readdb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\rebuildpe.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\regex_list.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\rtf.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\scanners.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\sha256.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\sis.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\snprintf.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\special.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\spin.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\str.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\suecrypt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\table.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\text.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\tnef.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\unsp.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\untar.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\unzip.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\upack.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\upx.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\uuencode.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\vba_extract.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\wwunpack.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\yc.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\libclamav.def"
+				>
+			</File>
+			<File
+				RelativePath=".\libclamav.rc"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Compat Files"
+			>
+			<Filter
+				Name="Header Files"
+				>
+				<File
+					RelativePath=".\clamav-config.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\dirent.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\filelist.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\flock.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\gethostbyname.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\inttypes.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\osdeps.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\regex.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\stdint.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\target.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\unistd.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\utime.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\win32proc.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\zzip-msvc.h"
+					>
+				</File>
+				<Filter
+					Name="sys"
+					>
+					<File
+						RelativePath=".\include\sys\mman.h"
+						>
+					</File>
+					<File
+						RelativePath=".\include\sys\time.h"
+						>
+					</File>
+				</Filter>
+			</Filter>
+			<Filter
+				Name="Source Files"
+				>
+				<File
+					RelativePath=".\src\dirent.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\dllmain.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\flock.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\gettimeofday.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\mkstemp.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\mmap.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\platform.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\regex.c"
+					>
+				</File>
+				<File
+					RelativePath=".\src\winstat.c"
+					>
+				</File>
+			</Filter>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/sigtool.dsp clamav-release/contrib/msvc/sigtool.dsp
--- clamav-0.91.2/contrib/msvc/sigtool.dsp	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/sigtool.dsp	2007-07-12 12:36:20.031250000 +1000
@@ -0,0 +1,252 @@
+# Microsoft Developer Studio Project File - Name="sigtool" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=sigtool - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "sigtool.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "sigtool.mak" CFG="sigtool - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "sigtool - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "sigtool - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "sigtool - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "sigtool_Objs_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release\sigtool"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "../../" /I "." /I "include" /I "../.." /I "../../libclamav" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /J /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x417 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib ws2_32.lib advapi32.lib pthreadVC2.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "sigtool - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "sigtool_Objs_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug\sigtool"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "../.." /I "." /I "include" /I "../../libclamav" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "HAVE_CONFIG_H" /D "_USE_INT64" /D _INTEGRAL_MAX_BITS=64 /J /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x417 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib ws2_32.lib advapi32.lib pthreadVC2.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "sigtool - Win32 Release"
+# Name "sigtool - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\..\sigtool\sigtool.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\sigtool\vba.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\..\shared\cdiff.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\misc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\options.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\sigtool\vba.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\sigtool.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\sigtool.rc
+# End Source File
+# End Group
+# Begin Group "Compat Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\src\dirent.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\flock.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\getpass.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\gettimeofday.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\mkstemp.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\mmap.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\platform.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\src\winstat.c
+# End Source File
+# End Group
+# Begin Group "Shared"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\shared\cdiff.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\cfgparser.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\misc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\options.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\shared\output.c
+# End Source File
+# End Group
+# Begin Group "libclamav"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\libclamav\blob.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\cvd.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\dsig.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\entconv.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\hashtab.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\htmlnorm.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\md5.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\ole2_extract.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\others.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\sha256.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\snprintf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\str.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\libclamav\vba_extract.c
+# End Source File
+# End Group
+# End Target
+# End Project
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/sigtool.ico clamav-release/contrib/msvc/sigtool.ico
--- clamav-0.91.2/contrib/msvc/sigtool.ico	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/sigtool.ico	2007-07-12 12:36:19.937500000 +1000
@@ -0,0 +1,5 @@
+        h  F         ¨  ®       h  V         ¨  ¾  (                @                      *++ <;9 ÖÖÓ ãİÚ KON ‡ŠŠ ... µ´± ĞÍÊ âäâ µ©¦ ÉÌË £vu ¿Ÿ ÅËË --- ÿÿÿ åãâ ããâ ¢‡ƒ ³ ¥ji ²pp ’MK ¦} ÕÕÕ ùøø çäã ´ ÙÎÍ À—– ¹“‘ ¥on ­bc Š77 `_ v€€ srs ùòó ÏÑÌ ¿¸» èèé Õ¶¶ ´op ˜MK  QP QP ¢RR <; ó×× ÒÍÈ ±²ª à×à Sq3 ¿½¼ —ŸŒ ªWY ­XX ÉŸŸ Ğ¹¹ ÖÅÄ ±cd ¿œ› {yz ÎÊÊ {d u` ±¶¦ .[ Tk8 ¿¶» âÛÚ ñ÷ö îñğ ñúù °cc Å¢¡ ¯©£ ÄÃ¼ ¬³ ~•j „–q øöÿ ®‘ W  bK øúú õõõ îôó ·yy àÄÄ «ª« a|E {j 3 oE: ”x} ˆ´z Kƒ3 áÔÙ ŞËÊ üÿÿ ãâá Ğ‹‹ °¬¬ _]^ ÏÍÇ h†O ±Ë© „EI % sc[ ¿ï¾ =Š* Ñ¯ª ×   åÏÎ àÌÊ ÿÓÓ %++  ßâÒ Uj9 X‡? ‰¥| øËÔ @%! ßÍİ p¶h „°w å¦ Öµ³ Ï¯­ ÿİÜ  ïäï (i )} ¬½¥ ÇÅ¿ }Íx N»H Œ¸{ Ş¢¨ ç££ ÿĞĞ  khg ²È£ [B 'v
+ %† L«@ A»8 ‰³y ñ§´ ßÄÄ n[[ %$!  ×ÇÎ [™G |¢m R¯A —‹’ óûé ZUR –““ • °¥  ¯®© ^^Z                                                                                                                                                                                                                                                                                                                                                                 ©ª«            ¡¢£¤¥¦         •–—˜™š›œ       ˆ‰Š‹Œ‘’    z{|}~€‚ƒ„…†   jklmnopqrstuvw   \]^_`abcdefghi NOPQRSTUVWXYZ[   ABCDEFGHIJKLM   3456789:;<=>?    '()*+,-./012     !"#$             	
+                ÿÿ  ñÿ  à  À  À  €  €  À   €   à   à   ğ   ğ  ø  ü  ÿŸ  (       @         €                                                           .!! 9&& @(( @,* ?2. ;7. <<* <A$ :G! 8M 7Q 7X 6` 6f 5m 4q 4s 4u 4y 4| 5} 6 6… 9€ ;~  =}" Az$ Eu' Ht* Jr+ Lp, Nm- Pk. Sh3 Ve7 Y^= ]XA aSC dOC hLC qJC wID HE †CB HG “II ˜JJ ™LL šNN ›PP RR UT WU —[Y `] †ea kd {qf wtf uxg uze vb v†` uˆ^ s‡[ q‡X p…U m‚Q i„M e‰K ^“H W›D R£B M¦? L«? L°A PµF V¹M \½T _¿X bÀ[ f¼^ k¸c p²f u®j {ªo €¦t „¢w ˆ™z ‹’} ‰ „~ “~z ™wu Ÿon ¥ih ¨fe ªcc «bb ¬bb ®cc °ee ²hh ´jj µll ·pp ¸ss ¹uu ºvv ¹ww ¹yy º|| ¹ ¹ƒƒ ·†† ºˆˆ ¸ŒŒ ¶ ´‘ ±” «– ¥—’  ˜“ ™• œ™” ››“ š›’ ™ ˜ Œ —¢‰ •§ˆ —­‡ ˜±‰ œ³ Ÿ¶’ ¡µ• £µ˜ ¥¶› §¶œ ¨µ ©´ ©±  ©¬£ ªª¤ ¬¨¤ ²¥¢ ¹¢  ¾  Äœ É›š Îšš Òšš Ö›› ×›› Øœœ Ùœœ Ù ÚŸŸ Û¡¡ Ú££ Ù¥¥ ×¨¨ Õ«ª Õ®¬ Î¯­ Ç¯® Á°® ½´¯ º¸° ¹»± ¹»³ º¹µ ¼¹· ½º¸ ¿¼» Á¾½ Â¿¾ Ã¿¾ Ë¿¾ Ó¿¾ Ù¿½ ×À¾ ÔÁÀ ÏÄÃ ÎÅÄ ÌÇÇ ÍÉÈ ÎÌÊ ÎÍË ÏÏË ÒĞÌ ÒÑÎ ÔÒÏ ÔÓĞ ÕÓÒ ÖÔÓ ØÕÔ ÙÖÔ ÙÖÕ Ú×Ö ÛØÖ ÛÙ× ÜÚØ İÛÙ ŞÛÚ ŞÜÛ ŞİÜ ßŞİ àßŞ áàà âáà ãâá äââ åãã æãã çäã éåå éææ éèç êéè ëëê ëìê ììë ììë ííì ííì îîî ïïî ïğï ğğğ ñññ ñññ òòò ôôô ÷÷÷ ùùù ûûû ûûû üûû ÿÿÿ ‹k‹åŸj¼‹ ãRÍ4À”ÍjÔdO›¾]–ºÀ÷jJÜd#&&&ZgË”’Í’U¹U"%&&&[[[[ÍÄÄË¾jäh"&&Zab`][¤zƒ­Æí*!"&)g˜f]`^b³Æ§§©©°Â º,*"WÛÏ·Ìåaa]]YÅ©®°±¬£‹ ¹QU,"ºì±7mŸï^cY¹±®±³³¥×ÄjìS1OW-åé>kÉ¹bY´©°³ÄÄÆ³±ËŒÓàNQRVù¤;5‹ô^Yš®±³Ä²îÛ­®è‹ÎUg0à:6jşX&*”Ä®©°ùóÄ­²şû1gU668Œ÷&#V¹´¤´óù÷Ä©§ßÀ/‘gU8F97Àœ" ¹Şóúıüú÷Ï©„³ş×·ÁNS’NS ¼àÌÍ*âñ÷ùúúùõÜƒƒ‚şJøÓÜÑT’Oh»şPNîò÷øøõñë§€}ë×éjÓœO’’ºê1Ó¹Òìñòñîìé€}yÖË»‰3NSNOTU·l‰²Úêëëêéå}ywÎ·ÊJÒÎS1‘¹Tj€pu}Æßååäà}vsĞŒŸÓëÀ¾˜RÀŸÈ‰Dtuuwx‚€¤sDèúÀÈèêÁ ä··°xBDrsssssrDCrşåİû»ÀÊäåÔ¥¥€DBCCDDCBA>¥şıäìşò¡näâ†¥¥†zE???>>;<æøÚòşå¡Éà´…††…„‚~y>;AËüåÌéõà·m¶Â¤†„ƒ‚p;mÂğşØÀØåŞ¢ˆ€;rErA;;‚ËáşşÙ»ÀÔÖËm¡¿½;;;nÊİşì» »ËËËÉ¶¶¾ËÒîâ»‹‹Ÿ··»Ò÷şõåâñÿÿÿÿüÿÿÿúGÿÿøÿÿü?ÿä ?ÿà ÿà  ÿğ  ?ğ  À  €  À  ğ  ø  ğ   À   à   ğ   ü   ü   ü   ü   ÿ   ÿ  ÿ€ ÿÀ ÿÀ ÿà ÿø ÿş ?ÿÿÃÿ(                 @                              ÑÑÑ    ååå                                                ÆÆÆÆÇÑÁk–––•·Ë²¬                                    ÊÊÊ999h€Pªªªèd–Pûr¨fù[­NóšŒŠ±É¯¨9ĞĞĞ                    »˜¨‡şaŠIş3ÿ:˜(ÿQµGÿLÁFÿ€»oÿÌ››ÿÍ¤¤ù”ÂonnFèèè        Jº¾·ş@t"ÿ:„"ÿœÄ”ş¨È¤ÿ×}ÿ_ÆYÿ–³}ÿÖ¡ŸÿÜÿÛ©©ú‰k        ………E¦©ën‚Rş]†Bÿ†ªwşÎ°°şkCCÿ¹¹·ÿzÇrÿ€µmÿŞ¢¢ÿê¯¯ÿà±±ÿá»»üõîîL    vvv;mmmÆ´¼ªşpVÿ ·“ÿ‰QQÿT))ÿ}mmÿªÒ¢ÿ]GÿÏ¯¢ÿæªªÿåËËÿäÈÈÿã³³æşşş    ™™™¸¹³üp…Tÿz”eÿX11ÿnLLÿŒyyÿ¯qÿ_•JÿÓÓÉÿáĞĞÿöõõÿéÛÛÿÕ””ÿòââg    ²²²—²´¡ş¦­”şƒ–kÿ„–oÿÖÒÒÿ‘©ÿ6kÿq‘YÿîîîÿôôôÿóóóÿêèèÿË‹‹ÿŞ¹¹°    íííîîî¸¸¸ÏŒ“rÿ…’lÿ§±–ÿNk+ÿdyEÿ®ª£ÿÜÑÏÿëëëÿëëëÿæææÿ¿wwÿĞŸŸÒ            °°°Í´´¦ÿÈÈÆÿw}Zÿ¯²©ÿ—†ÿ®hhÿ´jjÿÉÿÑ³³ÿÑ¶¶ÿ´nnÿÌœœÌ            íííÚÚÚßÑÑÑÿ½½¹ÿÖÖÖÿÈ°°ÿµuuÿ§WWÿ©ZZÿª[[ÿ¨XXÿ£QQÿÛ¼¼                óóóXìììşáŞŞÿ¾­­ÿÔÁÁÿÃ““ÿ¾‰‰ÿ°nnÿ©``ÿ–@@ÿ¡ffşù÷÷;                    âââÜÜÜÿÖÔÔÿ±˜˜ÿ¯ÿ®vvÿ®ppÿSSÿ¥}}ÿäââ–                            ŞŞŞn½½½ñÉÉÉÿ»­­ÿÀ»»ÿ¢ppÿ²ôäääşşş                                ÷÷÷ÓÓÓbÆÆÆ‘ÌÌÌ‘ááá^ûûû            ëÿ  Áÿ     €            €   €   €   à   à   ğ   ø  ü  ş  (       @          €                                                                                                                                                                          ­­­™™™	            	ÁÁÁ                                                                                                ………n——–½äçãp    «««‹‹‹ÊºÃ·áÎĞÎA                                                                                            ˜˜˜¡¡¡íáâáÿk‘TúÍÏÍB___uÁÁÁıŠ¹ÿÊŞÅ                                                                            ÒÒÒ*999ÀÀÀuuuÚÕÕÕÿvcÿn—]ğ¥µ ê¿Òºş]¨NÿšÉ’Ï³³³	888B¿¿¿¦ñññ#ççç                                                        WWW}Ú›œ˜»333xjjjÇÚÛÚşx£fÿ3ÿ3‰ÿ3’ÿ3›"ÿB©6ÿƒ²~ãÉËÉøŠÊ„ÿ‹ªˆØ777y...jH111'uuuÍÍÍ                                    »»»RRR®ÏÏÏı›§ˆÿc~Gş±¿§ıg’Qÿ3xÿ3ƒÿ3ÿ3˜!ÿ5£(ÿ<¯2ÿ7³/ÿG¼Aÿ3²*ÿĞÒÃÿØ¾¾ÿÚ¿¿ÿŞËËşÃ¼¼è|||²[BBBÒÒÒ                                ”””Fˆˆˆúâââş˜jÿ8hÿ4pÿ3zÿ3†ÿ3‘ÿPªBÿg¾^ÿiÆcÿbË]ÿOÉLÿ;¾6ÿÂ¨šÿ¼ssÿÂ{{ÿÈ‚‚ÿÌ‰‰ÿÕŸŸÿŞÂÂüŠŠ¾A£££                    &?K000ª›››ıêíéşAo ÿ9tÿ3{ÿ3†ÿ>˜,ÿ…Â|ÿÔ™ÿ‚Ï}ÿQÈMÿaÔ`ÿYÌUÿkÅdÿÖ®­ÿáÁÁÿÔ™™ÿÓ‘‘ÿ×——ÿÚ››ÿİ¥¥ÿÏ»»í:::]¾¾¾                G   {   }Š¥¥¥ı¾Ê³ÿHt)ÿ?x"ÿ3zÿP–<ÿÛåÙşĞĞĞÿ±¯¯ÿÍÍÍÿäòãÿeÏbÿeÌaÿS¾LÿX·NÿG¦9ÿ×Ã¸ÿÙ™™ÿŞ  ÿâ¥¥ÿã§§ÿÜÿ¾––øqppV                rrrM˜˜˜Í¥§å¹¿®şpŠVÿ^ƒBÿI}-ÿ3xÿ¸Ê²şëëëşÊ¨¨ÿk77ÿvvÿ«««ÿìõëÿYÀRÿrÅkÿ8¥+ÿ·Ó«ÿŞ§§ÿŞ  ÿä¨¨ÿé¯¯ÿë±±ÿÊ––ÿåÖÖÿá»»öğïï9                ‡‡‡¹êêêürzRÿ:PÿTp3ÿv”^ÿX…=ÿJ„0ÿäääÿëææÿ™IIÿi//ÿV..ÿ…ÿÇÇÇÿ­Û¨ÿn½eÿF¤8ÿË¹¨ÿÛ››ÿâ¥¥ÿé¯¯ÿğ¸¸ÿó»»ÿØÃÃÿØµµÿä¨¨ÿêËËäşşş        ¾¾¾:::±”””üÔÔÔıàãÚş€“gÿqWÿm’Uÿ]ŒDÿôôôÿÆÿ†77ÿW((ÿS))ÿlSSÿ˜˜˜ÿî÷íÿ_¯RÿI8ÿ¯½—ÿŞ¢¢ÿä¨¨ÿì³³ÿô½½ÿä««ÿíëëÿâÙÙÿÛŸŸÿŞ¡¡ÿòää        ÛÛÛ;mBBB±ŸŸŸıÒØÉÿ`{Bÿ‚lÿP~4ÿßßßÿNNÿV##ÿQ''ÿS**ÿd??ÿŠŠŠÿüûûÿ]¥Mÿ8Œ"ÿC-ÿ•µƒÿä¿»ÿŞ  ÿÚššÿÏ¥¥ÿóóóÿïïïÿãººÿİŸŸÿİªªüııı-        ÒÒÒÁÁÁddd|||ıùùøşWn5ÿŠ uÿ^„Cÿ›¦“ÿHÿN$$ÿ`DDÿ];;ÿlAAÿ”””ÿñöïÿ7†ÿ3ÿd›Pÿ°Ê¥ÿÏ¸³ÿÃÿÏ±±ÿóïïÿõõõÿñññÿß¼¼ÿÛ››ÿÓ’’ÿïİİŸ                BBBAÀÀÀø«±˜ÿNa(ÿ“£~ÿˆŸrÿf‡KÿrRPÿV22ÿ\\ÿ{VVÿmOOÿÁÀÀÿ¬È ÿ3xÿ3tÿ´È«ÿİİİÿïïïÿ÷÷÷ÿûûûÿúúúÿöööÿñññÿãÎÎÿ×––ÿĞÿÛ®®óşşş
+        ×××4¯¯¯éÅÅ·ÿ:@ÿz„\ÿl|Mÿ“¤~ÿ|•cÿm‰Rÿ§£œÿÇ··ÿßßßÿÍÍÍÿĞİÊÿ?x"ÿ3mÿ3jÿâçßÿíííÿñññÿõõõÿ÷÷÷ÿöööÿóóóÿğğğÿãÛÛÿËˆˆÿË‡‡ÿÈ††ÿıııH        ÎÎÎBtttıòòñıÖÖÒüÛÛÛüÕÙÌÿhxHÿ—¦‚ÿy_ÿƒšnÿµµµÿüıüÿr“Zÿ6gÿ3dÿ3bÿ7bÿy“aÿìììÿîîîÿñññÿòòòÿòòòÿğğğÿíííÿéééÿÑœœÿÆ€€ÿÀxxÿôèè}            ºººa×××?æææ#‹‹‹àÔÔÔş­³šÿ|ˆ_ÿ˜¥ƒÿ–¥ÿ¼Ã³ÿéìæÿ3Yÿ7]ÿ>bÿTs4ÿÖÙÒÿ´¾¨ÿÕØÑÿëëëÿíííÿîîîÿíííÿìììÿêêêÿæææÿÅÿÀxxÿ»qqÿêÕÕ                        ÊÊÊ^¶¶¶ÿ¤§ÿbi=ÿ{†_ÿlyKÿdÿwˆZÿj~KÿcxCÿ>XÿÀ¶¯ÿŠ||ÿ¥””ÿÏ««ÿáØØÿèèèÿéééÿéééÿèèèÿæææÿãããÿ½wwÿºppÿµiiÿåÌÌ¬                        ²²²ŠÉÉÉıuuUÿœœˆÿÒÒÒÿÑÒÌÿnwOÿS_-ÿ›¢Šÿ¸¼¯ÿjuLÿ¡Œ}ÿ¹€€ÿ©ggÿ²ffÿ½xxÿØÂÂÿâİİÿäääÿãããÿâââÿßßßÿ·xxÿ³ggÿ¯aaÿçĞĞ§                        ššš°ªªªıÕÕÓÿéééÿÁÁÁÿ»»»ÿ¦§˜ÿsuUÿÁÁÁÿªªªÿÅÆÄÿ¢—Šÿ§WWÿ®ccÿ±eeÿ²ffÿµiiÿ·mmÿÀ……ÿ½~~ÿ¼}}ÿÅ››ÿ¸{{ÿ¬^^ÿ¨XXÿñåå                        ÷÷÷
+¿¿¿tÄÄÄñåååÿèèèÿ¬¬¬ÿÄÄÂÿ¨¨šÿâââÿ±±±ÿ¶²²ÿÈ¤¤ÿ²mmÿ¥SSÿ¨XXÿ«[[ÿ­^^ÿ®``ÿ¯aaÿ®``ÿ­__ÿ«\\ÿ©YYÿ¥TTÿª__ÿşıı^                                äääÜÜÜÿùùùÿ¶¶¶ÿÀ¿¿ÿÈÈÈÿâââÿãããÿÜÔÔÿÅ––ÿÆ——ÿº~~ÿ¥VVÿ£QQÿ¥TTÿ¦UUÿ§VVÿ¦VVÿ¥TTÿ¤RRÿ¡OOÿJJÿÆ––üÿÿÿ                                ûûûâââîëëëÿşşşÿîîîÿµ©©ÿllÿâââÿâááÿÀ““ÿÅ––ÿÅ••ÿÃÿ´ttÿ¦ZZÿŸLLÿKKÿKKÿIIÿœGGÿ66ÿDDÿîãã¶                                        òòò_ÚÚÚşîîîÿüüüÿäääÿ°ŸŸÿÇÇÇÿßßßÿÍ³³ÿ¿ÿÂ’’ÿÂ‘‘ÿÁÿ¿‹‹ÿ¼……ÿ¶zzÿ°ooÿ—BBÿ‡,,ÿQQÿÕÊÊıúúú9                                            ããã˜ÎÎÎÿæææÿğğğÿßßßÿº±±ÿ¡yyÿ¿««ÿÎ»»ÿÃ——ÿÁÿ¿ÿ½ŠŠÿ»††ÿ¹‚‚ÿªggÿ‚,,ÿŸwwÿÈ¿¿ÿíìì•                                                ıııØØØ¤ÂÂÂÿØØØÿãããÿİİİÿ¹¨¨ÿ¬””ÿ¥€€ÿ†33ÿbbÿšYYÿ¢__ÿœQQÿ::ÿ„((ÿ§††ÿÌÌÌÿààà½ııı                                                    şşşÙÙÙµµµüÂÂÂÿÕÕÕÿÖÖÖÿÌËËÿ¤yyÿ³¥¥ÿ¾¾¾ÿ½ººÿˆ::ÿ~  ÿˆ55ÿ¢ooÿÊÉÉşÜÜÜ¨üüü	                                                                êêê9···Ê§§§ÿ¸¸¸ÿÊÊÊÿÌÌÌÿËËËÿÈÆÆÿ¾¯¯ÿ¼««ÿÄ¼¼ÿËËËÿÒÒÒÖìììU                                                                                áááD¸¸¸¢™™™çş©©©ÿ±±±ÿ²²²ş¶¶¶ãÒÒÒ•ñññ;şşş                                                                                                ğğğããã/ááá/ííí                                        ÿÿÿÿüçÿÿøCÿÿøÿÿ€ ÿ€  ÿ€  ?À           €        €  à   À   À   à   ü   ü   ü   ü   ÿ   ÿ  ÿ€ ÿÀ ÿÀ ÿà ÿø ÿş ?ÿÿÃÿ
\ No newline at end of file
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/sigtool.rc clamav-release/contrib/msvc/sigtool.rc
--- clamav-0.91.2/contrib/msvc/sigtool.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/sigtool.rc	2007-07-12 12:36:19.906250000 +1000
@@ -0,0 +1,3 @@
+#define __MODULE__	"sigtool.exe"
+#define __ICON__	"sigtool.ico"
+#include <clamav.rc>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/sigtool.vcproj clamav-release/contrib/msvc/sigtool.vcproj
--- clamav-0.91.2/contrib/msvc/sigtool.vcproj	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/sigtool.vcproj	2007-07-12 12:36:19.906250000 +1000
@@ -0,0 +1,526 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="sigtool"
+	ProjectGUID="{5163901E-4C74-421E-A053-7599C3A9D9B8}"
+	RootNamespace="clamav"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\sigtool"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				MinimalRebuild="true"
+				ExceptionHandling="1"
+				BasicRuntimeChecks="3"
+				SmallerTypeCheck="false"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\sigtool"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				MinimalRebuild="true"
+				ExceptionHandling="1"
+				BasicRuntimeChecks="3"
+				SmallerTypeCheck="false"
+				RuntimeLibrary="3"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\sigtool"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				LinkIncremental="1"
+				IgnoreDefaultLibraryNames=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\sigtool"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=".;include;../..;../../libclamav"
+				PreprocessorDefinitions="WIN32;_CONSOLE;HAVE_CONFIG_H;_USE_INT64;_INTEGRAL_MAX_BITS=64;$(NOINHERIT)"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				DefaultCharIsUnsigned="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib pthreadVC2.lib"
+				LinkIncremental="1"
+				IgnoreDefaultLibraryNames="libcmt.lib"
+				GenerateDebugInformation="false"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+		<ProjectReference
+			ReferencedProjectIdentifier="{0E45E0DC-F9DB-4F31-A58C-1515EDE2A95B}"
+			RelativePathToProject=".\libclamav.vcproj"
+		/>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\libclamav\blob.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\sigtool\sigtool.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\sigtool\vba.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\shared\cdiff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\misc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\options.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\sigtool\vba.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Shared"
+			>
+			<File
+				RelativePath="..\..\shared\cdiff.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\cfgparser.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\getopt.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\misc.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\options.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\shared\output.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Compat Files"
+			>
+			<File
+				RelativePath=".\src\dirent.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\flock.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\getpass.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gettimeofday.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\mkstemp.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\mmap.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\platform.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\winstat.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="libclamav"
+			>
+			<File
+				RelativePath="..\..\libclamav\cvd.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\dsig.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\entconv.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\hashtab.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\htmlnorm.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\md5.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\ole2_extract.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\others.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\sha256.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\snprintf.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\str.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\libclamav\vba_extract.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\sigtool.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/dirent.c clamav-release/contrib/msvc/src/dirent.c
--- clamav-0.91.2/contrib/msvc/src/dirent.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/dirent.c	2007-07-12 12:36:19.421875000 +1000
@@ -0,0 +1,290 @@
+/*
+ * Clamav Native Windows Port : dirent win32 compatibility layer
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * Dirent for win32 is part of GNU Make
+ * Wrapped Unicode version by Alex Cherney <alch@sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <clamav-config.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include "dirent.h"
+
+DIR *opendir(const char* pDirName)
+{
+    struct stat sb;
+    DIR* pDir;
+    char* pEndDirName;
+    int nBufferLen;
+
+    /* sanity checks */
+    if (!pDirName)
+    {
+        errno = EINVAL;
+        return NULL;
+    }
+
+    if (stat(pDirName, &sb) != 0)
+    {
+        errno = ENOENT;
+        return NULL;
+    }
+
+    if ((sb.st_mode & S_IFMT) != S_IFDIR)
+    {
+        errno = ENOTDIR;
+        return NULL;
+    }
+
+    /* allocate a DIR structure to return */
+    pDir = (DIR *) malloc(sizeof(DIR));
+
+    if (!pDir) return NULL;
+
+    /* input directory name length */
+    nBufferLen = strlen(pDirName);
+
+    /* copy input directory name to DIR buffer */
+    strcpy(pDir->dir_pDirectoryName, pDirName);
+
+    /* point to end of the copied directory name */
+    pEndDirName = &pDir->dir_pDirectoryName[nBufferLen - 1];
+
+    /* if directory name did not end in '/' or '\', add '\' */
+    if ((*pEndDirName != '/') && (*pEndDirName != '\\'))
+    {
+        pEndDirName++;
+        *pEndDirName = '/';
+    }
+
+    /* now append the wildcard character to the buffer */
+    pEndDirName++;
+    *pEndDirName = '*';
+    pEndDirName++;
+    *pEndDirName = '\0';
+
+    /* other values defaulted */
+    pDir->dir_nNumFiles = 0;
+    pDir->dir_hDirHandle = INVALID_HANDLE_VALUE;
+    pDir->dir_ulCookie = __DIRENT_COOKIE;
+
+    return pDir;
+}
+
+int closedir(DIR *pDir)
+{
+    /* got a valid pointer? */
+    if (!pDir)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    /* sanity check that this is a DIR pointer */
+    if (pDir->dir_ulCookie != __DIRENT_COOKIE)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    /* close the WINDOWS32 directory handle */
+    if (pDir->dir_hDirHandle != INVALID_HANDLE_VALUE)
+        FindClose(pDir->dir_hDirHandle);
+
+    free(pDir);
+    return 0;
+}
+
+/*
+ * Unicode version of  readdir to be used on NT platforms
+ * deals with unicode filenames by using 8.3 name if translation
+ * from unicode to ansi fails
+ */
+struct dirent *readdir_w(DIR* pDir)
+{
+    WIN32_FIND_DATAW wfdFindData;
+    wchar_t wtemp[MAX_PATH + 1];
+    char atemp[MAX_PATH + 1];
+    BOOL invalid;
+
+    if (!pDir)
+    {
+        errno = EINVAL;
+        return NULL;
+    }
+
+    /* sanity check that this is a DIR pointer */
+    if (pDir->dir_ulCookie != __DIRENT_COOKIE)
+    {
+        errno = EINVAL;
+        return NULL;
+    }
+
+    if (pDir->dir_nNumFiles == 0)
+    {
+        if(!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pDir->dir_pDirectoryName, -1, wtemp, sizeof(wtemp)))
+            return NULL;
+        pDir->dir_hDirHandle = FindFirstFileW(wtemp, &wfdFindData);
+        if (pDir->dir_hDirHandle == INVALID_HANDLE_VALUE)
+            return NULL;
+    }
+    else
+        if (!FindNextFileW(pDir->dir_hDirHandle, &wfdFindData))
+            return NULL;
+
+    /* bump count for next call to readdir() or telldir() */
+    pDir->dir_nNumFiles++;
+
+    if(wcslen(wfdFindData.cAlternateFileName) &&
+        (!WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, wfdFindData.cFileName, -1, atemp, sizeof(atemp), NULL, &invalid) || invalid))
+    {
+        /* unicode name is not directly translable to ascii so use the shortname instead */
+        WideCharToMultiByte(CP_ACP, 0, wfdFindData.cAlternateFileName, -1, atemp,sizeof(atemp), NULL, NULL);
+    }
+    else
+        WideCharToMultiByte(CP_ACP, 0, wfdFindData.cFileName, -1, atemp,sizeof(atemp), NULL, NULL);
+
+    strcpy(pDir->dir_sdReturn.d_name, atemp);
+    return &pDir->dir_sdReturn;
+}
+
+/* 
+ * Ansi version of readdir to be used on 9x platforms
+ * Windows9x doesn't allow creation of a filename in codepage different to
+ * the default, therefore we don't have to mess up with unicows.dll
+ * and can use the ansi functions
+ */
+struct dirent *readdir_a(DIR* pDir)
+{
+    WIN32_FIND_DATAA wfdFindData;
+
+    if (!pDir)
+    {
+        errno = EINVAL;
+        return NULL;
+    }
+
+    /* sanity check that this is a DIR pointer */
+    if (pDir->dir_ulCookie != __DIRENT_COOKIE)
+    {
+        errno = EINVAL;
+        return NULL;
+    }
+
+    if (pDir->dir_nNumFiles == 0)
+    {
+        pDir->dir_hDirHandle = FindFirstFileA(pDir->dir_pDirectoryName, &wfdFindData);
+        if (pDir->dir_hDirHandle == INVALID_HANDLE_VALUE)
+            return NULL;
+    }
+    else
+        if (!FindNextFileA(pDir->dir_hDirHandle, &wfdFindData))
+            return NULL;
+
+    /* bump count for next call to readdir() or telldir() */
+    pDir->dir_nNumFiles++;
+
+    /* fill in struct dirent values */
+    strcpy(pDir->dir_sdReturn.d_name, (strchr(wfdFindData.cFileName, '?')) ? wfdFindData.cAlternateFileName : wfdFindData.cFileName);
+    return &pDir->dir_sdReturn;
+}
+
+/*
+ * load an appropriate version (unicode or ansi) of readdir
+ * we need that to handle scanning of unicode filenames in libclamav
+ * Windows9x doesn't allow creation of a filename in codepage different to
+ * the default, therefore we don't have to mess up with unicows.dll
+ */
+struct dirent *readdir(DIR* pDir)
+{
+    unixpath_to_win32(pDir->dir_pDirectoryName);
+    if(isWin9x())
+        return readdir_a(pDir);
+    else
+        return readdir_w(pDir);
+}
+
+void rewinddir(DIR* pDir)
+{
+    if (!pDir)
+    {
+        errno = EINVAL;
+        return;
+    }
+
+    /* sanity check that this is a DIR pointer */
+    if (pDir->dir_ulCookie != __DIRENT_COOKIE)
+    {
+        errno = EINVAL;
+        return;
+    }
+
+    /* close the WINDOWS32 directory handle */
+    if (pDir->dir_hDirHandle != INVALID_HANDLE_VALUE)
+        if (!FindClose(pDir->dir_hDirHandle))
+            errno = EBADF;
+
+    /* reset members which control readdir() */
+    pDir->dir_hDirHandle = INVALID_HANDLE_VALUE;
+    pDir->dir_nNumFiles = 0;
+    return;
+}
+
+int telldir(DIR* pDir)
+{
+    if (!pDir)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    /* sanity check that this is a DIR pointer */
+    if (pDir->dir_ulCookie != __DIRENT_COOKIE)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    /* return number of times readdir() called */
+    return pDir->dir_nNumFiles;
+}
+
+void seekdir(DIR* pDir, long nPosition)
+{
+    if (!pDir) return;
+
+    /* sanity check that this is a DIR pointer */
+    if (pDir->dir_ulCookie != __DIRENT_COOKIE)
+        return;
+
+    /* go back to beginning of directory */
+    rewinddir(pDir);
+
+    /* loop until we have found position we care about */
+    for (--nPosition; nPosition && readdir(pDir); nPosition--);
+
+    /* flag invalid nPosition value */
+    if (nPosition)
+        errno = EINVAL;
+    return;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/dllmain.c clamav-release/contrib/msvc/src/dllmain.c
--- clamav-0.91.2/contrib/msvc/src/dllmain.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/dllmain.c	2007-07-12 12:36:19.390625000 +1000
@@ -0,0 +1,250 @@
+/*
+ * Clamav Native Windows Port
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <osdeps.h>
+#include <dbghelp.h>
+
+#define MINDUMP_FLAGS (MiniDumpWithDataSegs  | MiniDumpWithIndirectlyReferencedMemory | MiniDumpFilterModulePaths)
+
+typedef BOOL (WINAPI *pMiniDumpWriteDumpFunc)(HANDLE hProcess,
+                                              DWORD dwPid,
+                                              HANDLE hFile,
+                                              MINIDUMP_TYPE DumpType,
+                                              CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
+                                              CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
+                                              CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam);
+
+uint32_t LIBCLAMAV_API Platform = 0;
+memhelpers_t LIBCLAMAV_API memhelpers = { FALSE, NULL, NULL, NULL, NULL };
+
+#define Q(string) # string
+#define IMPORT_FUNC(hLib, x) \
+    memhelpers.x = ( imp_##x ) GetProcAddress(hLib, Q(x)); \
+    if (!memhelpers.x) return;
+
+static void init_memhelpers(void)
+{
+    /* kernel32.dll and advapi32.dll should be linked by libclamav anyway */
+    HINSTANCE hKernel = GetModuleHandleA("kernel32.dll");
+    HINSTANCE hAdvapi32 = GetModuleHandleA("advapi32.dll");
+    memhelpers.ok = FALSE;
+
+    if (!hKernel || !hAdvapi32) return;
+
+    /* kernel32 */
+    IMPORT_FUNC(hKernel, CreateToolhelp32Snapshot);
+    IMPORT_FUNC(hKernel, Process32First);
+    IMPORT_FUNC(hKernel, Process32Next);
+    IMPORT_FUNC(hKernel, Module32First);
+    IMPORT_FUNC(hKernel, Module32Next);
+    IMPORT_FUNC(hKernel, CreateRemoteThread);
+
+    /* advapi32 */
+    IMPORT_FUNC(hAdvapi32, OpenProcessToken);
+    IMPORT_FUNC(hAdvapi32, LookupPrivilegeValueA);
+    IMPORT_FUNC(hAdvapi32, AdjustTokenPrivileges);
+
+    if (memhelpers.CreateToolhelp32Snapshot &&
+        memhelpers.Process32First &&
+        memhelpers.Process32Next &&
+        memhelpers.Module32First &&
+        memhelpers.Module32Next &&
+        memhelpers.CreateRemoteThread &&
+        memhelpers.OpenProcessToken &&
+        memhelpers.LookupPrivilegeValueA &&
+        memhelpers.AdjustTokenPrivileges) memhelpers.ok = TRUE;
+}
+
+static uint32_t GetWindowsVersion(void)
+{
+    OSVERSIONINFOA osv;
+    memset(&osv, 0, sizeof(osv));
+    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
+
+    if (!GetVersionEx((LPOSVERSIONINFOA) &osv))
+        osv.dwPlatformId = 0x0010400; /* Worst case report as Win95 */
+
+    return ((osv.dwPlatformId << 16) | (osv.dwMajorVersion << 8) | (osv.dwMinorVersion));
+}
+
+/* avoid bombing in stupid msvcrt checks - msvcrt8 only */
+#if _MSC_VER >= 1400
+void clamavInvalidParameterHandler(const wchar_t* expression,
+   const wchar_t* function,
+   const wchar_t* file,
+   unsigned int line,
+   uintptr_t pReserved) {}
+#else
+#define _set_invalid_parameter_handler(x)
+#endif
+
+DWORD WINAPI CrashMiniDumpWriteDumpProc(LPVOID lpParam)
+{
+    EXCEPTION_POINTERS *pExPtrs = (EXCEPTION_POINTERS *) lpParam;
+    LONG retval = EXCEPTION_EXECUTE_HANDLER;
+    MINIDUMP_EXCEPTION_INFORMATION ExInfo;
+    pMiniDumpWriteDumpFunc pMiniDumpWriteDump = NULL;
+    HANDLE hFile = INVALID_HANDLE_VALUE;
+    HANDLE hMapFile = NULL;
+    LPBYTE lpMapAddress = NULL;
+    BY_HANDLE_FILE_INFORMATION FileInformation;
+    HMODULE hDll;
+    char name[MAX_PATH] = "", fullpath[MAX_PATH] = "";
+    char *lSlash = NULL;
+    int i;
+
+    if (!GetModuleFileName(NULL, fullpath, MAX_PATH)) /* Very unlikely */
+        strncat(name, "LibClamAV", MAX_PATH);
+    else
+    {
+        /* Get executable name */
+        char *p = fullpath + strlen(fullpath) - 1;
+        while (*p && (*p != '\\')) p--;
+        strncat(name, ++p, MAX_PATH);
+    }
+
+    fprintf(stderr, "*** ClamWinDumper ***\n"
+                    "*** %s Crashed\n"
+                    "    ExpCode   : 0x%8.8x\n"
+                    "    ExpAddress: 0x%8.8x\n",
+                    name,
+                    pExPtrs->ExceptionRecord->ExceptionCode,
+                    pExPtrs->ExceptionRecord->ExceptionAddress);
+
+    /* Try to get dll from executable directory, win2k dbghelp misses symbols */
+    lSlash = strrchr(fullpath, '\\');
+    if (lSlash)
+    {
+        strcpy(lSlash + 1, "dbghelp.dll");
+        hDll = LoadLibrary(fullpath);
+    }
+
+    /* Load the version provided by the environment */
+    if (!hDll) hDll = LoadLibrary("dbghelp.dll");
+
+    if (!hDll)
+    {
+        fprintf(stderr, "Cannot find dbghelp.dll you must install it to produce a crash dump\n");
+        return retval;
+    }
+
+    pMiniDumpWriteDump = (pMiniDumpWriteDumpFunc) GetProcAddress(hDll, "MiniDumpWriteDump");
+    if (!pMiniDumpWriteDump)
+    {
+        fprintf(stderr, "Your dbghelp.dll is too old, put an updated version\n"
+                        "in the same directory of the executable\n");
+        goto cleanup;
+    }
+
+    strncat(name, ".dmp", MAX_PATH);
+    hFile = CreateFile(name, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (hFile == INVALID_HANDLE_VALUE)
+    {
+        fprintf(stderr, "Cannot open file for writing\n");
+        goto cleanup;
+    }
+
+    ExInfo.ThreadId = GetCurrentThreadId();
+    ExInfo.ExceptionPointers = pExPtrs;
+    ExInfo.ClientPointers = FALSE;
+
+    if (!pMiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, MINDUMP_FLAGS, &ExInfo, NULL, NULL))
+    {
+        fprintf(stderr, "MiniDumpWriteDump() failed with code %d\n", GetLastError());
+        goto cleanup;
+    }
+
+    /* Now scramble it by xor-ing with 42, to avoid false positives on the dump file */
+    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, "libClamAVDumper");
+
+    if (!hMapFile)
+    {
+        fprintf(stderr, "CreateFileMapping() on file failed (%d)\n", GetLastError());
+        goto cleanup;
+    }
+
+    lpMapAddress = (LPBYTE) MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
+    if (!lpMapAddress)
+    {
+        fprintf(stderr, "MapViewOfFile() on file failed (%d)\n", GetLastError());
+        goto cleanup;
+    }
+
+    if (!GetFileInformationByHandle(hFile, &FileInformation))
+    {
+        fprintf(stderr, "GetFileInformationByHandle() on file failed (%d)\n", GetLastError());
+        goto cleanup;
+    }
+
+    for (i = 0; i < FileInformation.nFileSizeLow; i++)
+        lpMapAddress[i] ^= 42;
+
+    FlushViewOfFile(lpMapAddress, 0);
+
+    fprintf(stderr, "Crash Dump saved as %s, please report\n", name);
+
+cleanup:
+    if (hMapFile) CloseHandle(hMapFile);
+    if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
+    FreeLibrary(hDll);
+    return retval;
+}
+
+static LONG __stdcall CrashHandlerExceptionFilter(EXCEPTION_POINTERS *pExPtrs)
+{
+    /* Spawn a new thread this should improve the dump */
+    DWORD tid = 0, res = -1;
+    HANDLE cProc = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) CrashMiniDumpWriteDumpProc, (LPVOID) pExPtrs, 0, &tid);
+
+    if (!cProc)
+    {
+        fprintf(stderr, "Cannot spawn crash dumper thread\n");
+        return -1;
+    }
+
+    if (WaitForSingleObject(cProc, INFINITE) == WAIT_OBJECT_0)
+        GetExitCodeThread(cProc, &res);
+
+    CloseHandle(cProc);
+    return res;
+}
+
+BOOL APIENTRY DllMain(HANDLE hModule, DWORD reason, LPVOID lpReserved)
+{
+    switch (reason)
+    {
+        case DLL_PROCESS_ATTACH:
+        {
+            DisableThreadLibraryCalls(hModule);
+            Platform = GetWindowsVersion();
+            _set_invalid_parameter_handler(clamavInvalidParameterHandler);
+            init_memhelpers();
+#ifndef _DEBUG /* this fools windows when calling the debugger */
+            SetUnhandledExceptionFilter(CrashHandlerExceptionFilter);
+#endif
+            break;
+        }
+        case DLL_THREAD_ATTACH:
+        case DLL_THREAD_DETACH:
+        case DLL_PROCESS_DETACH:
+            break;
+    }
+    return TRUE;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/dnsquery.c clamav-release/contrib/msvc/src/dnsquery.c
--- clamav-0.91.2/contrib/msvc/src/dnsquery.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/dnsquery.c	2007-07-12 12:36:19.421875000 +1000
@@ -0,0 +1,410 @@
+/*
+ * Clamav Native Windows Port: txt dns query for freshclam
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#if HAVE_CONFIG_H
+#include <clamav-config.h>
+#endif
+
+#include <windows.h>
+#include <windns.h>
+#include <iphlpapi.h>
+#include <inttypes.h>
+
+#include "others.h"
+#include "shared/output.h"
+
+char *txtquery_dnsapi(const char *domain, unsigned int *ttl);
+char *txtquery_compat(const char *domain, unsigned int *ttl);
+
+#define NS_INT8SZ 1
+#define NS_PACKETSZ 512
+#define ns_t_txt 16
+#define N_RETRY 5
+
+#define SETUINT16(x, v) *(uint16_t *) x = htons(v)
+
+#define GETUINT16(x) ntohs(*(uint16_t *) x)
+#define GETUINT32(x) ntohl(*(uint32_t *) x)
+
+/* Bound checks to avoid buffer overflows */
+#define NEED(len) \
+    /* cli_dbgmsg("DNS Resolver: Need %d bytes - Have %d bytes\n", len, numbytes - (seek - reply)); */ \
+    if (((seek + len) - reply) > numbytes) \
+    { \
+        cli_errmsg("DNS Resolver: Bound Check failed - Bad packet\n"); \
+        return NULL; \
+    }
+
+#ifndef HAVE_ATTRIB_PACKED
+#define __attribute__(x)
+#endif
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+
+typedef struct _simple_dns_query
+{
+    uint16_t transaction_id __attribute__ ((packed));
+    uint16_t flags __attribute__ ((packed));
+    uint16_t questions __attribute__ ((packed));
+    uint16_t ans_rrs __attribute__ ((packed));
+    uint16_t auth_rss __attribute__ ((packed));
+    uint16_t add_rss __attribute__ ((packed));
+    /* queries here */
+} simple_dns_query;
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack()
+#endif
+
+/* Switcher */
+char *txtquery(const char *domain, unsigned int *ttl)
+{
+    if (isWin9x())
+        return txtquery_compat(domain, ttl);
+    else
+        return txtquery_dnsapi(domain, ttl);
+}
+
+char *txtquery_dnsapi(const char *domain, unsigned int *ttl);
+char *txtquery_compat(const char *domain, unsigned int *ttl);
+
+static char *get_dns(void)
+{
+    FIXED_INFO *FixedInfo;
+    ULONG ulOutBufLen;
+    char *dns_server = NULL;
+
+    FixedInfo = (FIXED_INFO *) GlobalAlloc(GPTR, sizeof(FIXED_INFO));
+    ulOutBufLen = sizeof(FIXED_INFO);
+
+    if (GetNetworkParams(FixedInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW)
+    {
+        GlobalFree(FixedInfo);
+        FixedInfo = (FIXED_INFO *) GlobalAlloc(GPTR, ulOutBufLen);
+    }
+
+    if (GetNetworkParams(FixedInfo, &ulOutBufLen) != ERROR_SUCCESS)
+    {
+        GlobalFree(FixedInfo);
+        cli_errmsg("DNS Resolver: Call to GetNetworkParams() failed [Win95 or NT4]\n");
+        return NULL;
+    }
+
+
+/*
+    More than one dns server - we just use the primary
+    if (FixedInfo->DnsServerList.Next)
+    {
+        IP_ADDR_STRING *pIPAddr;
+        pIPAddr = FixedInfo->DnsServerList.Next;
+        while (pIPAddr)
+        {
+            cli_dbgmsg("DNS Resolver: Found additional DNS Server: %s\n", pIPAddr->IpAddress.String);
+            pIPAddr = pIPAddr->Next;
+        }
+    }
+*/
+
+    dns_server = strdup(FixedInfo->DnsServerList.IpAddress.String);
+    GlobalFree(FixedInfo);
+    return dns_server;
+}
+
+static char *do_query(struct hostent *he, const char *domain, uint32_t *ttl)
+{
+    struct sockaddr_in dns;
+    char *packet, *seek, *txtreply;
+    char reply[NS_PACKETSZ];
+    simple_dns_query query, *res;
+    int numbytes, addr_len, i;
+    int start, rev, len, off;
+    uint16_t tid = rand();
+    int sockfd = -1;
+
+    if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
+    {
+        cli_errmsg("DNS Resolver: socket() failed %d\n", WSAGetLastError());
+        return NULL;
+    }
+
+    memset(&dns, 0, sizeof(dns));
+    dns.sin_family = AF_INET;
+    dns.sin_port = htons(53);
+    dns.sin_addr = *((struct in_addr *) he->h_addr);
+
+    /* Generate the packet */
+    memset(&query, 0, sizeof(query));
+    query.transaction_id = htons(tid);
+    query.flags = htons(0x0100); /* Request + Recursion */
+    query.questions = htons(1); /* 1 query */
+
+    len = sizeof(query) + NS_INT8SZ + (int) strlen(domain) + NS_INT8SZ + (2 * sizeof(uint16_t)); /* \0 + Type + Class */
+    packet = (char *) cli_malloc(len);
+
+    memcpy(packet, &query, sizeof(query));
+    off = sizeof(query) + NS_INT8SZ;
+
+    start = 0;
+    off += (int) strlen(domain);
+    rev = start = off;
+
+    /* String-ize */
+    for (i = (int) strlen(domain); i >= 0; i--)
+    {
+        if (domain[i] != '.')
+            packet[rev] = domain[i];
+        else
+        {
+            packet[rev] = (uint8_t) (start - rev - 1);
+            start = rev;
+        }
+        rev--;
+    }
+
+    /* First string length */
+    packet[rev] = (uint8_t) (start - rev - 1);
+    packet[off++] = 0;
+
+    /* Type TXT */
+    SETUINT16(&packet[off], ns_t_txt);
+    off += sizeof(uint16_t);
+
+    /* Class */
+    SETUINT16(&packet[off], NS_INT8SZ);
+    off += sizeof(uint16_t);
+
+    if ((numbytes = sendto(sockfd, packet, (int) len, 0, (struct sockaddr *) &dns, sizeof(struct sockaddr))) == -1)
+    {
+        cli_errmsg("DNS Resolver: sendto() failed %d\n", WSAGetLastError());
+        free(packet);
+        return NULL;
+    }
+    free(packet);
+
+    addr_len = sizeof(struct sockaddr);
+    if ((numbytes = recvfrom(sockfd, reply, NS_PACKETSZ, 0, (struct sockaddr *) &dns, &addr_len)) == -1)
+    {
+        cli_errmsg("DNS Resolver: recvfrom() failed %d\n", WSAGetLastError());
+        return NULL;
+    }
+
+    cli_dbgmsg("DNS Resolver: received %d bytes from the DNS\n", numbytes);
+
+    if (numbytes <= sizeof(simple_dns_query))
+    {
+        cli_errmsg("DNS Resolver: Short Reply\n");
+        return NULL;
+    }
+
+    seek = reply;
+    res = (simple_dns_query *) seek;
+
+    /* All your replies are belong to us? */
+    if (ntohs(res->transaction_id) != tid)
+    {
+        cli_errmsg("DNS Resolver: Bad TID expected 0x%04x got 0x%04x\n", tid, ntohs(res->transaction_id));
+        return NULL;
+    }
+
+    /* Is a reply and result is ok */
+    if (!(ntohs(res->flags) >> 15) || (ntohs(res->flags) & 0x000f))
+    {
+        cli_errmsg("DNS Resolver: Bad Reply\n");
+        return NULL;
+    }
+
+    if (ntohs(res->ans_rrs) < 1)
+    {
+        cli_errmsg("DNS Resolver: No replies :(\n");
+        return NULL;
+    }
+
+    seek += sizeof(simple_dns_query) + NS_INT8SZ;
+    while (((seek - reply) < numbytes) && *seek) seek++; /* my request, don't care*/
+    seek++;
+
+    NEED(sizeof(uint16_t));
+    if (GETUINT16(seek) != ns_t_txt)
+    {
+        cli_errmsg("DNS Resolver: Dns query in reply is not TXT\n");
+        return NULL;
+    }
+    seek += sizeof(uint16_t);
+
+    NEED(sizeof(uint16_t));
+    if (GETUINT16(seek) != NS_INT8SZ)
+    {
+        cli_errmsg("DNS Resolver: Dns query in reply has a different Class\n");
+        return NULL;
+    }
+    seek += sizeof(uint16_t);
+    seek += sizeof(uint16_t); /* Answer c0 0c ?? - Wireshark says Name */
+
+    NEED(sizeof(uint16_t));
+    if (GETUINT16(seek) != ns_t_txt)
+    {
+        cli_dbgmsg("DNS Resolver: Dns reply Type is not TXT\n");
+        return NULL;
+    }
+    seek += sizeof(uint16_t);
+
+    NEED(sizeof(uint16_t));
+    if (GETUINT16(seek) != NS_INT8SZ)
+    {
+        cli_errmsg("DNS Resolver: Dns reply has a different Class\n");
+        return NULL;
+    }
+    seek += sizeof(uint16_t);
+
+    NEED(sizeof(uint32_t));
+    *ttl = GETUINT32(seek);
+    seek += sizeof(uint32_t);
+
+    NEED(sizeof(uint16_t));
+    len = GETUINT16(seek);
+
+    if (len > NS_PACKETSZ)
+    {
+        cli_errmsg("DNS Resolver: Oversized reply\n");
+        return NULL;
+    }
+    seek += sizeof(uint16_t); /* Len */
+
+    NEED(len);
+
+    seek++;
+    if (!*seek)
+    {
+        cli_errmsg("DNS Resolver: NULL txt reply, very weird\n");
+        return NULL;
+    }
+
+    txtreply = (char *) cli_malloc(len);
+    memcpy(txtreply, seek, len);
+    txtreply[len - 1] = 0;
+    return txtreply;
+}
+
+/* Bare Version */
+char *txtquery_compat(const char *domain, unsigned int *ttl)
+{
+    WSADATA wsaData;
+    struct hostent *he;
+    char *txt = NULL, *nameserver = NULL;
+    int i;
+
+    if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
+        return NULL;
+
+    if ((nameserver = get_dns()) == NULL)
+    {
+        cli_errmsg("DNS Resolver: Cannot found a dns server\n");
+        return NULL;
+    }
+
+    if ((he = gethostbyname(nameserver)) == NULL)
+    {
+        cli_errmsg("DNS Resolver: gethostbyname() on dns failed\n");
+        return NULL;
+    }
+
+    for (i = 0; i < N_RETRY; i++)
+    {
+        if ((txt = do_query(he, domain, ttl)) != NULL)
+            break;
+    }
+
+    WSACleanup();
+    if (nameserver) free(nameserver);
+    cli_dbgmsg("DNS Resolver - Query Done using compatibility Method\n");
+    cli_dbgmsg("DNS Resolver - Result : [%s]\n", txt);
+    return txt;
+}
+
+/* DNS API Version */
+typedef DNS_STATUS (WINAPI *fnDnsQuery)(
+    IN      PCSTR           pszName,
+    IN      WORD            wType,
+    IN      DWORD           Options,
+    IN      PIP4_ARRAY      aipServers      OPTIONAL,
+    IN OUT  PDNS_RECORD     *ppQueryResults OPTIONAL,
+    IN OUT  PVOID           *pReserved      OPTIONAL
+);
+
+typedef VOID (WINAPI *fnDnsRecordListFree)(
+    IN OUT  PDNS_RECORD     pRecordList,
+    IN      DNS_FREE_TYPE   FreeType
+);
+
+char *txtquery_dnsapi(const char *domain, unsigned int *ttl)
+{
+    PDNS_RECORD pRec = NULL, pRecOrig = NULL;
+    HMODULE hDnsApi = NULL;
+    fnDnsQuery pDnsQuery = NULL;
+    fnDnsRecordListFree pDnsRecordListFree = NULL;
+    char *txt = NULL;
+
+    if (!(hDnsApi = LoadLibraryA("dnsapi.dll")))
+    {
+        cli_errmsg("DNS Resolver: Cannot load dnsapi.dll: %d\n", GetLastError());
+        return txtquery_compat(domain, ttl);
+    }
+
+    if (!(pDnsQuery = (fnDnsQuery) GetProcAddress(hDnsApi, "DnsQuery_A")) ||
+        !(pDnsRecordListFree = (fnDnsRecordListFree) GetProcAddress(hDnsApi, "DnsRecordListFree")))
+    {
+        cli_errmsg("DNS Resolver: Cannot find needed exports in dnsapi.dll\n");
+        FreeLibrary(hDnsApi);
+        return txtquery_compat(domain, ttl);
+    }
+
+    if (pDnsQuery(domain, DNS_TYPE_TEXT, DNS_QUERY_STANDARD | DNS_QUERY_BYPASS_CACHE, NULL, &pRec, NULL) != ERROR_SUCCESS)
+    {
+        cli_errmsg("DNS Resolver: Can't query %s\n", domain);
+        FreeLibrary(hDnsApi);
+        return NULL;
+    }
+
+    pRecOrig = pRec;
+
+    while (pRec)
+    {
+        if ((pRec->wType == DNS_TYPE_TEXT) && pRec->wDataLength && pRec->Data.TXT.dwStringCount)
+        {
+            /* int len = DNS_TEXT_RECORD_LENGTH(pRec->Data.TXT.dwStringCount); */ /* returns 12 instead of 22? */
+            /* yes strlen is unsafe but win32 doesn't tell me the right length */
+            int len = strlen(pRec->Data.TXT.pStringArray[0]);
+            txt = (char *) cli_malloc(len + 1);
+            strncpy(txt, (char *) pRec->Data.TXT.pStringArray[0], len);
+            txt[len] = 0;
+            *ttl = pRec->dwTtl;
+            break;
+        }
+        pRec = pRec->pNext;
+    }
+    if (!txt) cli_errmsg("DNS Resolver: Broken DNS reply.\n");
+    pDnsRecordListFree(pRecOrig, DnsFreeRecordList);
+    FreeLibrary(hDnsApi);
+    cli_dbgmsg("DNS Resolver - Query Done using DnsApi Method\n");
+    cli_dbgmsg("DNS Resolver - Result : [%s]\n", txt);
+    return txt;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/exeScanner.c clamav-release/contrib/msvc/src/exeScanner.c
--- clamav-0.91.2/contrib/msvc/src/exeScanner.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/exeScanner.c	2007-07-12 12:36:19.437500000 +1000
@@ -0,0 +1,274 @@
+/*
+ * executable modules analyzer
+ *
+ * Copyright (c) 2006-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <exeScanner.h>
+
+sigs_t signatures[] =
+{
+    { { 0x60, 0xbe,   -1,   -1,   -1,   -1, 0x8d, 0xbe,   -1,   -1,   -1, 0xff, 0x57, 0x83, 0xcd, 0xff },  "UPX", 1 }, // Checked
+    { { 0x94, 0xbc, 0x5d, 0x07, 0x42, 0x00, 0xb9, 0x1d, 0x00, 0x00, 0x00, 0x80, 0x34, 0x0c, 0x44, 0xe2 },  "UPXSHiT", 1 },
+    { { 0xbe, 0xa4, 0x01, 0x40, 0x00, 0xad, 0x93, 0xad, 0x97, 0xad, 0x56, 0x96, 0xb2, 0x80, 0xa4, 0xb6 },  "FSG 1.33", 1 },
+    { { 0x4d, 0x5a,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00 },  "FSG 2.00", 1 },
+    { { 0x4d, 0x5a, 0x4b, 0x45, 0x52, 0x4e, 0x45, 0x4c, 0x33, 0x32, 0x2e, 0x44, 0x4c, 0x4c, 0x00, 0x00 },  "WinUpack 0.39", 1 },
+    { { 0xbe, 0x88, 0x01, 0x40, 0x00, 0xad, 0x8b, 0xf8, 0x95, 0xad, 0x91, 0xf3, 0xa5, 0xad, 0xb5, 0x1c },  "Upack 2.4/2.9", 1 },
+    { { 0xbe, 0x48, 0x01, 0x40, 0x00, 0xad, 0x8b, 0xf8, 0x95, 0xa5, 0x33, 0xc0, 0x33, 0xc9, 0xab, 0x48 },  "Upack 1.1/1.2", 1 }, // Could be merged
+    { { 0x83, 0xec, 0x20, 0x53, 0x55, 0x56, 0x33, 0xdb, 0x57, 0x89, 0x5c, 0x24, 0x18, 0xc7, 0x44, 0x24 },  "NullSoft PiMP", 1 },
+    { { 0xe9,   -1,   -1,   -1, 0xff, 0x0c,   -1,   -1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  "Mew 11 1.2", 1 },
+    { { 0x60, 0xe9, 0x3d, 0x04, 0x00, 0x00,   -2 },                                                        "ASPack 2.11", 1 },
+    { { 0x60, 0xe8, 0x03, 0x00, 0x00, 0x00, 0xe9, 0xeb, 0x04, 0x5d, 0x45, 0x55, 0xc3, 0xe8, 0x01, 0x00 },  "ASPack 2.12", 1 },
+    { { 0x55, 0x83, 0xc4, 0x04, 0x76, 0x08, 0x7a, 0x06, 0x74, 0x04, 0x66, 0x83, 0xea, 0x00, 0xf5, 0x50 },  "Morphine 1.4/2.7", 1 },
+    { { 0x56, 0x72, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x0b, 0xd2, 0xf9, 0x84, 0xdb, 0x68, 0x34 },  "Morphine 1.4/2.7 [2]", 1 },
+    { { 0x53, 0x51, 0x52, 0x56, 0x57, 0x55, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x8b, 0xd5, 0x81, 0xed },  "PEDiminisher 0.1", 1 },
+
+    { { 0xff, 0x25,   -1,   -1,   -1,   -1, 0xcc, 0xcc, 0x03, 0x30, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00 },  "DotNet", 0 },
+    { { 0x55, 0x89, 0xe5,   -2 },                                                                          "MinGW", 0 },
+    { 0, 0, 0}
+};
+
+int sigcmp(const uint8_t *data, const int16_t *sig, size_t n)
+{
+    uint8_t *d = (uint8_t *) data;
+    int16_t *s = (int16_t *) sig;
+    while (n-- != 0)
+    {
+        if (*s == -2) return 0;
+        if ((*s != -1) && (*d != *s))
+            return (*d < *s) ? -1 : +1;
+        d++;
+        s++;
+    }
+    return 0;
+}
+
+sigs_t *checksig(uint8_t *data)
+{
+    int i = 0;
+    while (signatures[i].name)
+    {
+        if (!sigcmp(data, signatures[i].sig, 16))
+            return &signatures[i];
+        i++;
+    }
+    return NULL;
+}
+
+double calc_entropy(const unsigned char *data, size_t size)
+{
+    double entropy = 0.0;
+    size_t p[256];
+    size_t c, i;
+
+    memset(p, 0, sizeof(p));
+
+    for (c = 0; c < size; c++)
+        p[data[c]]++;
+
+    for (i = 0; i < 256; i++)
+        if (p[i])
+            entropy -= ((double) p[i] / size) * log((double) p[i] / size);
+    return entropy;
+}
+
+#define FILLBYTES(dst) \
+    if (IsBadReadPtr(seek, sizeof(dst))) \
+    { \
+        cli_errmsg("exeScanner: Bad pointer!!!\n"); \
+        goto cleanup; \
+    } \
+    memcpy(&dst, seek, sizeof(dst));
+
+/* Packed exe heuristic detection, errors are handled as like of non packed data */
+int is_packed(const char *filename)
+{
+    int packed = 0;
+    int i = 0, c = 0;
+    int badsection = 0 , whitelist = 0;
+    double entropy = 0.0;
+    sigs_t *sig = NULL;
+    uint16_t e_mz;
+    uint32_t e_lfanew, e_magic;
+    uint32_t epoff = 0;
+    unsigned char *seek = NULL, *s_start = NULL, *ep = NULL, *lpMapAddress = NULL;
+    PIMAGE_FILE_HEADER pehdr;
+    PIMAGE_OPTIONAL_HEADER32 opthdr;
+    PIMAGE_SECTION_HEADER sechdr;
+    unsigned char secname[IMAGE_SIZEOF_SHORT_NAME];
+
+    HANDLE hFile = INVALID_HANDLE_VALUE, hMapFile = NULL;
+
+    hFile = CreateFileA(filename, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+
+    if (hFile == INVALID_HANDLE_VALUE)
+    {
+        cli_dbgmsg("exeScanner: CreateFileA failed %d\n", GetLastError());
+        return packed; /* Returning packed, the module is loaded so it must exists on disk */
+    }
+
+    hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, "exeScanner");
+    if (!hMapFile)
+    {
+        cli_dbgmsg("exeScanner: CreateFileMappingA() failed %d\n", GetLastError());
+        goto cleanup;
+    }
+
+    lpMapAddress = (LPBYTE) MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
+    if (!lpMapAddress)
+    {
+        cli_dbgmsg("exeScanner: MapViewOfFile() failed %d\n", GetLastError());
+        goto cleanup;
+    }
+
+    seek = lpMapAddress;
+
+    /* DOS Signature 'MZ' */
+    FILLBYTES(e_mz);
+    if (e_mz != IMAGE_DOS_SIGNATURE)
+    {
+        cli_dbgmsg("exeScanner: DOS Signature not found\n");
+        goto cleanup;
+    }
+
+    seek += 0x3c;
+
+    FILLBYTES(e_lfanew);
+    if (!e_lfanew)
+    {
+        cli_dbgmsg("exeScanner: Invalid PE offset\n");
+        goto cleanup;
+    }
+    seek = lpMapAddress + e_lfanew;
+
+    /* PE Signature 'PE' */
+    FILLBYTES(e_magic);
+    if (e_magic != IMAGE_NT_SIGNATURE)
+    {
+        cli_dbgmsg("exeScanner: PE Signature not found\n");
+        goto cleanup;
+    }
+    seek += sizeof(e_magic);
+
+    if (IsBadReadPtr(seek, sizeof(IMAGE_FILE_HEADER))) goto cleanup;
+    pehdr = (PIMAGE_FILE_HEADER) seek;
+    seek += sizeof(IMAGE_FILE_HEADER);
+
+    if (IsBadReadPtr(seek, sizeof(IMAGE_OPTIONAL_HEADER32))) goto cleanup;
+    opthdr = (PIMAGE_OPTIONAL_HEADER32) seek;
+    seek += sizeof(IMAGE_OPTIONAL_HEADER32);
+
+    /* Invalid sections number */
+    if ((pehdr->NumberOfSections < 1) || (pehdr->NumberOfSections > 32))
+    {
+        cli_dbgmsg("exeScanner: Invalid sections number\n");
+        packed = 1;
+        goto cleanup;
+    }
+
+    for (i = 0; i < pehdr->NumberOfSections; i++)
+    {
+        double section_entropy = 0.0;
+        if (IsBadReadPtr(seek, sizeof(IMAGE_SECTION_HEADER))) goto cleanup;
+        sechdr = (PIMAGE_SECTION_HEADER) seek;
+        seek += sizeof(IMAGE_SECTION_HEADER);
+
+        if (opthdr->AddressOfEntryPoint >= sechdr->VirtualAddress)
+            epoff = opthdr->AddressOfEntryPoint - sechdr->VirtualAddress + sechdr->PointerToRawData;
+
+        s_start = lpMapAddress + sechdr->PointerToRawData;
+        if (!IsBadReadPtr(s_start, sechdr->SizeOfRawData))
+            section_entropy = calc_entropy(s_start, sechdr->SizeOfRawData);
+
+        entropy = MAX(entropy, section_entropy);
+
+        /* Sanitize the section name */
+        memcpy(secname, sechdr->Name, IMAGE_SIZEOF_SHORT_NAME);
+        for (c = 0; (c < IMAGE_SIZEOF_SHORT_NAME) && secname[c]; c++)
+            if (!isprint(secname[c])) secname[c] = '?';
+        secname[IMAGE_SIZEOF_SHORT_NAME - 1] = 0;
+
+        cli_dbgmsg("exeScanner: Section name: [%s] - Entropy %f\n", secname, section_entropy);
+
+        if (!sechdr->SizeOfRawData)
+            badsection = 1;
+    }
+
+    cli_dbgmsg("exeScanner: Max entropy = %f\n", entropy);
+    /* EP Check */
+    cli_dbgmsg("exeScanner: Entry Point rva: 0x%x - raw: 0x%x\n", opthdr->AddressOfEntryPoint, epoff);
+
+    ep = lpMapAddress + epoff;
+    if (!IsBadReadPtr(ep, EP_SIGNATURE_SIZE))
+    {
+#ifdef DUMP_SIGNATURE
+        int i;
+        for (i = 0; i < EP_SIGNATURE_SIZE; i++)
+            cli_dbgmsg("%02x ", ep[i]);
+        cli_dbgmsg("\n");
+#endif
+        if ((sig = checksig(ep)))
+        {
+            cli_dbgmsg("exeScanner: Signature check: %s\n", sig->name);
+            if (sig->packed) packed = 1;
+            else whitelist = 1;
+        }
+        else
+            cli_dbgmsg("exeScanner: Signature check: Nothing found\n");
+    }
+    else
+        cli_dbgmsg("exeScanner: Invalid address of Entry Point\n");
+
+    if (badsection)
+    {
+        if (whitelist)
+        {
+            entropy -= 1.0;
+            cli_dbgmsg("exeScanner: Whitelisted signature found lowering entropy to %f\n", entropy);
+        }
+
+        if ((entropy == 0.0) || (entropy > ENTROPY_THRESHOLD))
+        {
+            cli_dbgmsg("exeScanner: found zero SizeOfRawData and entropy %f\n", entropy);
+            packed = 1;
+            goto cleanup;
+        }
+    }
+
+    /* Empty IAT - it needs some additional checks first since is not 100% correct
+       examples:
+        - ntdll.dll and kernel mode stuff - need to check some of pe headers
+        - resources only dll - partially fixed by entropy calculation, can be improved
+        - dotnet code - whitelisted by signature match
+        - mingw executables - whitelisted by signature match
+    */
+
+    if (!(opthdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size || opthdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress))
+    {
+        if ((entropy == 0.0) || (entropy > ENTROPY_THRESHOLD))
+        {
+            cli_dbgmsg("exeScanner: Empty IAT and entropy is %f\n", entropy);
+            packed = 1;
+        }
+    }
+
+cleanup:
+    if (lpMapAddress) UnmapViewOfFile(lpMapAddress);
+    if (hMapFile) CloseHandle(hMapFile);
+    CloseHandle(hFile);
+    return packed;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/flock.c clamav-release/contrib/msvc/src/flock.c
--- clamav-0.91.2/contrib/msvc/src/flock.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/flock.c	2007-07-12 12:36:19.390625000 +1000
@@ -0,0 +1,109 @@
+/* Copyright (C) 1991, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this software; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include <clamav-config.h>
+#include <flock.h>
+
+int lock(int fd, int cmd, struct flock *fl)
+{
+    uint64_t fstart, fend;
+    HANDLE hFile = (HANDLE) _get_osfhandle (fd);
+    int res;
+
+    fstart = _lseek(fd, 0, fl->l_whence) + fl->l_start;
+    fend = fstart + fl->l_len;
+    switch (cmd)
+    {
+        case F_GETLK:       /* Get record locking information */
+            errno = ENOSYS;
+            return -1;
+        case F_SETLK:       /* Set record locking information */
+        case F_SETLKW:      /* Set record locking information; wait if blocked */
+            switch (fl->l_type)
+            {
+                    case F_RDLCK:       /* Shared or read lock */
+                    case F_WRLCK:       /* Exclusive or write lock */
+                        /* res = LockFile(hFile, LODWORD(fstart), HIDWORD(fstart), LODWORD(fend), HIDWORD(fend)); */
+                        res = LockFile(hFile, 1024, 0, 1024, 0);
+                        break;
+                    case F_UNLCK:       /* Unlock */
+                        res = UnlockFile(hFile, LODWORD(fstart), HIDWORD(fstart), LODWORD(fend), HIDWORD(fend));
+                        break;
+                    default:
+                        errno = EINVAL;
+                        return -1;
+            }
+            if (res) return 0;
+            else return 0;
+            break;
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+    return 0;
+}
+
+static int do_fcntl(int fd, int cmd, void *arg)
+{
+    switch (cmd)
+    {
+        case F_DUPFD:       /* Duplicate file descriptor */
+            return _dup(fd);
+        case F_GETFD:
+        case F_SETFD:
+        case F_GETFL:       /* Get file status flags and file access modes */
+            errno = EINVAL;
+            return -1;
+        case F_SETFL:       /* Set file status flags */
+            break;
+        case F_GETLK:       /* Get record locking information */
+            break;
+        case F_SETLK:       /* Set record locking information */
+        case F_SETLKW:
+        {
+            /* Set record locking information; wait if blocked */
+            struct flock *fl = arg;
+            return lock(fd, cmd, fl);
+        }
+        case F_GETOWN:      /* Get process or process group ID to receive SIGURG signals */
+        case F_SETOWN:      /* Set process or process group ID to receive SIGURG signals */
+            break;
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+    errno = ENOSYS;
+    return -1;
+}
+
+/* Perform file control operations on FD */
+int fcntl(int fd, int cmd, ...)
+{
+    va_list ap;
+    void *arg;
+
+    va_start (ap, cmd);
+    arg = va_arg (ap, void *);
+    va_end (ap);
+
+    if (fd < 0)
+    {
+        errno = EBADF;
+        return -1;
+    }
+    return do_fcntl(fd, cmd, arg);
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/getpass.c clamav-release/contrib/msvc/src/getpass.c
--- clamav-0.91.2/contrib/msvc/src/getpass.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/getpass.c	2007-07-12 12:36:19.421875000 +1000
@@ -0,0 +1,79 @@
+/*
+ * Clamav Native Windows Port: getpass win32 compatibility function
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/* getpass() native win32 by Kees Zeelenberg <kzlg@users.sourceforge.net> : part of LibGW32C */
+
+#include <windows.h>
+
+/* Avoid buffer overflow in caller routine:
+   smbuff (user) - 30
+   "ClamSign:::" - 11
+   cmd is 100
+   so we have 100 - 30 - 11 - 1 = 58 max bytes to fill
+   better remain on 32, I think enough for a password */
+
+#define MAX_STRING_LEN 32
+
+char *getpass(const char *prompt)
+{
+    static char input[MAX_STRING_LEN];
+    HANDLE in;
+    HANDLE err;
+    DWORD count;
+
+    in = GetStdHandle(STD_INPUT_HANDLE);
+    err = GetStdHandle(STD_ERROR_HANDLE);
+
+    if (in == INVALID_HANDLE_VALUE || err == INVALID_HANDLE_VALUE)
+        return NULL;
+
+    if (WriteFile(err, prompt, (DWORD) strlen(prompt), &count, NULL))
+    {
+        int istty = (GetFileType(in) == FILE_TYPE_CHAR);
+        DWORD old_flags;
+        int rc;
+
+        if (istty)
+        {
+            if (GetConsoleMode(in, &old_flags))
+                SetConsoleMode(in, ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT);
+            else
+                istty = 0;
+        }
+
+        rc = ReadFile(in, input, sizeof (input), &count, NULL);
+
+        if (count >= 2 && input[count - 2] == '\r')
+            input[count - 2] = '\0';
+        else
+        {
+            char buf[MAX_STRING_LEN];
+            while (ReadFile(in, buf, sizeof(buf), &count, NULL) > 0)
+                if (count >= 2 && buf[count - 2] == '\r')
+                    break;
+        }
+        WriteFile(err, "\r\n", 2, &count, NULL);
+        if (istty)
+            SetConsoleMode(in, old_flags);
+        if (rc)
+            return input;
+    }
+    return NULL;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/gettimeofday.c clamav-release/contrib/msvc/src/gettimeofday.c
--- clamav-0.91.2/contrib/msvc/src/gettimeofday.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/gettimeofday.c	2007-07-12 12:36:19.406250000 +1000
@@ -0,0 +1,34 @@
+/*
+ * Clamav Native Windows Port: gettimeofday for win32
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef HAVE_GETTIMEOFDAY
+#include <sys/time.h>
+#include <sys/timeb.h>
+#include <winsock2.h>
+
+int gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+    struct timeb timebuffer;
+    ftime(&timebuffer);
+    tv->tv_sec = (long) timebuffer.time;
+    tv->tv_usec = 1000 * timebuffer.millitm;
+    return 0;
+}
+#endif
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/mkstemp.c clamav-release/contrib/msvc/src/mkstemp.c
--- clamav-0.91.2/contrib/msvc/src/mkstemp.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/mkstemp.c	2007-07-12 12:36:19.406250000 +1000
@@ -0,0 +1,86 @@
+/* Copyright (C) 1991, 1992, 1996, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this software; if not, write to the
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include <clamav-config.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <stdio.h>
+#include <time.h>
+
+/* Generate a unique temporary file name from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the filename unique.
+   Returns a file descriptor open on the file for reading and writing.  */
+int mkstemp(char *tmpl)
+{
+    static const char letters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
+    size_t len;
+    size_t i;
+    char *xs;
+    static uint64_t value;
+    unsigned int count;
+    int fd = -1;
+
+    /* A lower bound on the number of temporary files to attempt to
+       generate.  The maximum total number of temporary file names that
+       can exist for a given template is 62**6.  It should never be
+       necessary to try all these combinations.  Instead if a reasonable
+       number of names is tried (we define reasonable as 62**3) fail to
+       give the system administrator the chance to remove the problems.  */
+    unsigned int attempts_min = 62 * 62 * 62;
+
+    /* The number of times to attempt to generate a temporary file.  To
+       conform to POSIX, this must be no smaller than TMP_MAX.  */
+    unsigned int attempts = attempts_min < TMP_MAX ? TMP_MAX : attempts_min;
+
+    len = strlen(tmpl);
+    if (len < 6 || strcmp(&tmpl[len - 6], "XXXXXX"))
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    xs = &tmpl[len - 6];
+    value += time(NULL) ^ getpid();
+
+    for (count = 0; count < attempts; value += 7777, ++count)
+    {
+        uint64_t v = value;
+
+        /* Fill in the random bits.  */
+        xs[0] = letters[v % 62];
+        v /= 62;
+        xs[1] = letters[v % 62];
+        v /= 62;
+        xs[2] = letters[v % 62];
+        v /= 62;
+        xs[3] = letters[v % 62];
+        v /= 62;
+        xs[4] = letters[v % 62];
+        v /= 62;
+        xs[5] = letters[v % 62];
+
+        fd = open(tmpl, O_RDWR|O_BINARY|O_CREAT|O_EXCL, 0600);
+        if (fd >= 0) return fd;
+    }
+
+    /* We return the null string if we can't find a unique file name.  */
+    tmpl[0] = '\0';
+    return -1;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/mmap.c clamav-release/contrib/msvc/src/mmap.c
--- clamav-0.91.2/contrib/msvc/src/mmap.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/mmap.c	2007-07-12 12:36:19.421875000 +1000
@@ -0,0 +1,92 @@
+/*
+ * Clamav Native Windows Port : mmap win32 compatibility layer
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/* Parts of this file by by Kees Zeelenberg <kzlg@users.sourceforge.net> (LibGW32C) */
+
+#include <clamav-config.h>
+#include <sys/mman.h>
+
+void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)
+{
+    void *map = NULL;
+    HANDLE handle = INVALID_HANDLE_VALUE;
+    DWORD cfm_flags = 0, mvf_flags = 0;
+    uint64_t rlen = (uint64_t) len;
+    uint64_t roffset = (uint64_t) offset;
+
+    switch (prot)
+    {
+        case PROT_READ | PROT_WRITE | PROT_EXEC:
+        case PROT_WRITE | PROT_EXEC:
+            cfm_flags = PAGE_EXECUTE_READWRITE;
+            mvf_flags = FILE_MAP_ALL_ACCESS;
+            break;
+        case PROT_READ | PROT_WRITE:
+            cfm_flags = PAGE_READWRITE;
+            mvf_flags = FILE_MAP_ALL_ACCESS;
+            break;
+        case PROT_WRITE:
+            cfm_flags = PAGE_READWRITE;
+            mvf_flags = FILE_MAP_WRITE;
+            break;
+        case PROT_READ:
+            cfm_flags = PAGE_READONLY;
+            mvf_flags = FILE_MAP_READ;
+            break;
+        case PROT_NONE:
+            cfm_flags = PAGE_NOACCESS;
+            mvf_flags = FILE_MAP_READ;
+            break;
+        case PROT_EXEC:
+            cfm_flags = PAGE_EXECUTE;
+            mvf_flags = FILE_MAP_READ;
+            break;
+    }
+
+    if (flags & MAP_PRIVATE)
+    {
+        if (isWin9x()) cfm_flags = PAGE_WRITECOPY;
+        mvf_flags = FILE_MAP_COPY;
+    }
+
+    handle = CreateFileMappingA((HANDLE) _get_osfhandle(fd), NULL, cfm_flags, HIDWORD(rlen), LODWORD(rlen), NULL);
+    if (!handle)
+    {
+        errno = EBADF;
+        return MAP_FAILED;
+    }
+
+    map = MapViewOfFile(handle, mvf_flags, HIDWORD(offset), LODWORD(offset), len);
+    CloseHandle(handle);
+
+    if (!map)
+    {
+        errno = EINVAL;
+        return MAP_FAILED;
+    }
+
+    return map;
+}
+
+int munmap(void *addr, size_t len)
+{
+    if (!UnmapViewOfFile((LPCVOID) addr)) return -1;
+    return 0;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/platform.c clamav-release/contrib/msvc/src/platform.c
--- clamav-0.91.2/contrib/msvc/src/platform.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/platform.c	2007-07-12 12:36:19.406250000 +1000
@@ -0,0 +1,105 @@
+/*
+ * Clamav Native Windows Port
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <osdeps.h>
+
+#define DATADIRBASEKEY  "Software\\ClamAV"
+
+static char datadir[MAX_PATH] = { 0 };
+static char confdir[MAX_PATH] = { 0 };
+static char clamdconfig[MAX_PATH] = { 0 };
+static char freshclamconfig[MAX_PATH] = { 0 };
+
+const char *unc_prefix(const char *filename)
+{
+    if (PATH_ISUNC(filename) || PATH_ISNET(filename) || isWin9x())
+        return "";
+    else
+        return UNC_PREFIX;
+}
+
+void GetRegistryValue(char *key, char *path, char *default_value)
+{
+    HKEY hKey = NULL;
+    DWORD dwType = 0;
+    char data[MAX_PATH];
+    int datalen = sizeof(data);
+
+    path[0] = 0;
+    strncat(path, default_value, MAX_PATH);
+
+    /* First look in HKCU then in HKLM */
+    if (RegOpenKey(HKEY_CURRENT_USER, DATADIRBASEKEY, &hKey) != ERROR_SUCCESS)
+        if (RegOpenKey(HKEY_LOCAL_MACHINE, DATADIRBASEKEY, &hKey) != ERROR_SUCCESS)
+            return;
+
+    if ((RegQueryValueEx(hKey, key, NULL, &dwType, data, &datalen) == ERROR_SUCCESS) &&
+        datalen && ((dwType == REG_SZ) || dwType == REG_EXPAND_SZ))
+    {
+        path[0] = 0;
+        ExpandEnvironmentStrings(data, path, MAX_PATH);
+    }
+    RegCloseKey(hKey);
+}
+
+/* These functions can be thread unsafe, anyway I don't think multiple thread will
+ * call them at once */
+
+/* Picks data dir from the Windows Registry */
+const char *GetDataDir(void)
+{
+    const char *dir = NULL;
+    if (!datadir[0])
+    {
+        dir = getenv("CLAMAV_DATADIR");
+        if (dir) strncat(datadir, dir, MAX_PATH);
+        else GetRegistryValue("DataDir", datadir, DATADIR);
+    }
+    return datadir;
+}
+
+/* Picks config dir from the Windows Registry */
+const char *GetConfigDir(void)
+{
+    const char *conf = NULL;
+    if (!confdir[0])
+    {
+        conf = getenv("CLAMAV_CONFDIR");
+        if (conf) strncat(confdir, conf, MAX_PATH);
+        else GetRegistryValue("ConfigDir", confdir, CONFDIR);
+    }
+    return confdir;
+}
+
+/* Yes it's dirty and tricky but with the clamav code I don't known a better
+ * way to do it without memory leaks */
+const char *GetClamdConfig(void)
+{
+   if (!clamdconfig[0])
+        snprintf(clamdconfig, sizeof(clamdconfig), "%s\\%s", GetConfigDir(), "clamd.conf");
+   return clamdconfig;
+}
+
+const char *GetFreshClamConfig(void)
+{
+    if (!freshclamconfig[0])
+        snprintf(freshclamconfig, sizeof(freshclamconfig), "%s\\%s", GetConfigDir(), "freshclam.conf");
+    return freshclamconfig;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/regex.c clamav-release/contrib/msvc/src/regex.c
--- clamav-0.91.2/contrib/msvc/src/regex.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/regex.c	2007-07-12 12:36:19.437500000 +1000
@@ -0,0 +1,4883 @@
+/* Extended regular expression matching and search library,
+   version 0.12.
+   (Implements POSIX draft P10003.2/D11.2, except for
+   internationalization features.)
+
+   Copyright (C) 1993 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+/* AIX requires this to be the first thing in the file. */
+#if defined (_AIX) && !defined (REGEX_MALLOC)
+  #pragma alloca
+#endif
+
+#define _GNU_SOURCE
+
+/* We need this for `regex.h', and perhaps for the Emacs include files.  */
+#include <sys/types.h>
+
+#ifdef HAVE_CONFIG_H
+#include "clamav-config.h"
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4047 4312)
+#endif
+
+/* The `emacs' switch turns on certain matching commands
+   that make sense only in Emacs. */
+#ifdef emacs
+
+#include "lisp.h"
+#include "buffer.h"
+#include "syntax.h"
+
+/* Emacs uses `NULL' as a predicate.  */
+#undef NULL
+
+#else  /* not emacs */
+
+/* We used to test for `BSTRING' here, but only GCC and Emacs define
+   `BSTRING', as far as I know, and neither of them use this code.  */
+#if HAVE_STRING_H || STDC_HEADERS
+#include <string.h>
+#ifndef bcmp
+#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
+#endif
+#ifndef bcopy
+#define bcopy(s, d, n)	memcpy ((d), (s), (n))
+#endif
+#ifndef bzero
+#define bzero(s, n)	memset ((s), 0, (n))
+#endif
+#else
+#include <strings.h>
+#endif
+
+#ifdef STDC_HEADERS
+#include <stdlib.h>
+#else
+char *malloc ();
+char *realloc ();
+#endif
+
+
+/* Define the syntax stuff for \<, \>, etc.  */
+
+/* This must be nonzero for the wordchar and notwordchar pattern
+   commands in re_match_2.  */
+#ifndef Sword
+#define Sword 1
+#endif
+
+#ifdef SYNTAX_TABLE
+
+extern char *re_syntax_table;
+
+#else /* not SYNTAX_TABLE */
+
+/* How many characters in the character set.  */
+#define CHAR_SET_SIZE 256
+
+static char re_syntax_table[CHAR_SET_SIZE];
+
+static void init_syntax_once(void)
+{
+   register int c;
+   static int done = 0;
+
+   if (done)
+     return;
+
+   bzero (re_syntax_table, sizeof re_syntax_table);
+
+   for (c = 'a'; c <= 'z'; c++)
+     re_syntax_table[c] = Sword;
+
+   for (c = 'A'; c <= 'Z'; c++)
+     re_syntax_table[c] = Sword;
+
+   for (c = '0'; c <= '9'; c++)
+     re_syntax_table[c] = Sword;
+
+   re_syntax_table['_'] = Sword;
+
+   done = 1;
+}
+
+#endif /* not SYNTAX_TABLE */
+
+#define SYNTAX(c) re_syntax_table[c]
+
+#endif /* not emacs */
+
+/* Get the interface, including the syntax bits.  */
+#include "regex.h"
+
+/* isalpha etc. are used for the character classes.  */
+#include <ctype.h>
+
+#ifndef isascii
+#define isascii(c) 1
+#endif
+
+#ifdef isblank
+#define ISBLANK(c) (isascii (c) && isblank (c))
+#else
+#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+#endif
+#ifdef isgraph
+#define ISGRAPH(c) (isascii (c) && isgraph (c))
+#else
+#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
+#endif
+
+#define ISPRINT(c) (isascii (c) && isprint (c))
+#define ISDIGIT(c) (isascii (c) && isdigit (c))
+#define ISALNUM(c) (isascii (c) && isalnum (c))
+#define ISALPHA(c) (isascii (c) && isalpha (c))
+#define ISCNTRL(c) (isascii (c) && iscntrl (c))
+#define ISLOWER(c) (isascii (c) && islower (c))
+#define ISPUNCT(c) (isascii (c) && ispunct (c))
+#define ISSPACE(c) (isascii (c) && isspace (c))
+#define ISUPPER(c) (isascii (c) && isupper (c))
+#define ISXDIGIT(c) (isascii (c) && isxdigit (c))
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/* We remove any previous definition of `SIGN_EXTEND_CHAR',
+   since ours (we hope) works properly with all combinations of
+   machines, compilers, `char' and `unsigned char' argument types.
+   (Per Bothner suggested the basic approach.)  */
+#undef SIGN_EXTEND_CHAR
+#if __STDC__
+#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
+#else  /* not __STDC__ */
+/* As in Harbison and Steele.  */
+#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
+#endif
+
+/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
+   use `alloca' instead of `malloc'.  This is because using malloc in
+   re_search* or re_match* could cause memory leaks when C-g is used in
+   Emacs; also, malloc is slower and causes storage fragmentation.  On
+   the other hand, malloc is more portable, and easier to debug.
+
+   Because we sometimes use alloca, some routines have to be macros,
+   not functions -- `alloca'-allocated space disappears at the end of the
+   function it is called in.  */
+
+#ifdef REGEX_MALLOC
+
+#define REGEX_ALLOCATE malloc
+#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
+
+#else /* not REGEX_MALLOC  */
+
+/* Emacs already defines alloca, sometimes.  */
+#ifndef alloca
+
+/* Make alloca work the best possible way.  */
+#ifdef _WIN32
+#include <malloc.h>
+#else
+#ifdef __GNUC__
+#define alloca __builtin_alloca
+#else /* not __GNUC__ */
+#if HAVE_ALLOCA_H
+#include <alloca.h>
+#else /* not __GNUC__ or HAVE_ALLOCA_H */
+#ifndef _AIX /* Already did AIX, up at the top.  */
+char *alloca ();
+#endif /* not _AIX */
+#endif /* not HAVE_ALLOCA_H */
+#endif /* not __GNUC__ */
+
+#endif /* not alloca */
+#endif /* _WIN32 */
+
+#define REGEX_ALLOCATE alloca
+
+/* Assumes a `char *destination' variable.  */
+#define REGEX_REALLOCATE(source, osize, nsize)				\
+  (destination = (char *) alloca (nsize),				\
+   bcopy (source, destination, osize),					\
+   destination)
+
+#endif /* not REGEX_MALLOC */
+
+
+/* True if `size1' is non-NULL and PTR is pointing anywhere inside
+   `string1' or just past its end.  This works if PTR is NULL, which is
+   a good thing.  */
+#define FIRST_STRING_P(ptr) 					\
+  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
+
+/* (Re)Allocate N items of type T using malloc, or fail.  */
+#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
+#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
+#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
+
+#define BYTEWIDTH 8 /* In bits.  */
+
+#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
+
+#ifndef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+typedef char boolean;
+#define false 0
+#define true 1
+
+/* These are the command codes that appear in compiled regular
+   expressions.  Some opcodes are followed by argument bytes.  A
+   command code can specify any interpretation whatsoever for its
+   arguments.  Zero bytes may appear in the compiled regular expression.
+
+   The value of `exactn' is needed in search.c (search_buffer) in Emacs.
+   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
+   `exactn' we use here must also be 1.  */
+
+typedef enum
+{
+  no_op = 0,
+
+        /* Followed by one byte giving n, then by n literal bytes.  */
+  exactn = 1,
+
+        /* Matches any (more or less) character.  */
+  anychar,
+
+        /* Matches any one char belonging to specified set.  First
+           following byte is number of bitmap bytes.  Then come bytes
+           for a bitmap saying which chars are in.  Bits in each byte
+           are ordered low-bit-first.  A character is in the set if its
+           bit is 1.  A character too large to have a bit in the map is
+           automatically not in the set.  */
+  charset,
+
+        /* Same parameters as charset, but match any character that is
+           not one of those specified.  */
+  charset_not,
+
+        /* Start remembering the text that is matched, for storing in a
+           register.  Followed by one byte with the register number, in
+           the range 0 to one less than the pattern buffer's re_nsub
+           field.  Then followed by one byte with the number of groups
+           inner to this one.  (This last has to be part of the
+           start_memory only because we need it in the on_failure_jump
+           of re_match_2.)  */
+  start_memory,
+
+        /* Stop remembering the text that is matched and store it in a
+           memory register.  Followed by one byte with the register
+           number, in the range 0 to one less than `re_nsub' in the
+           pattern buffer, and one byte with the number of inner groups,
+           just like `start_memory'.  (We need the number of inner
+           groups here because we don't have any easy way of finding the
+           corresponding start_memory when we're at a stop_memory.)  */
+  stop_memory,
+
+        /* Match a duplicate of something remembered. Followed by one
+           byte containing the register number.  */
+  duplicate,
+
+        /* Fail unless at beginning of line.  */
+  begline,
+
+        /* Fail unless at end of line.  */
+  endline,
+
+        /* Succeeds if at beginning of buffer (if emacs) or at beginning
+           of string to be matched (if not).  */
+  begbuf,
+
+        /* Analogously, for end of buffer/string.  */
+  endbuf,
+
+        /* Followed by two byte relative address to which to jump.  */
+  jump,
+
+	/* Same as jump, but marks the end of an alternative.  */
+  jump_past_alt,
+
+        /* Followed by two-byte relative address of place to resume at
+           in case of failure.  */
+  on_failure_jump,
+
+        /* Like on_failure_jump, but pushes a placeholder instead of the
+           current string position when executed.  */
+  on_failure_keep_string_jump,
+
+        /* Throw away latest failure point and then jump to following
+           two-byte relative address.  */
+  pop_failure_jump,
+
+        /* Change to pop_failure_jump if know won't have to backtrack to
+           match; otherwise change to jump.  This is used to jump
+           back to the beginning of a repeat.  If what follows this jump
+           clearly won't match what the repeat does, such that we can be
+           sure that there is no use backtracking out of repetitions
+           already matched, then we change it to a pop_failure_jump.
+           Followed by two-byte address.  */
+  maybe_pop_jump,
+
+        /* Jump to following two-byte address, and push a dummy failure
+           point. This failure point will be thrown away if an attempt
+           is made to use it for a failure.  A `+' construct makes this
+           before the first repeat.  Also used as an intermediary kind
+           of jump when compiling an alternative.  */
+  dummy_failure_jump,
+
+	/* Push a dummy failure point and continue.  Used at the end of
+	   alternatives.  */
+  push_dummy_failure,
+
+        /* Followed by two-byte relative address and two-byte number n.
+           After matching N times, jump to the address upon failure.  */
+  succeed_n,
+
+        /* Followed by two-byte relative address, and two-byte number n.
+           Jump to the address N times, then fail.  */
+  jump_n,
+
+        /* Set the following two-byte relative address to the
+           subsequent two-byte number.  The address *includes* the two
+           bytes of number.  */
+  set_number_at,
+
+  wordchar,	/* Matches any word-constituent character.  */
+  notwordchar,	/* Matches any char that is not a word-constituent.  */
+
+  wordbeg,	/* Succeeds if at word beginning.  */
+  wordend,	/* Succeeds if at word end.  */
+
+  wordbound,	/* Succeeds if at a word boundary.  */
+  notwordbound	/* Succeeds if not at a word boundary.  */
+
+#ifdef emacs
+  ,before_dot,	/* Succeeds if before point.  */
+  at_dot,	/* Succeeds if at point.  */
+  after_dot,	/* Succeeds if after point.  */
+
+	/* Matches any character whose syntax is specified.  Followed by
+           a byte which contains a syntax code, e.g., Sword.  */
+  syntaxspec,
+
+	/* Matches any character whose syntax is not that specified.  */
+  notsyntaxspec
+#endif /* emacs */
+} re_opcode_t;
+
+/* Common operations on the compiled pattern.  */
+
+/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
+
+#define STORE_NUMBER(destination, number)				\
+  do {									\
+    (destination)[0] = (number) & 0377;					\
+    (destination)[1] = (number) >> 8;					\
+  } while (0)
+
+/* Same as STORE_NUMBER, except increment DESTINATION to
+   the byte after where the number is stored.  Therefore, DESTINATION
+   must be an lvalue.  */
+
+#define STORE_NUMBER_AND_INCR(destination, number)			\
+  do {									\
+    STORE_NUMBER (destination, number);					\
+    (destination) += 2;							\
+  } while (0)
+
+/* Put into DESTINATION a number stored in two contiguous bytes starting
+   at SOURCE.  */
+
+#define EXTRACT_NUMBER(destination, source)				\
+  do {									\
+    (destination) = *(source) & 0377;					\
+    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
+  } while (0)
+
+#ifdef DEBUG
+static void extract_number (int *dest, unsigned char *source)
+{
+  int temp = SIGN_EXTEND_CHAR (*(source + 1));
+  *dest = *source & 0377;
+  *dest += temp << 8;
+}
+
+#ifndef EXTRACT_MACROS /* To debug the macros.  */
+#undef EXTRACT_NUMBER
+#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
+#endif /* not EXTRACT_MACROS */
+
+#endif /* DEBUG */
+
+/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
+   SOURCE must be an lvalue.  */
+
+#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
+  do {									\
+    EXTRACT_NUMBER (destination, source);				\
+    (source) += 2; 							\
+  } while (0)
+
+#ifdef DEBUG
+static void extract_number_and_incr(int *destination, unsigned char **source)
+{
+  extract_number (destination, *source);
+  *source += 2;
+}
+
+#ifndef EXTRACT_MACROS
+#undef EXTRACT_NUMBER_AND_INCR
+#define EXTRACT_NUMBER_AND_INCR(dest, src) \
+  extract_number_and_incr (&dest, &src)
+#endif /* not EXTRACT_MACROS */
+
+#endif /* DEBUG */
+
+/* If DEBUG is defined, Regex prints many voluminous messages about what
+   it is doing (if the variable `debug' is nonzero).  If linked with the
+   main program in `iregex.c', you can enter patterns and strings
+   interactively.  And if linked with the main program in `main.c' and
+   the other test files, you can run the already-written tests.  */
+
+#ifdef DEBUG
+
+/* We use standard I/O for debugging.  */
+#include <stdio.h>
+
+/* It is useful to test things that ``must'' be true when debugging.  */
+#include <assert.h>
+
+static int debug = 0;
+
+#define DEBUG_STATEMENT(e) e
+#define DEBUG_PRINT1(x) if (debug) printf (x)
+#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
+#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
+#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
+#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
+  if (debug) print_partial_compiled_pattern (s, e)
+#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
+  if (debug) print_double_string (w, s1, sz1, s2, sz2)
+
+
+extern void printchar ();
+
+/* Print the fastmap in human-readable form.  */
+
+void print_fastmap(char *fastmap)
+{
+  unsigned was_a_range = 0;
+  unsigned i = 0;
+
+  while (i < (1 << BYTEWIDTH))
+    {
+      if (fastmap[i++])
+	{
+	  was_a_range = 0;
+          printchar (i - 1);
+          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
+            {
+              was_a_range = 1;
+              i++;
+            }
+	  if (was_a_range)
+            {
+              printf ("-");
+              printchar (i - 1);
+            }
+        }
+    }
+  putchar ('\n');
+}
+
+
+/* Print a compiled pattern string in human-readable form, starting at
+   the START pointer into it and ending just before the pointer END.  */
+
+void print_partial_compiled_pattern(unsigned char *start, unsigned char *end)
+{
+  int mcnt, mcnt2;
+  unsigned char *p = start;
+  unsigned char *pend = end;
+
+  if (start == NULL)
+    {
+      printf ("(null)\n");
+      return;
+    }
+
+  /* Loop over pattern commands.  */
+  while (p < pend)
+    {
+      switch ((re_opcode_t) *p++)
+	{
+        case no_op:
+          printf ("/no_op");
+          break;
+
+	case exactn:
+	  mcnt = *p++;
+          printf ("/exactn/%d", mcnt);
+          do
+	    {
+              putchar ('/');
+	      printchar (*p++);
+            }
+          while (--mcnt);
+          break;
+
+	case start_memory:
+          mcnt = *p++;
+          printf ("/start_memory/%d/%d", mcnt, *p++);
+          break;
+
+	case stop_memory:
+          mcnt = *p++;
+	  printf ("/stop_memory/%d/%d", mcnt, *p++);
+          break;
+
+	case duplicate:
+	  printf ("/duplicate/%d", *p++);
+	  break;
+
+	case anychar:
+	  printf ("/anychar");
+	  break;
+
+	case charset:
+        case charset_not:
+          {
+            register int c;
+
+            printf ("/charset%s",
+	            (re_opcode_t) *(p - 1) == charset_not ? "_not" : "");
+
+            assert (p + *p < pend);
+
+            for (c = 0; c < *p; c++)
+              {
+                unsigned bit;
+                unsigned char map_byte = p[1 + c];
+
+                putchar ('/');
+
+		for (bit = 0; bit < BYTEWIDTH; bit++)
+                  if (map_byte & (1 << bit))
+                    printchar (c * BYTEWIDTH + bit);
+              }
+	    p += 1 + *p;
+	    break;
+	  }
+
+	case begline:
+	  printf ("/begline");
+          break;
+
+	case endline:
+          printf ("/endline");
+          break;
+
+	case on_failure_jump:
+          extract_number_and_incr (&mcnt, &p);
+  	  printf ("/on_failure_jump/0/%d", mcnt);
+          break;
+
+	case on_failure_keep_string_jump:
+          extract_number_and_incr (&mcnt, &p);
+  	  printf ("/on_failure_keep_string_jump/0/%d", mcnt);
+          break;
+
+	case dummy_failure_jump:
+          extract_number_and_incr (&mcnt, &p);
+  	  printf ("/dummy_failure_jump/0/%d", mcnt);
+          break;
+
+	case push_dummy_failure:
+          printf ("/push_dummy_failure");
+          break;
+
+        case maybe_pop_jump:
+          extract_number_and_incr (&mcnt, &p);
+  	  printf ("/maybe_pop_jump/0/%d", mcnt);
+	  break;
+
+        case pop_failure_jump:
+	  extract_number_and_incr (&mcnt, &p);
+  	  printf ("/pop_failure_jump/0/%d", mcnt);
+	  break;
+
+        case jump_past_alt:
+	  extract_number_and_incr (&mcnt, &p);
+  	  printf ("/jump_past_alt/0/%d", mcnt);
+	  break;
+
+        case jump:
+	  extract_number_and_incr (&mcnt, &p);
+  	  printf ("/jump/0/%d", mcnt);
+	  break;
+
+        case succeed_n:
+          extract_number_and_incr (&mcnt, &p);
+          extract_number_and_incr (&mcnt2, &p);
+ 	  printf ("/succeed_n/0/%d/0/%d", mcnt, mcnt2);
+          break;
+
+        case jump_n:
+          extract_number_and_incr (&mcnt, &p);
+          extract_number_and_incr (&mcnt2, &p);
+ 	  printf ("/jump_n/0/%d/0/%d", mcnt, mcnt2);
+          break;
+
+        case set_number_at:
+          extract_number_and_incr (&mcnt, &p);
+          extract_number_and_incr (&mcnt2, &p);
+ 	  printf ("/set_number_at/0/%d/0/%d", mcnt, mcnt2);
+          break;
+
+        case wordbound:
+	  printf ("/wordbound");
+	  break;
+
+	case notwordbound:
+	  printf ("/notwordbound");
+          break;
+
+	case wordbeg:
+	  printf ("/wordbeg");
+	  break;
+
+	case wordend:
+	  printf ("/wordend");
+
+#ifdef emacs
+	case before_dot:
+	  printf ("/before_dot");
+          break;
+
+	case at_dot:
+	  printf ("/at_dot");
+          break;
+
+	case after_dot:
+	  printf ("/after_dot");
+          break;
+
+	case syntaxspec:
+          printf ("/syntaxspec");
+	  mcnt = *p++;
+	  printf ("/%d", mcnt);
+          break;
+
+	case notsyntaxspec:
+          printf ("/notsyntaxspec");
+	  mcnt = *p++;
+	  printf ("/%d", mcnt);
+	  break;
+#endif /* emacs */
+
+	case wordchar:
+	  printf ("/wordchar");
+          break;
+
+	case notwordchar:
+	  printf ("/notwordchar");
+          break;
+
+	case begbuf:
+	  printf ("/begbuf");
+          break;
+
+	case endbuf:
+	  printf ("/endbuf");
+          break;
+
+        default:
+          printf ("?%d", *(p-1));
+	}
+    }
+  printf ("/\n");
+}
+
+
+void print_compiled_pattern(struct re_pattern_buffer *bufp)
+{
+  unsigned char *buffer = bufp->buffer;
+
+  print_partial_compiled_pattern (buffer, buffer + bufp->used);
+  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
+
+  if (bufp->fastmap_accurate && bufp->fastmap)
+    {
+      printf ("fastmap: ");
+      print_fastmap (bufp->fastmap);
+    }
+
+  printf ("re_nsub: %d\t", bufp->re_nsub);
+  printf ("regs_alloc: %d\t", bufp->regs_allocated);
+  printf ("can_be_null: %d\t", bufp->can_be_null);
+  printf ("newline_anchor: %d\n", bufp->newline_anchor);
+  printf ("no_sub: %d\t", bufp->no_sub);
+  printf ("not_bol: %d\t", bufp->not_bol);
+  printf ("not_eol: %d\t", bufp->not_eol);
+  printf ("syntax: %d\n", bufp->syntax);
+  /* Perhaps we should print the translate table?  */
+}
+
+
+void print_double_string(const char *where,
+                         const char *string1,
+                         const char *string2,
+                         int size1,
+                         int size2)
+{
+  unsigned this_char;
+
+  if (where == NULL)
+    printf ("(null)");
+  else
+    {
+      if (FIRST_STRING_P (where))
+        {
+          for (this_char = where - string1; this_char < size1; this_char++)
+            printchar (string1[this_char]);
+
+          where = string2;
+        }
+
+      for (this_char = where - string2; this_char < size2; this_char++)
+        printchar (string2[this_char]);
+    }
+}
+
+#else /* not DEBUG */
+
+#undef assert
+#define assert(e)
+
+#define DEBUG_STATEMENT(e)
+#define DEBUG_PRINT1(x)
+#define DEBUG_PRINT2(x1, x2)
+#define DEBUG_PRINT3(x1, x2, x3)
+#define DEBUG_PRINT4(x1, x2, x3, x4)
+#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
+#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
+
+#endif /* not DEBUG */
+
+/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
+   also be assigned to arbitrarily: each pattern buffer stores its own
+   syntax, so it can be changed between regex compilations.  */
+reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
+
+
+/* Specify the precise syntax of regexps for compilation.  This provides
+   for compatibility for various utilities which historically have
+   different, incompatible syntaxes.
+
+   The argument SYNTAX is a bit mask comprised of the various bits
+   defined in regex.h.  We return the old syntax.  */
+
+reg_syntax_t
+re_set_syntax (syntax)
+    reg_syntax_t syntax;
+{
+  reg_syntax_t ret = re_syntax_options;
+
+  re_syntax_options = syntax;
+  return ret;
+}
+
+/* This table gives an error message for each of the error codes listed
+   in regex.h.  Obviously the order here has to be same as there.  */
+
+static const char *re_error_msg[] =
+  { NULL,					/* REG_NOERROR */
+    "No match",					/* REG_NOMATCH */
+    "Invalid regular expression",		/* REG_BADPAT */
+    "Invalid collation character",		/* REG_ECOLLATE */
+    "Invalid character class name",		/* REG_ECTYPE */
+    "Trailing backslash",			/* REG_EESCAPE */
+    "Invalid back reference",			/* REG_ESUBREG */
+    "Unmatched [ or [^",			/* REG_EBRACK */
+    "Unmatched ( or \\(",			/* REG_EPAREN */
+    "Unmatched \\{",				/* REG_EBRACE */
+    "Invalid content of \\{\\}",		/* REG_BADBR */
+    "Invalid range end",			/* REG_ERANGE */
+    "Memory exhausted",				/* REG_ESPACE */
+    "Invalid preceding regular expression",	/* REG_BADRPT */
+    "Premature end of regular expression",	/* REG_EEND */
+    "Regular expression too big",		/* REG_ESIZE */
+    "Unmatched ) or \\)",			/* REG_ERPAREN */
+  };
+
+/* Subroutine declarations and macros for regex_compile.  */
+
+static void store_op1 (), store_op2 ();
+static void insert_op1 (), insert_op2 ();
+static boolean at_begline_loc_p (), at_endline_loc_p ();
+static boolean group_in_compile_stack ();
+static reg_errcode_t compile_range ();
+
+/* Fetch the next character in the uncompiled pattern---translating it
+   if necessary.  Also cast from a signed character in the constant
+   string passed to us by the user to an unsigned char that we can use
+   as an array index (in, e.g., `translate').  */
+#define PATFETCH(c)							\
+  do {if (p == pend) return REG_EEND;					\
+    c = (unsigned char) *p++;						\
+    if (translate) c = translate[c]; 					\
+  } while (0)
+
+/* Fetch the next character in the uncompiled pattern, with no
+   translation.  */
+#define PATFETCH_RAW(c)							\
+  do {if (p == pend) return REG_EEND;					\
+    c = (unsigned char) *p++; 						\
+  } while (0)
+
+/* Go backwards one character in the pattern.  */
+#define PATUNFETCH p--
+
+
+/* If `translate' is non-null, return translate[D], else just D.  We
+   cast the subscript to translate because some data is declared as
+   `char *', to avoid warnings when a string constant is passed.  But
+   when we use a character as a subscript we must make it unsigned.  */
+#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
+
+
+/* Macros for outputting the compiled pattern into `buffer'.  */
+
+/* If the buffer isn't allocated when it comes in, use this.  */
+#define INIT_BUF_SIZE  32
+
+/* Make sure we have at least N more bytes of space in buffer.  */
+#define GET_BUFFER_SPACE(n)						\
+    while (b - bufp->buffer + (n) > bufp->allocated)			\
+      EXTEND_BUFFER ()
+
+/* Make sure we have one more byte of buffer space and then add C to it.  */
+#define BUF_PUSH(c)							\
+  do {									\
+    GET_BUFFER_SPACE (1);						\
+    *b++ = (unsigned char) (c);						\
+  } while (0)
+
+
+/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
+#define BUF_PUSH_2(c1, c2)						\
+  do {									\
+    GET_BUFFER_SPACE (2);						\
+    *b++ = (unsigned char) (c1);					\
+    *b++ = (unsigned char) (c2);					\
+  } while (0)
+
+
+/* As with BUF_PUSH_2, except for three bytes.  */
+#define BUF_PUSH_3(c1, c2, c3)						\
+  do {									\
+    GET_BUFFER_SPACE (3);						\
+    *b++ = (unsigned char) (c1);					\
+    *b++ = (unsigned char) (c2);					\
+    *b++ = (unsigned char) (c3);					\
+  } while (0)
+
+
+/* Store a jump with opcode OP at LOC to location TO.  We store a
+   relative address offset by the three bytes the jump itself occupies.  */
+#define STORE_JUMP(op, loc, to) \
+  store_op1 (op, loc, (to) - (loc) - 3)
+
+/* Likewise, for a two-argument jump.  */
+#define STORE_JUMP2(op, loc, to, arg) \
+  store_op2 (op, loc, (to) - (loc) - 3, arg)
+
+/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
+#define INSERT_JUMP(op, loc, to) \
+  insert_op1 (op, loc, (to) - (loc) - 3, b)
+
+/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
+#define INSERT_JUMP2(op, loc, to, arg) \
+  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
+
+
+/* This is not an arbitrary limit: the arguments which represent offsets
+   into the pattern are two bytes long.  So if 2^16 bytes turns out to
+   be too small, many things would have to change.  */
+#define MAX_BUF_SIZE (1L << 16)
+
+
+/* Extend the buffer by twice its current size via realloc and
+   reset the pointers that pointed into the old block to point to the
+   correct places in the new one.  If extending the buffer results in it
+   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
+#define EXTEND_BUFFER()							\
+  do { 									\
+    unsigned char *old_buffer = bufp->buffer;				\
+    if (bufp->allocated == MAX_BUF_SIZE) 				\
+      return REG_ESIZE;							\
+    bufp->allocated <<= 1;						\
+    if (bufp->allocated > MAX_BUF_SIZE)					\
+      bufp->allocated = MAX_BUF_SIZE; 					\
+    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
+    if (bufp->buffer == NULL)						\
+      return REG_ESPACE;						\
+    /* If the buffer moved, move all the pointers into it.  */		\
+    if (old_buffer != bufp->buffer)					\
+      {									\
+        b = (b - old_buffer) + bufp->buffer;				\
+        begalt = (begalt - old_buffer) + bufp->buffer;			\
+        if (fixup_alt_jump)						\
+          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
+        if (laststart)							\
+          laststart = (laststart - old_buffer) + bufp->buffer;		\
+        if (pending_exact)						\
+          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
+      }									\
+  } while (0)
+
+
+/* Since we have one byte reserved for the register number argument to
+   {start,stop}_memory, the maximum number of groups we can report
+   things about is what fits in that byte.  */
+#define MAX_REGNUM 255
+
+/* But patterns can have more than `MAX_REGNUM' registers.  We just
+   ignore the excess.  */
+typedef unsigned regnum_t;
+
+
+/* Macros for the compile stack.  */
+
+/* Since offsets can go either forwards or backwards, this type needs to
+   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
+typedef int pattern_offset_t;
+
+typedef struct
+{
+  pattern_offset_t begalt_offset;
+  pattern_offset_t fixup_alt_jump;
+  pattern_offset_t inner_group_offset;
+  pattern_offset_t laststart_offset;
+  regnum_t regnum;
+} compile_stack_elt_t;
+
+
+typedef struct
+{
+  compile_stack_elt_t *stack;
+  unsigned size;
+  unsigned avail;			/* Offset of next open position.  */
+} compile_stack_type;
+
+
+#define INIT_COMPILE_STACK_SIZE 32
+
+#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
+#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
+
+/* The next available element.  */
+#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
+
+
+/* Set the bit for character C in a list.  */
+#define SET_LIST_BIT(c)                               \
+  (b[((unsigned char) (c)) / BYTEWIDTH]               \
+   |= 1 << (((unsigned char) c) % BYTEWIDTH))
+
+
+/* Get the next unsigned number in the uncompiled pattern.  */
+#define GET_UNSIGNED_NUMBER(num) 					\
+  { if (p != pend)							\
+     {									\
+       PATFETCH (c); 							\
+       while (ISDIGIT (c)) 						\
+         { 								\
+           if (num < 0)							\
+              num = 0;							\
+           num = num * 10 + c - '0'; 					\
+           if (p == pend) 						\
+              break; 							\
+           PATFETCH (c);						\
+         } 								\
+       } 								\
+    }
+
+#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
+
+#define IS_CHAR_CLASS(string)						\
+   (STREQ (string, "alpha") || STREQ (string, "upper")			\
+    || STREQ (string, "lower") || STREQ (string, "digit")		\
+    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
+    || STREQ (string, "space") || STREQ (string, "print")		\
+    || STREQ (string, "punct") || STREQ (string, "graph")		\
+    || STREQ (string, "cntrl") || STREQ (string, "blank"))
+
+/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
+   Returns one of error codes defined in `regex.h', or zero for success.
+
+   Assumes the `allocated' (and perhaps `buffer') and `translate'
+   fields are set in BUFP on entry.
+
+   If it succeeds, results are put in BUFP (if it returns an error, the
+   contents of BUFP are undefined):
+     `buffer' is the compiled pattern;
+     `syntax' is set to SYNTAX;
+     `used' is set to the length of the compiled pattern;
+     `fastmap_accurate' is zero;
+     `re_nsub' is the number of subexpressions in PATTERN;
+     `not_bol' and `not_eol' are zero;
+
+   The `fastmap' and `newline_anchor' fields are neither
+   examined nor set.  */
+
+static reg_errcode_t
+regex_compile (pattern, size, syntax, bufp)
+     const char *pattern;
+     int size;
+     reg_syntax_t syntax;
+     struct re_pattern_buffer *bufp;
+{
+  /* We fetch characters from PATTERN here.  Even though PATTERN is
+     `char *' (i.e., signed), we declare these variables as unsigned, so
+     they can be reliably used as array indices.  */
+  register unsigned char c, c1;
+
+  /* A random tempory spot in PATTERN.  */
+  const char *p1;
+
+  /* Points to the end of the buffer, where we should append.  */
+  register unsigned char *b;
+
+  /* Keeps track of unclosed groups.  */
+  compile_stack_type compile_stack;
+
+  /* Points to the current (ending) position in the pattern.  */
+  const char *p = pattern;
+  const char *pend = pattern + size;
+
+  /* How to translate the characters in the pattern.  */
+  char *translate = bufp->translate;
+
+  /* Address of the count-byte of the most recently inserted `exactn'
+     command.  This makes it possible to tell if a new exact-match
+     character can be added to that command or if the character requires
+     a new `exactn' command.  */
+  unsigned char *pending_exact = 0;
+
+  /* Address of start of the most recently finished expression.
+     This tells, e.g., postfix * where to find the start of its
+     operand.  Reset at the beginning of groups and alternatives.  */
+  unsigned char *laststart = 0;
+
+  /* Address of beginning of regexp, or inside of last group.  */
+  unsigned char *begalt;
+
+  /* Place in the uncompiled pattern (i.e., the {) to
+     which to go back if the interval is invalid.  */
+  const char *beg_interval;
+
+  /* Address of the place where a forward jump should go to the end of
+     the containing expression.  Each alternative of an `or' -- except the
+     last -- ends with a forward jump of this sort.  */
+  unsigned char *fixup_alt_jump = 0;
+
+  /* Counts open-groups as they are encountered.  Remembered for the
+     matching close-group on the compile stack, so the same register
+     number is put in the stop_memory as the start_memory.  */
+  regnum_t regnum = 0;
+
+#ifdef DEBUG
+  DEBUG_PRINT1 ("\nCompiling pattern: ");
+  if (debug)
+    {
+      unsigned debug_count;
+
+      for (debug_count = 0; debug_count < size; debug_count++)
+        printchar (pattern[debug_count]);
+      putchar ('\n');
+    }
+#endif /* DEBUG */
+
+  /* Initialize the compile stack.  */
+  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
+  if (compile_stack.stack == NULL)
+    return REG_ESPACE;
+
+  compile_stack.size = INIT_COMPILE_STACK_SIZE;
+  compile_stack.avail = 0;
+
+  /* Initialize the pattern buffer.  */
+  bufp->syntax = syntax;
+  bufp->fastmap_accurate = 0;
+  bufp->not_bol = bufp->not_eol = 0;
+
+  /* Set `used' to zero, so that if we return an error, the pattern
+     printer (for debugging) will think there's no pattern.  We reset it
+     at the end.  */
+  bufp->used = 0;
+
+  /* Always count groups, whether or not bufp->no_sub is set.  */
+  bufp->re_nsub = 0;
+
+#if !defined (emacs) && !defined (SYNTAX_TABLE)
+  /* Initialize the syntax table.  */
+   init_syntax_once ();
+#endif
+
+  if (bufp->allocated == 0)
+    {
+      if (bufp->buffer)
+	{ /* If zero allocated, but buffer is non-null, try to realloc
+             enough space.  This loses if buffer's address is bogus, but
+             that is the user's responsibility.  */
+          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
+        }
+      else
+        { /* Caller did not allocate a buffer.  Do it for them.  */
+          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
+        }
+      if (!bufp->buffer) return REG_ESPACE;
+
+      bufp->allocated = INIT_BUF_SIZE;
+    }
+
+  begalt = b = bufp->buffer;
+
+  /* Loop through the uncompiled pattern until we're at the end.  */
+  while (p != pend)
+    {
+      PATFETCH (c);
+
+      switch (c)
+        {
+        case '^':
+          {
+            if (   /* If at start of pattern, it's an operator.  */
+                   p == pattern + 1
+                   /* If context independent, it's an operator.  */
+                || syntax & RE_CONTEXT_INDEP_ANCHORS
+                   /* Otherwise, depends on what's come before.  */
+                || at_begline_loc_p (pattern, p, syntax))
+              BUF_PUSH (begline);
+            else
+              goto normal_char;
+          }
+          break;
+
+
+        case '$':
+          {
+            if (   /* If at end of pattern, it's an operator.  */
+                   p == pend
+                   /* If context independent, it's an operator.  */
+                || syntax & RE_CONTEXT_INDEP_ANCHORS
+                   /* Otherwise, depends on what's next.  */
+                || at_endline_loc_p (p, pend, syntax))
+               BUF_PUSH (endline);
+             else
+               goto normal_char;
+           }
+           break;
+
+
+	case '+':
+        case '?':
+          if ((syntax & RE_BK_PLUS_QM)
+              || (syntax & RE_LIMITED_OPS))
+            goto normal_char;
+        handle_plus:
+        case '*':
+          /* If there is no previous pattern... */
+          if (!laststart)
+            {
+              if (syntax & RE_CONTEXT_INVALID_OPS)
+                return REG_BADRPT;
+              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
+                goto normal_char;
+            }
+
+          {
+            /* Are we optimizing this jump?  */
+            boolean keep_string_p = false;
+
+            /* 1 means zero (many) matches is allowed.  */
+            char zero_times_ok = 0, many_times_ok = 0;
+
+            /* If there is a sequence of repetition chars, collapse it
+               down to just one (the right one).  We can't combine
+               interval operators with these because of, e.g., `a{2}*',
+               which should only match an even number of `a's.  */
+
+            for (;;)
+              {
+                zero_times_ok |= c != '+';
+                many_times_ok |= c != '?';
+
+                if (p == pend)
+                  break;
+
+                PATFETCH (c);
+
+                if (c == '*'
+                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
+                  ;
+
+                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
+                  {
+                    if (p == pend) return REG_EESCAPE;
+
+                    PATFETCH (c1);
+                    if (!(c1 == '+' || c1 == '?'))
+                      {
+                        PATUNFETCH;
+                        PATUNFETCH;
+                        break;
+                      }
+
+                    c = c1;
+                  }
+                else
+                  {
+                    PATUNFETCH;
+                    break;
+                  }
+
+                /* If we get here, we found another repeat character.  */
+               }
+
+            /* Star, etc. applied to an empty pattern is equivalent
+               to an empty pattern.  */
+            if (!laststart)
+              break;
+
+            /* Now we know whether or not zero matches is allowed
+               and also whether or not two or more matches is allowed.  */
+            if (many_times_ok)
+              { /* More than one repetition is allowed, so put in at the
+                   end a backward relative jump from `b' to before the next
+                   jump we're going to put in below (which jumps from
+                   laststart to after this jump).
+
+                   But if we are at the `*' in the exact sequence `.*\n',
+                   insert an unconditional jump backwards to the .,
+                   instead of the beginning of the loop.  This way we only
+                   push a failure point once, instead of every time
+                   through the loop.  */
+                assert (p - 1 > pattern);
+
+                /* Allocate the space for the jump.  */
+                GET_BUFFER_SPACE (3);
+
+                /* We know we are not at the first character of the pattern,
+                   because laststart was nonzero.  And we've already
+                   incremented `p', by the way, to be the character after
+                   the `*'.  Do we have to do something analogous here
+                   for null bytes, because of RE_DOT_NOT_NULL?  */
+                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
+		    && zero_times_ok
+                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
+                    && !(syntax & RE_DOT_NEWLINE))
+                  { /* We have .*\n.  */
+                    STORE_JUMP (jump, b, laststart);
+                    keep_string_p = true;
+                  }
+                else
+                  /* Anything else.  */
+                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
+
+                /* We've added more stuff to the buffer.  */
+                b += 3;
+              }
+
+            /* On failure, jump from laststart to b + 3, which will be the
+               end of the buffer after this jump is inserted.  */
+            GET_BUFFER_SPACE (3);
+            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
+                                       : on_failure_jump,
+                         laststart, b + 3);
+            pending_exact = 0;
+            b += 3;
+
+            if (!zero_times_ok)
+              {
+                /* At least one repetition is required, so insert a
+                   `dummy_failure_jump' before the initial
+                   `on_failure_jump' instruction of the loop. This
+                   effects a skip over that instruction the first time
+                   we hit that loop.  */
+                GET_BUFFER_SPACE (3);
+                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
+                b += 3;
+              }
+            }
+	  break;
+
+
+	case '.':
+          laststart = b;
+          BUF_PUSH (anychar);
+          break;
+
+
+        case '[':
+          {
+            boolean had_char_class = false;
+
+            if (p == pend) return REG_EBRACK;
+
+            /* Ensure that we have enough space to push a charset: the
+               opcode, the length count, and the bitset; 34 bytes in all.  */
+	    GET_BUFFER_SPACE (34);
+
+            laststart = b;
+
+            /* We test `*p == '^' twice, instead of using an if
+               statement, so we only need one BUF_PUSH.  */
+            BUF_PUSH (*p == '^' ? charset_not : charset);
+            if (*p == '^')
+              p++;
+
+            /* Remember the first position in the bracket expression.  */
+            p1 = p;
+
+            /* Push the number of bytes in the bitmap.  */
+            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
+
+            /* Clear the whole map.  */
+            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
+
+            /* charset_not matches newline according to a syntax bit.  */
+            if ((re_opcode_t) b[-2] == charset_not
+                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
+              SET_LIST_BIT ('\n');
+
+            /* Read in characters and ranges, setting map bits.  */
+            for (;;)
+              {
+                if (p == pend) return REG_EBRACK;
+
+                PATFETCH (c);
+
+                /* \ might escape characters inside [...] and [^...].  */
+                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
+                  {
+                    if (p == pend) return REG_EESCAPE;
+
+                    PATFETCH (c1);
+                    SET_LIST_BIT (c1);
+                    continue;
+                  }
+
+                /* Could be the end of the bracket expression.  If it's
+                   not (i.e., when the bracket expression is `[]' so
+                   far), the ']' character bit gets set way below.  */
+                if (c == ']' && p != p1 + 1)
+                  break;
+
+                /* Look ahead to see if it's a range when the last thing
+                   was a character class.  */
+                if (had_char_class && c == '-' && *p != ']')
+                  return REG_ERANGE;
+
+                /* Look ahead to see if it's a range when the last thing
+                   was a character: if this is a hyphen not at the
+                   beginning or the end of a list, then it's the range
+                   operator.  */
+                if (c == '-'
+                    && !(p - 2 >= pattern && p[-2] == '[')
+                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
+                    && *p != ']')
+                  {
+                    reg_errcode_t ret
+                      = compile_range (&p, pend, translate, syntax, b);
+                    if (ret != REG_NOERROR) return ret;
+                  }
+
+                else if (p[0] == '-' && p[1] != ']')
+                  { /* This handles ranges made up of characters only.  */
+                    reg_errcode_t ret;
+
+		    /* Move past the `-'.  */
+                    PATFETCH (c1);
+
+                    ret = compile_range (&p, pend, translate, syntax, b);
+                    if (ret != REG_NOERROR) return ret;
+                  }
+
+                /* See if we're at the beginning of a possible character
+                   class.  */
+
+                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
+                  { /* Leave room for the null.  */
+                    char str[CHAR_CLASS_MAX_LENGTH + 1];
+
+                    PATFETCH (c);
+                    c1 = 0;
+
+                    /* If pattern is `[[:'.  */
+                    if (p == pend) return REG_EBRACK;
+
+                    for (;;)
+                      {
+                        PATFETCH (c);
+                        if (c == ':' || c == ']' || p == pend
+                            || c1 == CHAR_CLASS_MAX_LENGTH)
+                          break;
+                        str[c1++] = c;
+                      }
+                    str[c1] = '\0';
+
+                    /* If isn't a word bracketed by `[:' and:`]':
+                       undo the ending character, the letters, and leave
+                       the leading `:' and `[' (but set bits for them).  */
+                    if (c == ':' && *p == ']')
+                      {
+                        int ch;
+                        boolean is_alnum = STREQ (str, "alnum");
+                        boolean is_alpha = STREQ (str, "alpha");
+                        boolean is_blank = STREQ (str, "blank");
+                        boolean is_cntrl = STREQ (str, "cntrl");
+                        boolean is_digit = STREQ (str, "digit");
+                        boolean is_graph = STREQ (str, "graph");
+                        boolean is_lower = STREQ (str, "lower");
+                        boolean is_print = STREQ (str, "print");
+                        boolean is_punct = STREQ (str, "punct");
+                        boolean is_space = STREQ (str, "space");
+                        boolean is_upper = STREQ (str, "upper");
+                        boolean is_xdigit = STREQ (str, "xdigit");
+
+                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
+
+                        /* Throw away the ] at the end of the character
+                           class.  */
+                        PATFETCH (c);
+
+                        if (p == pend) return REG_EBRACK;
+
+                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
+                          {
+                            if (   (is_alnum  && ISALNUM (ch))
+                                || (is_alpha  && ISALPHA (ch))
+                                || (is_blank  && ISBLANK (ch))
+                                || (is_cntrl  && ISCNTRL (ch))
+                                || (is_digit  && ISDIGIT (ch))
+                                || (is_graph  && ISGRAPH (ch))
+                                || (is_lower  && ISLOWER (ch))
+                                || (is_print  && ISPRINT (ch))
+                                || (is_punct  && ISPUNCT (ch))
+                                || (is_space  && ISSPACE (ch))
+                                || (is_upper  && ISUPPER (ch))
+                                || (is_xdigit && ISXDIGIT (ch)))
+                            SET_LIST_BIT (ch);
+                          }
+                        had_char_class = true;
+                      }
+                    else
+                      {
+                        c1++;
+                        while (c1--)
+                          PATUNFETCH;
+                        SET_LIST_BIT ('[');
+                        SET_LIST_BIT (':');
+                        had_char_class = false;
+                      }
+                  }
+                else
+                  {
+                    had_char_class = false;
+                    SET_LIST_BIT (c);
+                  }
+              }
+
+            /* Discard any (non)matching list bytes that are all 0 at the
+               end of the map.  Decrease the map-length byte too.  */
+            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
+              b[-1]--;
+            b += b[-1];
+          }
+          break;
+
+
+	case '(':
+          if (syntax & RE_NO_BK_PARENS)
+            goto handle_open;
+          else
+            goto normal_char;
+
+
+        case ')':
+          if (syntax & RE_NO_BK_PARENS)
+            goto handle_close;
+          else
+            goto normal_char;
+
+
+        case '\n':
+          if (syntax & RE_NEWLINE_ALT)
+            goto handle_alt;
+          else
+            goto normal_char;
+
+
+	case '|':
+          if (syntax & RE_NO_BK_VBAR)
+            goto handle_alt;
+          else
+            goto normal_char;
+
+
+        case '{':
+           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
+             goto handle_interval;
+           else
+             goto normal_char;
+
+
+        case '\\':
+          if (p == pend) return REG_EESCAPE;
+
+          /* Do not translate the character after the \, so that we can
+             distinguish, e.g., \B from \b, even if we normally would
+             translate, e.g., B to b.  */
+          PATFETCH_RAW (c);
+
+          switch (c)
+            {
+            case '(':
+              if (syntax & RE_NO_BK_PARENS)
+                goto normal_backslash;
+
+            handle_open:
+              bufp->re_nsub++;
+              regnum++;
+
+              if (COMPILE_STACK_FULL)
+                {
+                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
+                            compile_stack_elt_t);
+                  if (compile_stack.stack == NULL) return REG_ESPACE;
+
+                  compile_stack.size <<= 1;
+                }
+
+              /* These are the values to restore when we hit end of this
+                 group.  They are all relative offsets, so that if the
+                 whole pattern moves because of realloc, they will still
+                 be valid.  */
+              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
+              COMPILE_STACK_TOP.fixup_alt_jump
+                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
+              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
+              COMPILE_STACK_TOP.regnum = regnum;
+
+              /* We will eventually replace the 0 with the number of
+                 groups inner to this one.  But do not push a
+                 start_memory for groups beyond the last one we can
+                 represent in the compiled pattern.  */
+              if (regnum <= MAX_REGNUM)
+                {
+                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
+                  BUF_PUSH_3 (start_memory, regnum, 0);
+                }
+
+              compile_stack.avail++;
+
+              fixup_alt_jump = 0;
+              laststart = 0;
+              begalt = b;
+	      /* If we've reached MAX_REGNUM groups, then this open
+		 won't actually generate any code, so we'll have to
+		 clear pending_exact explicitly.  */
+	      pending_exact = 0;
+              break;
+
+
+            case ')':
+              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
+
+              if (COMPILE_STACK_EMPTY)
+                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
+                  goto normal_backslash;
+                else
+                  return REG_ERPAREN;
+
+            handle_close:
+              if (fixup_alt_jump)
+                { /* Push a dummy failure point at the end of the
+                     alternative for a possible future
+                     `pop_failure_jump' to pop.  See comments at
+                     `push_dummy_failure' in `re_match_2'.  */
+                  BUF_PUSH (push_dummy_failure);
+
+                  /* We allocated space for this jump when we assigned
+                     to `fixup_alt_jump', in the `handle_alt' case below.  */
+                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
+                }
+
+              /* See similar code for backslashed left paren above.  */
+              if (COMPILE_STACK_EMPTY)
+                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
+                  goto normal_char;
+                else
+                  return REG_ERPAREN;
+
+              /* Since we just checked for an empty stack above, this
+                 ``can't happen''.  */
+              assert (compile_stack.avail != 0);
+              {
+                /* We don't just want to restore into `regnum', because
+                   later groups should continue to be numbered higher,
+                   as in `(ab)c(de)' -- the second group is #2.  */
+                regnum_t this_group_regnum;
+
+                compile_stack.avail--;
+                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
+                fixup_alt_jump
+                  = COMPILE_STACK_TOP.fixup_alt_jump
+                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
+                    : 0;
+                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
+                this_group_regnum = COMPILE_STACK_TOP.regnum;
+		/* If we've reached MAX_REGNUM groups, then this open
+		   won't actually generate any code, so we'll have to
+		   clear pending_exact explicitly.  */
+		pending_exact = 0;
+
+                /* We're at the end of the group, so now we know how many
+                   groups were inside this one.  */
+                if (this_group_regnum <= MAX_REGNUM)
+                  {
+                    unsigned char *inner_group_loc
+                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
+
+                    *inner_group_loc = regnum - this_group_regnum;
+                    BUF_PUSH_3 (stop_memory, this_group_regnum,
+                                regnum - this_group_regnum);
+                  }
+              }
+              break;
+
+
+            case '|':					/* `\|'.  */
+              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
+                goto normal_backslash;
+            handle_alt:
+              if (syntax & RE_LIMITED_OPS)
+                goto normal_char;
+
+              /* Insert before the previous alternative a jump which
+                 jumps to this alternative if the former fails.  */
+              GET_BUFFER_SPACE (3);
+              INSERT_JUMP (on_failure_jump, begalt, b + 6);
+              pending_exact = 0;
+              b += 3;
+
+              /* The alternative before this one has a jump after it
+                 which gets executed if it gets matched.  Adjust that
+                 jump so it will jump to this alternative's analogous
+                 jump (put in below, which in turn will jump to the next
+                 (if any) alternative's such jump, etc.).  The last such
+                 jump jumps to the correct final destination.  A picture:
+                          _____ _____
+                          |   | |   |
+                          |   v |   v
+                         a | b   | c
+
+                 If we are at `b', then fixup_alt_jump right now points to a
+                 three-byte space after `a'.  We'll put in the jump, set
+                 fixup_alt_jump to right after `b', and leave behind three
+                 bytes which we'll fill in when we get to after `c'.  */
+
+              if (fixup_alt_jump)
+                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
+
+              /* Mark and leave space for a jump after this alternative,
+                 to be filled in later either by next alternative or
+                 when know we're at the end of a series of alternatives.  */
+              fixup_alt_jump = b;
+              GET_BUFFER_SPACE (3);
+              b += 3;
+
+              laststart = 0;
+              begalt = b;
+              break;
+
+
+            case '{':
+              /* If \{ is a literal.  */
+              if (!(syntax & RE_INTERVALS)
+                     /* If we're at `\{' and it's not the open-interval
+                        operator.  */
+                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
+                  || (p - 2 == pattern  &&  p == pend))
+                goto normal_backslash;
+
+            handle_interval:
+              {
+                /* If got here, then the syntax allows intervals.  */
+
+                /* At least (most) this many matches must be made.  */
+                int lower_bound = -1, upper_bound = -1;
+
+                beg_interval = p - 1;
+
+                if (p == pend)
+                  {
+                    if (syntax & RE_NO_BK_BRACES)
+                      goto unfetch_interval;
+                    else
+                      return REG_EBRACE;
+                  }
+
+                GET_UNSIGNED_NUMBER (lower_bound);
+
+                if (c == ',')
+                  {
+                    GET_UNSIGNED_NUMBER (upper_bound);
+                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
+                  }
+                else
+                  /* Interval such as `{1}' => match exactly once. */
+                  upper_bound = lower_bound;
+
+                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
+                    || lower_bound > upper_bound)
+                  {
+                    if (syntax & RE_NO_BK_BRACES)
+                      goto unfetch_interval;
+                    else
+                      return REG_BADBR;
+                  }
+
+                if (!(syntax & RE_NO_BK_BRACES))
+                  {
+                    if (c != '\\') return REG_EBRACE;
+
+                    PATFETCH (c);
+                  }
+
+                if (c != '}')
+                  {
+                    if (syntax & RE_NO_BK_BRACES)
+                      goto unfetch_interval;
+                    else
+                      return REG_BADBR;
+                  }
+
+                /* We just parsed a valid interval.  */
+
+                /* If it's invalid to have no preceding re.  */
+                if (!laststart)
+                  {
+                    if (syntax & RE_CONTEXT_INVALID_OPS)
+                      return REG_BADRPT;
+                    else if (syntax & RE_CONTEXT_INDEP_OPS)
+                      laststart = b;
+                    else
+                      goto unfetch_interval;
+                  }
+
+                /* If the upper bound is zero, don't want to succeed at
+                   all; jump from `laststart' to `b + 3', which will be
+                   the end of the buffer after we insert the jump.  */
+                 if (upper_bound == 0)
+                   {
+                     GET_BUFFER_SPACE (3);
+                     INSERT_JUMP (jump, laststart, b + 3);
+                     b += 3;
+                   }
+
+                 /* Otherwise, we have a nontrivial interval.  When
+                    we're all done, the pattern will look like:
+                      set_number_at <jump count> <upper bound>
+                      set_number_at <succeed_n count> <lower bound>
+                      succeed_n <after jump addr> <succed_n count>
+                      <body of loop>
+                      jump_n <succeed_n addr> <jump count>
+                    (The upper bound and `jump_n' are omitted if
+                    `upper_bound' is 1, though.)  */
+                 else
+                   { /* If the upper bound is > 1, we need to insert
+                        more at the end of the loop.  */
+                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
+
+                     GET_BUFFER_SPACE (nbytes);
+
+                     /* Initialize lower bound of the `succeed_n', even
+                        though it will be set during matching by its
+                        attendant `set_number_at' (inserted next),
+                        because `re_compile_fastmap' needs to know.
+                        Jump to the `jump_n' we might insert below.  */
+                     INSERT_JUMP2 (succeed_n, laststart,
+                                   b + 5 + (upper_bound > 1) * 5,
+                                   lower_bound);
+                     b += 5;
+
+                     /* Code to initialize the lower bound.  Insert
+                        before the `succeed_n'.  The `5' is the last two
+                        bytes of this `set_number_at', plus 3 bytes of
+                        the following `succeed_n'.  */
+                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
+                     b += 5;
+
+                     if (upper_bound > 1)
+                       { /* More than one repetition is allowed, so
+                            append a backward jump to the `succeed_n'
+                            that starts this interval.
+
+                            When we've reached this during matching,
+                            we'll have matched the interval once, so
+                            jump back only `upper_bound - 1' times.  */
+                         STORE_JUMP2 (jump_n, b, laststart + 5,
+                                      upper_bound - 1);
+                         b += 5;
+
+                         /* The location we want to set is the second
+                            parameter of the `jump_n'; that is `b-2' as
+                            an absolute address.  `laststart' will be
+                            the `set_number_at' we're about to insert;
+                            `laststart+3' the number to set, the source
+                            for the relative address.  But we are
+                            inserting into the middle of the pattern --
+                            so everything is getting moved up by 5.
+                            Conclusion: (b - 2) - (laststart + 3) + 5,
+                            i.e., b - laststart.
+
+                            We insert this at the beginning of the loop
+                            so that if we fail during matching, we'll
+                            reinitialize the bounds.  */
+                         insert_op2 (set_number_at, laststart, b - laststart,
+                                     upper_bound - 1, b);
+                         b += 5;
+                       }
+                   }
+                pending_exact = 0;
+                beg_interval = NULL;
+              }
+              break;
+
+            unfetch_interval:
+              /* If an invalid interval, match the characters as literals.  */
+               assert (beg_interval);
+               p = beg_interval;
+               beg_interval = NULL;
+
+               /* normal_char and normal_backslash need `c'.  */
+               PATFETCH (c);
+
+               if (!(syntax & RE_NO_BK_BRACES))
+                 {
+                   if (p > pattern  &&  p[-1] == '\\')
+                     goto normal_backslash;
+                 }
+               goto normal_char;
+
+#ifdef emacs
+            /* There is no way to specify the before_dot and after_dot
+               operators.  rms says this is ok.  --karl  */
+            case '=':
+              BUF_PUSH (at_dot);
+              break;
+
+            case 's':
+              laststart = b;
+              PATFETCH (c);
+              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
+              break;
+
+            case 'S':
+              laststart = b;
+              PATFETCH (c);
+              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
+              break;
+#endif /* emacs */
+
+
+            case 'w':
+              laststart = b;
+              BUF_PUSH (wordchar);
+              break;
+
+
+            case 'W':
+              laststart = b;
+              BUF_PUSH (notwordchar);
+              break;
+
+
+            case '<':
+              BUF_PUSH (wordbeg);
+              break;
+
+            case '>':
+              BUF_PUSH (wordend);
+              break;
+
+            case 'b':
+              BUF_PUSH (wordbound);
+              break;
+
+            case 'B':
+              BUF_PUSH (notwordbound);
+              break;
+
+            case '`':
+              BUF_PUSH (begbuf);
+              break;
+
+            case '\'':
+              BUF_PUSH (endbuf);
+              break;
+
+            case '1': case '2': case '3': case '4': case '5':
+            case '6': case '7': case '8': case '9':
+              if (syntax & RE_NO_BK_REFS)
+                goto normal_char;
+
+              c1 = c - '0';
+
+              if (c1 > regnum)
+                return REG_ESUBREG;
+
+              /* Can't back reference to a subexpression if inside of it.  */
+              if (group_in_compile_stack (compile_stack, c1))
+                goto normal_char;
+
+              laststart = b;
+              BUF_PUSH_2 (duplicate, c1);
+              break;
+
+
+            case '+':
+            case '?':
+              if (syntax & RE_BK_PLUS_QM)
+                goto handle_plus;
+              else
+                goto normal_backslash;
+
+            default:
+            normal_backslash:
+              /* You might think it would be useful for \ to mean
+                 not to translate; but if we don't translate it
+                 it will never match anything.  */
+              c = TRANSLATE (c);
+              goto normal_char;
+            }
+          break;
+
+
+	default:
+        /* Expects the character in `c'.  */
+	normal_char:
+	      /* If no exactn currently being built.  */
+          if (!pending_exact
+
+              /* If last exactn not at current position.  */
+              || pending_exact + *pending_exact + 1 != b
+
+              /* We have only one byte following the exactn for the count.  */
+	      || *pending_exact == (1 << BYTEWIDTH) - 1
+
+              /* If followed by a repetition operator.  */
+              || *p == '*' || *p == '^'
+	      || ((syntax & RE_BK_PLUS_QM)
+		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
+		  : (*p == '+' || *p == '?'))
+	      || ((syntax & RE_INTERVALS)
+                  && ((syntax & RE_NO_BK_BRACES)
+		      ? *p == '{'
+                      : (p[0] == '\\' && p[1] == '{'))))
+	    {
+	      /* Start building a new exactn.  */
+
+              laststart = b;
+
+	      BUF_PUSH_2 (exactn, 0);
+	      pending_exact = b - 1;
+            }
+
+	  BUF_PUSH (c);
+          (*pending_exact)++;
+	  break;
+        } /* switch (c) */
+    } /* while p != pend */
+
+
+  /* Through the pattern now.  */
+
+  if (fixup_alt_jump)
+    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
+
+  if (!COMPILE_STACK_EMPTY)
+    return REG_EPAREN;
+
+  free (compile_stack.stack);
+
+  /* We have succeeded; set the length of the buffer.  */
+  bufp->used = b - bufp->buffer;
+
+#ifdef DEBUG
+  if (debug)
+    {
+      DEBUG_PRINT1 ("\nCompiled pattern: ");
+      print_compiled_pattern (bufp);
+    }
+#endif /* DEBUG */
+
+  return REG_NOERROR;
+} /* regex_compile */
+
+/* Subroutines for `regex_compile'.  */
+
+/* Store OP at LOC followed by two-byte integer parameter ARG.  */
+
+static void
+store_op1 (op, loc, arg)
+    re_opcode_t op;
+    unsigned char *loc;
+    int arg;
+{
+  *loc = (unsigned char) op;
+  STORE_NUMBER (loc + 1, arg);
+}
+
+
+/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
+
+static void store_op2(re_opcode_t op, unsigned char *loc, int arg1, int arg2)
+{
+  *loc = (unsigned char) op;
+  STORE_NUMBER (loc + 1, arg1);
+  STORE_NUMBER (loc + 3, arg2);
+}
+
+
+/* Copy the bytes from LOC to END to open up three bytes of space at LOC
+   for OP followed by two-byte integer parameter ARG.  */
+
+static void insert_op1(re_opcode_t op, unsigned char *loc, int arg, unsigned char *end)
+{
+  register unsigned char *pfrom = end;
+  register unsigned char *pto = end + 3;
+
+  while (pfrom != loc)
+    *--pto = *--pfrom;
+
+  store_op1 (op, loc, arg);
+}
+
+
+/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
+
+static void insert_op2(re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end)
+{
+  register unsigned char *pfrom = end;
+  register unsigned char *pto = end + 5;
+
+  while (pfrom != loc)
+    *--pto = *--pfrom;
+
+  store_op2 (op, loc, arg1, arg2);
+}
+
+
+/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
+   after an alternative or a begin-subexpression.  We assume there is at
+   least one character before the ^.  */
+
+static boolean at_begline_loc_p(const char *pattern, const char *p, reg_syntax_t syntax)
+{
+  const char *prev = p - 2;
+  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
+
+  return
+       /* After a subexpression?  */
+       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
+       /* After an alternative?  */
+    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
+}
+
+
+/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
+   at least one character after the $, i.e., `P < PEND'.  */
+
+static boolean at_endline_loc_p(const char *p, const char *pend, int syntax)
+{
+  const char *next = p;
+  boolean next_backslash = *next == '\\';
+  const char *next_next = p + 1 < pend ? p + 1 : NULL;
+
+  return
+       /* Before a subexpression?  */
+       (syntax & RE_NO_BK_PARENS ? *next == ')'
+        : next_backslash && next_next && *next_next == ')')
+       /* Before an alternative?  */
+    || (syntax & RE_NO_BK_VBAR ? *next == '|'
+        : next_backslash && next_next && *next_next == '|');
+}
+
+
+/* Returns true if REGNUM is in one of COMPILE_STACK's elements and
+   false if it's not.  */
+
+static boolean group_in_compile_stack(compile_stack_type compile_stack, regnum_t regnum)
+{
+  int this_element;
+
+  for (this_element = compile_stack.avail - 1;
+       this_element >= 0;
+       this_element--)
+    if (compile_stack.stack[this_element].regnum == regnum)
+      return true;
+
+  return false;
+}
+
+
+/* Read the ending character of a range (in a bracket expression) from the
+   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
+   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
+   Then we set the translation of all bits between the starting and
+   ending characters (inclusive) in the compiled pattern B.
+
+   Return an error code.
+
+   We use these short variable names so we can use the same macros as
+   `regex_compile' itself.  */
+
+static reg_errcode_t compile_range(const char **p_ptr,
+                                   const char *pend,
+                                   char *translate,
+                                   reg_syntax_t syntax,
+                                   unsigned char *b)
+{
+  unsigned this_char;
+
+  const char *p = *p_ptr;
+  int range_start, range_end;
+
+  if (p == pend)
+    return REG_ERANGE;
+
+  /* Even though the pattern is a signed `char *', we need to fetch
+     with unsigned char *'s; if the high bit of the pattern character
+     is set, the range endpoints will be negative if we fetch using a
+     signed char *.
+
+     We also want to fetch the endpoints without translating them; the
+     appropriate translation is done in the bit-setting loop below.  */
+  range_start = ((unsigned char *) p)[-2];
+  range_end   = ((unsigned char *) p)[0];
+
+  /* Have to increment the pointer into the pattern string, so the
+     caller isn't still at the ending character.  */
+  (*p_ptr)++;
+
+  /* If the start is after the end, the range is empty.  */
+  if (range_start > range_end)
+    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
+
+  /* Here we see why `this_char' has to be larger than an `unsigned
+     char' -- the range is inclusive, so if `range_end' == 0xff
+     (assuming 8-bit characters), we would otherwise go into an infinite
+     loop, since all characters <= 0xff.  */
+  for (this_char = range_start; this_char <= range_end; this_char++)
+    {
+      SET_LIST_BIT (TRANSLATE (this_char));
+    }
+
+  return REG_NOERROR;
+}
+
+/* Failure stack declarations and macros; both re_compile_fastmap and
+   re_match_2 use a failure stack.  These have to be macros because of
+   REGEX_ALLOCATE.  */
+
+
+/* Number of failure points for which to initially allocate space
+   when matching.  If this number is exceeded, we allocate more
+   space, so it is not a hard limit.  */
+#ifndef INIT_FAILURE_ALLOC
+#define INIT_FAILURE_ALLOC 5
+#endif
+
+/* Roughly the maximum number of failure points on the stack.  Would be
+   exactly that if always used MAX_FAILURE_SPACE each time we failed.
+   This is a variable only so users of regex can assign to it; we never
+   change it ourselves.  */
+int re_max_failures = 2000;
+
+typedef const unsigned char *fail_stack_elt_t;
+
+typedef struct
+{
+  fail_stack_elt_t *stack;
+  unsigned size;
+  unsigned avail;			/* Offset of next open position.  */
+} fail_stack_type;
+
+#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
+#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
+#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
+#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
+
+
+/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
+
+#define INIT_FAIL_STACK()						\
+  do {									\
+    fail_stack.stack = (fail_stack_elt_t *)				\
+      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
+									\
+    if (fail_stack.stack == NULL)					\
+      return -2;							\
+									\
+    fail_stack.size = INIT_FAILURE_ALLOC;				\
+    fail_stack.avail = 0;						\
+  } while (0)
+
+
+/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
+
+   Return 1 if succeeds, and 0 if either ran out of memory
+   allocating space for it or it was already too large.
+
+   REGEX_REALLOCATE requires `destination' be declared.   */
+
+#define DOUBLE_FAIL_STACK(fail_stack)					\
+  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
+   ? 0									\
+   : ((fail_stack).stack = (fail_stack_elt_t *)				\
+        REGEX_REALLOCATE ((fail_stack).stack, 				\
+          (fail_stack).size * sizeof (fail_stack_elt_t),		\
+          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
+									\
+      (fail_stack).stack == NULL					\
+      ? 0								\
+      : ((fail_stack).size <<= 1, 					\
+         1)))
+
+
+/* Push PATTERN_OP on FAIL_STACK.
+
+   Return 1 if was able to do so and 0 if ran out of memory allocating
+   space to do so.  */
+#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
+  ((FAIL_STACK_FULL ()							\
+    && !DOUBLE_FAIL_STACK (fail_stack))					\
+    ? 0									\
+    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
+       1))
+
+/* This pushes an item onto the failure stack.  Must be a four-byte
+   value.  Assumes the variable `fail_stack'.  Probably should only
+   be called from within `PUSH_FAILURE_POINT'.  */
+#define PUSH_FAILURE_ITEM(item)						\
+  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
+
+/* The complement operation.  Assumes `fail_stack' is nonempty.  */
+#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
+
+/* Used to omit pushing failure point id's when we're not debugging.  */
+#ifdef DEBUG
+#define DEBUG_PUSH PUSH_FAILURE_ITEM
+#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
+#else
+#define DEBUG_PUSH(item)
+#define DEBUG_POP(item_addr)
+#endif
+
+
+/* Push the information about the state we will need
+   if we ever fail back to it.
+
+   Requires variables fail_stack, regstart, regend, reg_info, and
+   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
+   declared.
+
+   Does `return FAILURE_CODE' if runs out of memory.  */
+
+#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
+  do {									\
+    char *destination;							\
+    /* Must be int, so when we don't save any registers, the arithmetic	\
+       of 0 + -1 isn't done as unsigned.  */				\
+    int this_reg;							\
+    									\
+    DEBUG_STATEMENT (failure_id++);					\
+    DEBUG_STATEMENT (nfailure_points_pushed++);				\
+    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
+    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
+    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
+									\
+    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
+    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
+									\
+    /* Ensure we have enough space allocated for what we will push.  */	\
+    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
+      {									\
+        if (!DOUBLE_FAIL_STACK (fail_stack))			\
+          return failure_code;						\
+									\
+        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
+		       (fail_stack).size);				\
+        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
+      }									\
+									\
+    /* Push the info, starting with the registers.  */			\
+    DEBUG_PRINT1 ("\n");						\
+									\
+    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
+         this_reg++)							\
+      {									\
+	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
+        DEBUG_STATEMENT (num_regs_pushed++);				\
+									\
+	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
+        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
+                                                                        \
+	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
+        PUSH_FAILURE_ITEM (regend[this_reg]);				\
+									\
+	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
+        DEBUG_PRINT2 (" match_null=%d",					\
+                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
+        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
+        DEBUG_PRINT2 (" matched_something=%d",				\
+                      MATCHED_SOMETHING (reg_info[this_reg]));		\
+        DEBUG_PRINT2 (" ever_matched=%d",				\
+                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
+	DEBUG_PRINT1 ("\n");						\
+        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
+      }									\
+									\
+    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
+    PUSH_FAILURE_ITEM (lowest_active_reg);				\
+									\
+    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
+    PUSH_FAILURE_ITEM (highest_active_reg);				\
+									\
+    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
+    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
+    PUSH_FAILURE_ITEM (pattern_place);					\
+									\
+    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
+    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
+				 size2);				\
+    DEBUG_PRINT1 ("'\n");						\
+    PUSH_FAILURE_ITEM (string_place);					\
+									\
+    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
+    DEBUG_PUSH (failure_id);						\
+  } while (0)
+
+/* This is the number of items that are pushed and popped on the stack
+   for each register.  */
+#define NUM_REG_ITEMS  3
+
+/* Individual items aside from the registers.  */
+#ifdef DEBUG
+#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
+#else
+#define NUM_NONREG_ITEMS 4
+#endif
+
+/* We push at most this many items on the stack.  */
+#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
+
+/* We actually push this many items.  */
+#define NUM_FAILURE_ITEMS						\
+  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
+    + NUM_NONREG_ITEMS)
+
+/* How many items can still be added to the stack without overflowing it.  */
+#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
+
+
+/* Pops what PUSH_FAIL_STACK pushes.
+
+   We restore into the parameters, all of which should be lvalues:
+     STR -- the saved data position.
+     PAT -- the saved pattern position.
+     LOW_REG, HIGH_REG -- the highest and lowest active registers.
+     REGSTART, REGEND -- arrays of string positions.
+     REG_INFO -- array of information about each subexpression.
+
+   Also assumes the variables `fail_stack' and (if debugging), `bufp',
+   `pend', `string1', `size1', `string2', and `size2'.  */
+
+#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
+{									\
+  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
+  int this_reg;								\
+  const unsigned char *string_temp;					\
+									\
+  assert (!FAIL_STACK_EMPTY ());					\
+									\
+  /* Remove failure points and point to how many regs pushed.  */	\
+  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
+  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
+  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
+									\
+  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
+									\
+  DEBUG_POP (&failure_id);						\
+  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
+									\
+  /* If the saved string location is NULL, it came from an		\
+     on_failure_keep_string_jump opcode, and we want to throw away the	\
+     saved NULL, thus retaining our current position in the string.  */	\
+  string_temp = POP_FAILURE_ITEM ();					\
+  if (string_temp != NULL)						\
+    str = (const char *) string_temp;					\
+									\
+  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
+  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
+  DEBUG_PRINT1 ("'\n");							\
+									\
+  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
+  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
+  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
+									\
+  /* Restore register info.  */						\
+  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
+  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
+									\
+  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
+  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
+									\
+  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
+    {									\
+      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
+									\
+      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
+      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
+									\
+      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
+      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
+									\
+      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
+      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
+    }									\
+									\
+  DEBUG_STATEMENT (nfailure_points_popped++);				\
+} /* POP_FAILURE_POINT */
+
+/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
+   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
+   characters can start a string that matches the pattern.  This fastmap
+   is used by re_search to skip quickly over impossible starting points.
+
+   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
+   area as BUFP->fastmap.
+
+   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
+   the pattern buffer.
+
+   Returns 0 if we succeed, -2 if an internal error.   */
+
+int re_compile_fastmap(struct re_pattern_buffer *bufp)
+{
+  int j, k;
+  fail_stack_type fail_stack;
+#ifndef REGEX_MALLOC
+  char *destination;
+#endif
+  /* We don't push any register information onto the failure stack.  */
+  unsigned num_regs = 0;
+
+  register char *fastmap = bufp->fastmap;
+  unsigned char *pattern = bufp->buffer;
+  unsigned long size = bufp->used;
+  const unsigned char *p = pattern;
+  register unsigned char *pend = pattern + size;
+
+  /* Assume that each path through the pattern can be null until
+     proven otherwise.  We set this false at the bottom of switch
+     statement, to which we get only if a particular path doesn't
+     match the empty string.  */
+  boolean path_can_be_null = true;
+
+  /* We aren't doing a `succeed_n' to begin with.  */
+  boolean succeed_n_p = false;
+
+  assert (fastmap != NULL && p != NULL);
+
+  INIT_FAIL_STACK ();
+  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
+  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
+  bufp->can_be_null = 0;
+
+  while (p != pend || !FAIL_STACK_EMPTY ())
+    {
+      if (p == pend)
+        {
+          bufp->can_be_null |= path_can_be_null;
+
+          /* Reset for next path.  */
+          path_can_be_null = true;
+
+          p = fail_stack.stack[--fail_stack.avail];
+	}
+
+      /* We should never be about to go beyond the end of the pattern.  */
+      assert (p < pend);
+
+#ifdef SWITCH_ENUM_BUG
+      switch ((int) ((re_opcode_t) *p++))
+#else
+      switch ((re_opcode_t) *p++)
+#endif
+	{
+
+        /* I guess the idea here is to simply not bother with a fastmap
+           if a backreference is used, since it's too hard to figure out
+           the fastmap for the corresponding group.  Setting
+           `can_be_null' stops `re_search_2' from using the fastmap, so
+           that is all we do.  */
+	case duplicate:
+	  bufp->can_be_null = 1;
+          return 0;
+
+
+      /* Following are the cases which match a character.  These end
+         with `break'.  */
+
+	case exactn:
+          fastmap[p[1]] = 1;
+	  break;
+
+
+        case charset:
+          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
+	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
+              fastmap[j] = 1;
+	  break;
+
+
+	case charset_not:
+	  /* Chars beyond end of map must be allowed.  */
+	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
+            fastmap[j] = 1;
+
+	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
+	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
+              fastmap[j] = 1;
+          break;
+
+
+	case wordchar:
+	  for (j = 0; j < (1 << BYTEWIDTH); j++)
+	    if (SYNTAX (j) == Sword)
+	      fastmap[j] = 1;
+	  break;
+
+
+	case notwordchar:
+	  for (j = 0; j < (1 << BYTEWIDTH); j++)
+	    if (SYNTAX (j) != Sword)
+	      fastmap[j] = 1;
+	  break;
+
+
+        case anychar:
+          /* `.' matches anything ...  */
+	  for (j = 0; j < (1 << BYTEWIDTH); j++)
+            fastmap[j] = 1;
+
+          /* ... except perhaps newline.  */
+          if (!(bufp->syntax & RE_DOT_NEWLINE))
+            fastmap['\n'] = 0;
+
+          /* Return if we have already set `can_be_null'; if we have,
+             then the fastmap is irrelevant.  Something's wrong here.  */
+	  else if (bufp->can_be_null)
+	    return 0;
+
+          /* Otherwise, have to check alternative paths.  */
+	  break;
+
+
+#ifdef emacs
+        case syntaxspec:
+	  k = *p++;
+	  for (j = 0; j < (1 << BYTEWIDTH); j++)
+	    if (SYNTAX (j) == (enum syntaxcode) k)
+	      fastmap[j] = 1;
+	  break;
+
+
+	case notsyntaxspec:
+	  k = *p++;
+	  for (j = 0; j < (1 << BYTEWIDTH); j++)
+	    if (SYNTAX (j) != (enum syntaxcode) k)
+	      fastmap[j] = 1;
+	  break;
+
+
+      /* All cases after this match the empty string.  These end with
+         `continue'.  */
+
+
+	case before_dot:
+	case at_dot:
+	case after_dot:
+          continue;
+#endif /* not emacs */
+
+
+        case no_op:
+        case begline:
+        case endline:
+	case begbuf:
+	case endbuf:
+	case wordbound:
+	case notwordbound:
+	case wordbeg:
+	case wordend:
+        case push_dummy_failure:
+          continue;
+
+
+	case jump_n:
+        case pop_failure_jump:
+	case maybe_pop_jump:
+	case jump:
+        case jump_past_alt:
+	case dummy_failure_jump:
+          EXTRACT_NUMBER_AND_INCR (j, p);
+	  p += j;
+	  if (j > 0)
+	    continue;
+
+          /* Jump backward implies we just went through the body of a
+             loop and matched nothing.  Opcode jumped to should be
+             `on_failure_jump' or `succeed_n'.  Just treat it like an
+             ordinary jump.  For a * loop, it has pushed its failure
+             point already; if so, discard that as redundant.  */
+          if ((re_opcode_t) *p != on_failure_jump
+	      && (re_opcode_t) *p != succeed_n)
+	    continue;
+
+          p++;
+          EXTRACT_NUMBER_AND_INCR (j, p);
+          p += j;
+
+          /* If what's on the stack is where we are now, pop it.  */
+          if (!FAIL_STACK_EMPTY ()
+	      && fail_stack.stack[fail_stack.avail - 1] == p)
+            fail_stack.avail--;
+
+          continue;
+
+
+        case on_failure_jump:
+        case on_failure_keep_string_jump:
+	handle_on_failure_jump:
+          EXTRACT_NUMBER_AND_INCR (j, p);
+
+          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
+             end of the pattern.  We don't want to push such a point,
+             since when we restore it above, entering the switch will
+             increment `p' past the end of the pattern.  We don't need
+             to push such a point since we obviously won't find any more
+             fastmap entries beyond `pend'.  Such a pattern can match
+             the null string, though.  */
+          if (p + j < pend)
+            {
+              if (!PUSH_PATTERN_OP (p + j, fail_stack))
+                return -2;
+            }
+          else
+            bufp->can_be_null = 1;
+
+          if (succeed_n_p)
+            {
+              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
+              succeed_n_p = false;
+	    }
+
+          continue;
+
+
+	case succeed_n:
+          /* Get to the number of times to succeed.  */
+          p += 2;
+
+          /* Increment p past the n for when k != 0.  */
+          EXTRACT_NUMBER_AND_INCR (k, p);
+          if (k == 0)
+	    {
+              p -= 4;
+  	      succeed_n_p = true;  /* Spaghetti code alert.  */
+              goto handle_on_failure_jump;
+            }
+          continue;
+
+
+	case set_number_at:
+          p += 4;
+          continue;
+
+
+	case start_memory:
+        case stop_memory:
+	  p += 2;
+	  continue;
+
+
+	default:
+          abort (); /* We have listed all the cases.  */
+        } /* switch *p++ */
+
+      /* Getting here means we have found the possible starting
+         characters for one path of the pattern -- and that the empty
+         string does not match.  We need not follow this path further.
+         Instead, look at the next alternative (remembered on the
+         stack), or quit if no more.  The test at the top of the loop
+         does these things.  */
+      path_can_be_null = false;
+      p = pend;
+    } /* while p */
+
+  /* Set `can_be_null' for the last path (also the first path, if the
+     pattern is empty).  */
+  bufp->can_be_null |= path_can_be_null;
+  return 0;
+} /* re_compile_fastmap */
+
+/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
+   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
+   this memory for recording register information.  STARTS and ENDS
+   must be allocated using the malloc library routine, and must each
+   be at least NUM_REGS * sizeof (regoff_t) bytes long.
+
+   If NUM_REGS == 0, then subsequent matches should allocate their own
+   register data.
+
+   Unless this function is called, the first search or match using
+   PATTERN_BUFFER will allocate its own register data, without
+   freeing the old data.  */
+
+void re_set_registers(struct re_pattern_buffer *bufp,
+                      struct re_registers *regs,
+                      unsigned num_regs,
+                      regoff_t *starts,
+                      regoff_t *ends)
+{
+  if (num_regs)
+    {
+      bufp->regs_allocated = REGS_REALLOCATE;
+      regs->num_regs = num_regs;
+      regs->start = starts;
+      regs->end = ends;
+    }
+  else
+    {
+      bufp->regs_allocated = REGS_UNALLOCATED;
+      regs->num_regs = 0;
+      regs->start = regs->end = (regoff_t) 0;
+    }
+}
+
+/* Searching routines.  */
+
+/* Like re_search_2, below, but only one string is specified, and
+   doesn't let you say where to stop matching. */
+
+int re_search(struct re_pattern_buffer *bufp,
+              const char *string,
+              int size,
+              int startpos,
+              int range,
+              struct re_registers *regs)
+{
+  return re_search_2(bufp, NULL, 0, string, size, startpos, range, regs, size);
+}
+
+
+/* Using the compiled pattern in BUFP->buffer, first tries to match the
+   virtual concatenation of STRING1 and STRING2, starting first at index
+   STARTPOS, then at STARTPOS + 1, and so on.
+
+   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
+
+   RANGE is how far to scan while trying to match.  RANGE = 0 means try
+   only at STARTPOS; in general, the last start tried is STARTPOS +
+   RANGE.
+
+   In REGS, return the indices of the virtual concatenation of STRING1
+   and STRING2 that matched the entire BUFP->buffer and its contained
+   subexpressions.
+
+   Do not consider matching one past the index STOP in the virtual
+   concatenation of STRING1 and STRING2.
+
+   We return either the position in the strings at which the match was
+   found, -1 if no match, or -2 if error (such as failure
+   stack overflow).  */
+
+int re_search_2(struct re_pattern_buffer *bufp,
+                const char *string1,
+                const char *string2,
+                int size1,
+                int size2,
+                int startpos,
+                int range,
+                struct re_registers *regs,
+                int stop)
+{
+  int val;
+  register char *fastmap = bufp->fastmap;
+  register char *translate = bufp->translate;
+  int total_size = size1 + size2;
+  int endpos = startpos + range;
+
+  /* Check for out-of-range STARTPOS.  */
+  if (startpos < 0 || startpos > total_size)
+    return -1;
+
+  /* Fix up RANGE if it might eventually take us outside
+     the virtual concatenation of STRING1 and STRING2.  */
+  if (endpos < -1)
+    range = -1 - startpos;
+  else if (endpos > total_size)
+    range = total_size - startpos;
+
+  /* If the search isn't to be a backwards one, don't waste time in a
+     search for a pattern that must be anchored.  */
+  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
+    {
+      if (startpos > 0)
+	return -1;
+      else
+	range = 1;
+    }
+
+  /* Update the fastmap now if not correct already.  */
+  if (fastmap && !bufp->fastmap_accurate)
+    if (re_compile_fastmap (bufp) == -2)
+      return -2;
+
+  /* Loop through the string, looking for a place to start matching.  */
+  for (;;)
+    {
+      /* If a fastmap is supplied, skip quickly over characters that
+         cannot be the start of a match.  If the pattern can match the
+         null string, however, we don't need to skip characters; we want
+         the first null string.  */
+      if (fastmap && startpos < total_size && !bufp->can_be_null)
+	{
+	  if (range > 0)	/* Searching forwards.  */
+	    {
+	      register const char *d;
+	      register int lim = 0;
+	      int irange = range;
+
+              if (startpos < size1 && startpos + range >= size1)
+                lim = range - (size1 - startpos);
+
+	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
+
+              /* Written out as an if-else to avoid testing `translate'
+                 inside the loop.  */
+	      if (translate)
+                while (range > lim
+                       && !fastmap[(unsigned char)
+				   translate[(unsigned char) *d++]])
+                  range--;
+	      else
+                while (range > lim && !fastmap[(unsigned char) *d++])
+                  range--;
+
+	      startpos += irange - range;
+	    }
+	  else				/* Searching backwards.  */
+	    {
+	      register char c = (size1 == 0 || startpos >= size1
+                                 ? string2[startpos - size1]
+                                 : string1[startpos]);
+
+	      if (!fastmap[(unsigned char) TRANSLATE (c)])
+		goto advance;
+	    }
+	}
+
+      /* If can't match the null string, and that's all we have left, fail.  */
+      if (range >= 0 && startpos == total_size && fastmap
+          && !bufp->can_be_null)
+	return -1;
+
+      val = re_match_2 (bufp, string1, size1, string2, size2,
+	                startpos, regs, stop);
+      if (val >= 0)
+	return startpos;
+
+      if (val == -2)
+	return -2;
+
+    advance:
+      if (!range)
+        break;
+      else if (range > 0)
+        {
+          range--;
+          startpos++;
+        }
+      else
+        {
+          range++;
+          startpos--;
+        }
+    }
+  return -1;
+} /* re_search_2 */
+
+/* Declarations and macros for re_match_2.  */
+
+static int bcmp_translate ();
+static boolean alt_match_null_string_p (),
+               common_op_match_null_string_p (),
+               group_match_null_string_p ();
+
+/* Structure for per-register (a.k.a. per-group) information.
+   This must not be longer than one word, because we push this value
+   onto the failure stack.  Other register information, such as the
+   starting and ending positions (which are addresses), and the list of
+   inner groups (which is a bits list) are maintained in separate
+   variables.
+
+   We are making a (strictly speaking) nonportable assumption here: that
+   the compiler will pack our bit fields into something that fits into
+   the type of `word', i.e., is something that fits into one item on the
+   failure stack.  */
+typedef union
+{
+  fail_stack_elt_t word;
+  struct
+  {
+      /* This field is one if this group can match the empty string,
+         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
+#define MATCH_NULL_UNSET_VALUE 3
+    unsigned match_null_string_p : 2;
+    unsigned is_active : 1;
+    unsigned matched_something : 1;
+    unsigned ever_matched_something : 1;
+  } bits;
+} register_info_type;
+
+#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
+#define IS_ACTIVE(R)  ((R).bits.is_active)
+#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
+#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
+
+
+/* Call this when have matched a real character; it sets `matched' flags
+   for the subexpressions which we are currently inside.  Also records
+   that those subexprs have matched.  */
+#define SET_REGS_MATCHED()						\
+  do									\
+    {									\
+      unsigned r;							\
+      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
+        {								\
+          MATCHED_SOMETHING (reg_info[r])				\
+            = EVER_MATCHED_SOMETHING (reg_info[r])			\
+            = 1;							\
+        }								\
+    }									\
+  while (0)
+
+
+/* This converts PTR, a pointer into one of the search strings `string1'
+   and `string2' into an offset from the beginning of that string.  */
+#define POINTER_TO_OFFSET(ptr)						\
+  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
+
+/* Registers are set to a sentinel when they haven't yet matched.  */
+#define REG_UNSET_VALUE ((char *) -1)
+#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
+
+
+/* Macros for dealing with the split strings in re_match_2.  */
+
+#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
+
+/* Call before fetching a character with *d.  This switches over to
+   string2 if necessary.  */
+#define PREFETCH()							\
+  while (d == dend)						    	\
+    {									\
+      /* End of string2 => fail.  */					\
+      if (dend == end_match_2) 						\
+        goto fail;							\
+      /* End of string1 => advance to string2.  */ 			\
+      d = string2;						        \
+      dend = end_match_2;						\
+    }
+
+
+/* Test if at very beginning or at very end of the virtual concatenation
+   of `string1' and `string2'.  If only one string, it's `string2'.  */
+#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
+#define AT_STRINGS_END(d) ((d) == end2)
+
+
+/* Test if D points to a character which is word-constituent.  We have
+   two special cases to check for: if past the end of string1, look at
+   the first character in string2; and if before the beginning of
+   string2, look at the last character in string1.  */
+#define WORDCHAR_P(d)							\
+  (SYNTAX ((d) == end1 ? *string2					\
+           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
+   == Sword)
+
+/* Test if the character before D and the one at D differ with respect
+   to being word-constituent.  */
+#define AT_WORD_BOUNDARY(d)						\
+  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
+   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
+
+
+/* Free everything we malloc.  */
+#ifdef REGEX_MALLOC
+#define FREE_VAR(var) if (var) free (var); var = NULL
+#define FREE_VARIABLES()						\
+  do {									\
+    FREE_VAR (fail_stack.stack);					\
+    FREE_VAR (regstart);						\
+    FREE_VAR (regend);							\
+    FREE_VAR (old_regstart);						\
+    FREE_VAR (old_regend);						\
+    FREE_VAR (best_regstart);						\
+    FREE_VAR (best_regend);						\
+    FREE_VAR (reg_info);						\
+    FREE_VAR (reg_dummy);						\
+    FREE_VAR (reg_info_dummy);						\
+  } while (0)
+#else /* not REGEX_MALLOC */
+/* Some MIPS systems (at least) want this to free alloca'd storage.  */
+#define FREE_VARIABLES() alloca (0)
+#endif /* not REGEX_MALLOC */
+
+
+/* These values must meet several constraints.  They must not be valid
+   register values; since we have a limit of 255 registers (because
+   we use only one byte in the pattern for the register number), we can
+   use numbers larger than 255.  They must differ by 1, because of
+   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
+   be larger than the value for the highest register, so we do not try
+   to actually save any registers when none are active.  */
+#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
+#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
+
+/* Matching routines.  */
+
+#ifndef emacs   /* Emacs never uses this.  */
+/* re_match is like re_match_2 except it takes only a single string.  */
+
+int re_match(struct re_pattern_buffer *bufp,
+             const char *string,
+             int size,
+             int pos,
+             struct re_registers *regs)
+ {
+  return re_match_2(bufp, NULL, 0, string, size, pos, regs, size);
+}
+#endif /* not emacs */
+
+
+/* re_match_2 matches the compiled pattern in BUFP against the
+   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
+   and SIZE2, respectively).  We start matching at POS, and stop
+   matching at STOP.
+
+   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
+   store offsets for the substring each group matched in REGS.  See the
+   documentation for exactly how many groups we fill.
+
+   We return -1 if no match, -2 if an internal error (such as the
+   failure stack overflowing).  Otherwise, we return the length of the
+   matched substring.  */
+
+int re_match_2(struct re_pattern_buffer *bufp,
+               const char *string1,
+               const char *string2,
+               int size1,
+               int size2,
+               int pos,
+               struct re_registers *regs,
+               int stop)
+{
+  /* General temporaries.  */
+  int mcnt;
+  unsigned char *p1;
+
+  /* Just past the end of the corresponding string.  */
+  const char *end1, *end2;
+
+  /* Pointers into string1 and string2, just past the last characters in
+     each to consider matching.  */
+  const char *end_match_1, *end_match_2;
+
+  /* Where we are in the data, and the end of the current string.  */
+  const char *d, *dend;
+
+  /* Where we are in the pattern, and the end of the pattern.  */
+  unsigned char *p = bufp->buffer;
+  register unsigned char *pend = p + bufp->used;
+
+  /* We use this to map every character in the string.  */
+  char *translate = bufp->translate;
+
+  /* Failure point stack.  Each place that can handle a failure further
+     down the line pushes a failure point on this stack.  It consists of
+     restart, regend, and reg_info for all registers corresponding to
+     the subexpressions we're currently inside, plus the number of such
+     registers, and, finally, two char *'s.  The first char * is where
+     to resume scanning the pattern; the second one is where to resume
+     scanning the strings.  If the latter is zero, the failure point is
+     a ``dummy''; if a failure happens and the failure point is a dummy,
+     it gets discarded and the next next one is tried.  */
+  fail_stack_type fail_stack;
+#ifdef DEBUG
+  static unsigned failure_id = 0;
+  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
+#endif
+
+  /* We fill all the registers internally, independent of what we
+     return, for use in backreferences.  The number here includes
+     an element for register zero.  */
+  unsigned num_regs = bufp->re_nsub + 1;
+
+  /* The currently active registers.  */
+  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
+  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
+
+  /* Information on the contents of registers. These are pointers into
+     the input strings; they record just what was matched (on this
+     attempt) by a subexpression part of the pattern, that is, the
+     regnum-th regstart pointer points to where in the pattern we began
+     matching and the regnum-th regend points to right after where we
+     stopped matching the regnum-th subexpression.  (The zeroth register
+     keeps track of what the whole pattern matches.)  */
+  const char **regstart, **regend;
+
+  /* If a group that's operated upon by a repetition operator fails to
+     match anything, then the register for its start will need to be
+     restored because it will have been set to wherever in the string we
+     are when we last see its open-group operator.  Similarly for a
+     register's end.  */
+  const char **old_regstart, **old_regend;
+
+  /* The is_active field of reg_info helps us keep track of which (possibly
+     nested) subexpressions we are currently in. The matched_something
+     field of reg_info[reg_num] helps us tell whether or not we have
+     matched any of the pattern so far this time through the reg_num-th
+     subexpression.  These two fields get reset each time through any
+     loop their register is in.  */
+  register_info_type *reg_info;
+
+  /* The following record the register info as found in the above
+     variables when we find a match better than any we've seen before.
+     This happens as we backtrack through the failure points, which in
+     turn happens only if we have not yet matched the entire string. */
+  unsigned best_regs_set = false;
+  const char **best_regstart, **best_regend;
+
+  /* Logically, this is `best_regend[0]'.  But we don't want to have to
+     allocate space for that if we're not allocating space for anything
+     else (see below).  Also, we never need info about register 0 for
+     any of the other register vectors, and it seems rather a kludge to
+     treat `best_regend' differently than the rest.  So we keep track of
+     the end of the best match so far in a separate variable.  We
+     initialize this to NULL so that when we backtrack the first time
+     and need to test it, it's not garbage.  */
+  const char *match_end = NULL;
+
+  /* Used when we pop values we don't care about.  */
+  const char **reg_dummy;
+  register_info_type *reg_info_dummy;
+
+#ifdef DEBUG
+  /* Counts the total number of registers pushed.  */
+  unsigned num_regs_pushed = 0;
+#endif
+
+  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
+
+  INIT_FAIL_STACK ();
+
+  /* Do not bother to initialize all the register variables if there are
+     no groups in the pattern, as it takes a fair amount of time.  If
+     there are groups, we include space for register 0 (the whole
+     pattern), even though we never use it, since it simplifies the
+     array indexing.  We should fix this.  */
+  if (bufp->re_nsub)
+    {
+      regstart = REGEX_TALLOC (num_regs, const char *);
+      regend = REGEX_TALLOC (num_regs, const char *);
+      old_regstart = REGEX_TALLOC (num_regs, const char *);
+      old_regend = REGEX_TALLOC (num_regs, const char *);
+      best_regstart = REGEX_TALLOC (num_regs, const char *);
+      best_regend = REGEX_TALLOC (num_regs, const char *);
+      reg_info = REGEX_TALLOC (num_regs, register_info_type);
+      reg_dummy = REGEX_TALLOC (num_regs, const char *);
+      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
+
+      if (!(regstart && regend && old_regstart && old_regend && reg_info
+            && best_regstart && best_regend && reg_dummy && reg_info_dummy))
+        {
+          FREE_VARIABLES ();
+          return -2;
+        }
+    }
+#ifdef REGEX_MALLOC
+  else
+    {
+      /* We must initialize all our variables to NULL, so that
+         `FREE_VARIABLES' doesn't try to free them.  */
+      regstart = regend = old_regstart = old_regend = best_regstart
+        = best_regend = reg_dummy = NULL;
+      reg_info = reg_info_dummy = (register_info_type *) NULL;
+    }
+#endif /* REGEX_MALLOC */
+
+  /* The starting position is bogus.  */
+  if (pos < 0 || pos > size1 + size2)
+    {
+      FREE_VARIABLES ();
+      return -1;
+    }
+
+  /* Initialize subexpression text positions to -1 to mark ones that no
+     start_memory/stop_memory has been seen for. Also initialize the
+     register information struct.  */
+  for (mcnt = 1; mcnt < num_regs; mcnt++)
+    {
+      regstart[mcnt] = regend[mcnt]
+        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
+
+      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
+      IS_ACTIVE (reg_info[mcnt]) = 0;
+      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
+      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
+    }
+
+  /* We move `string1' into `string2' if the latter's empty -- but not if
+     `string1' is null.  */
+  if (size2 == 0 && string1 != NULL)
+    {
+      string2 = string1;
+      size2 = size1;
+      string1 = 0;
+      size1 = 0;
+    }
+  end1 = string1 + size1;
+  end2 = string2 + size2;
+
+  /* Compute where to stop matching, within the two strings.  */
+  if (stop <= size1)
+    {
+      end_match_1 = string1 + stop;
+      end_match_2 = string2;
+    }
+  else
+    {
+      end_match_1 = end1;
+      end_match_2 = string2 + stop - size1;
+    }
+
+  /* `p' scans through the pattern as `d' scans through the data.
+     `dend' is the end of the input string that `d' points within.  `d'
+     is advanced into the following input string whenever necessary, but
+     this happens before fetching; therefore, at the beginning of the
+     loop, `d' can be pointing at the end of a string, but it cannot
+     equal `string2'.  */
+  if (size1 > 0 && pos <= size1)
+    {
+      d = string1 + pos;
+      dend = end_match_1;
+    }
+  else
+    {
+      d = string2 + pos - size1;
+      dend = end_match_2;
+    }
+
+  DEBUG_PRINT1 ("The compiled pattern is: ");
+  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
+  DEBUG_PRINT1 ("The string to match is: `");
+  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
+  DEBUG_PRINT1 ("'\n");
+
+  /* This loops over pattern commands.  It exits by returning from the
+     function if the match is complete, or it drops through if the match
+     fails at this starting point in the input data.  */
+  for (;;)
+    {
+      DEBUG_PRINT2 ("\n0x%x: ", p);
+
+      if (p == pend)
+	{ /* End of pattern means we might have succeeded.  */
+          DEBUG_PRINT1 ("end of pattern ... ");
+
+	  /* If we haven't matched the entire string, and we want the
+             longest match, try backtracking.  */
+          if (d != end_match_2)
+	    {
+              DEBUG_PRINT1 ("backtracking.\n");
+
+              if (!FAIL_STACK_EMPTY ())
+                { /* More failure points to try.  */
+                  boolean same_str_p = (FIRST_STRING_P (match_end)
+	        	                == MATCHING_IN_FIRST_STRING);
+
+                  /* If exceeds best match so far, save it.  */
+                  if (!best_regs_set
+                      || (same_str_p && d > match_end)
+                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))
+                    {
+                      best_regs_set = true;
+                      match_end = d;
+
+                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
+
+                      for (mcnt = 1; mcnt < num_regs; mcnt++)
+                        {
+                          best_regstart[mcnt] = regstart[mcnt];
+                          best_regend[mcnt] = regend[mcnt];
+                        }
+                    }
+                  goto fail;
+                }
+
+              /* If no failure points, don't restore garbage.  */
+              else if (best_regs_set)
+                {
+  	        restore_best_regs:
+                  /* Restore best match.  It may happen that `dend ==
+                     end_match_1' while the restored d is in string2.
+                     For example, the pattern `x.*y.*z' against the
+                     strings `x-' and `y-z-', if the two strings are
+                     not consecutive in memory.  */
+                  DEBUG_PRINT1 ("Restoring best registers.\n");
+
+                  d = match_end;
+                  dend = ((d >= string1 && d <= end1)
+		           ? end_match_1 : end_match_2);
+
+		  for (mcnt = 1; mcnt < num_regs; mcnt++)
+		    {
+		      regstart[mcnt] = best_regstart[mcnt];
+		      regend[mcnt] = best_regend[mcnt];
+		    }
+                }
+            } /* d != end_match_2 */
+
+          DEBUG_PRINT1 ("Accepting match.\n");
+
+          /* If caller wants register contents data back, do it.  */
+          if (regs && !bufp->no_sub)
+	    {
+              /* Have the register data arrays been allocated?  */
+              if (bufp->regs_allocated == REGS_UNALLOCATED)
+                { /* No.  So allocate them with malloc.  We need one
+                     extra element beyond `num_regs' for the `-1' marker
+                     GNU code uses.  */
+                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
+                  regs->start = TALLOC (regs->num_regs, regoff_t);
+                  regs->end = TALLOC (regs->num_regs, regoff_t);
+                  if (regs->start == NULL || regs->end == NULL)
+                    return -2;
+                  bufp->regs_allocated = REGS_REALLOCATE;
+                }
+              else if (bufp->regs_allocated == REGS_REALLOCATE)
+                { /* Yes.  If we need more elements than were already
+                     allocated, reallocate them.  If we need fewer, just
+                     leave it alone.  */
+                  if (regs->num_regs < num_regs + 1)
+                    {
+                      regs->num_regs = num_regs + 1;
+                      RETALLOC (regs->start, regs->num_regs, regoff_t);
+                      RETALLOC (regs->end, regs->num_regs, regoff_t);
+                      if (regs->start == NULL || regs->end == NULL)
+                        return -2;
+                    }
+                }
+              else
+                assert (bufp->regs_allocated == REGS_FIXED);
+
+              /* Convert the pointer data in `regstart' and `regend' to
+                 indices.  Register zero has to be set differently,
+                 since we haven't kept track of any info for it.  */
+              if (regs->num_regs > 0)
+                {
+                  regs->start[0] = pos;
+                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
+			          : d - string2 + size1);
+                }
+
+              /* Go through the first `min (num_regs, regs->num_regs)'
+                 registers, since that is all we initialized.  */
+	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
+		{
+                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
+                    regs->start[mcnt] = regs->end[mcnt] = -1;
+                  else
+                    {
+		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
+                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
+                    }
+		}
+
+              /* If the regs structure we return has more elements than
+                 were in the pattern, set the extra elements to -1.  If
+                 we (re)allocated the registers, this is the case,
+                 because we always allocate enough to have at least one
+                 -1 at the end.  */
+              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
+                regs->start[mcnt] = regs->end[mcnt] = -1;
+	    } /* regs && !bufp->no_sub */
+
+          FREE_VARIABLES ();
+          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
+                        nfailure_points_pushed, nfailure_points_popped,
+                        nfailure_points_pushed - nfailure_points_popped);
+          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
+
+          mcnt = d - pos - (MATCHING_IN_FIRST_STRING
+			    ? string1
+			    : string2 - size1);
+
+          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
+
+          return mcnt;
+        }
+
+      /* Otherwise match next pattern command.  */
+#ifdef SWITCH_ENUM_BUG
+      switch ((int) ((re_opcode_t) *p++))
+#else
+      switch ((re_opcode_t) *p++)
+#endif
+	{
+        /* Ignore these.  Used to ignore the n of succeed_n's which
+           currently have n == 0.  */
+        case no_op:
+          DEBUG_PRINT1 ("EXECUTING no_op.\n");
+          break;
+
+
+        /* Match the next n pattern characters exactly.  The following
+           byte in the pattern defines n, and the n bytes after that
+           are the characters to match.  */
+	case exactn:
+	  mcnt = *p++;
+          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
+
+          /* This is written out as an if-else so we don't waste time
+             testing `translate' inside the loop.  */
+          if (translate)
+	    {
+	      do
+		{
+		  PREFETCH ();
+		  if (translate[(unsigned char) *d++] != (char) *p++)
+                    goto fail;
+		}
+	      while (--mcnt);
+	    }
+	  else
+	    {
+	      do
+		{
+		  PREFETCH ();
+		  if (*d++ != (char) *p++) goto fail;
+		}
+	      while (--mcnt);
+	    }
+	  SET_REGS_MATCHED ();
+          break;
+
+
+        /* Match any character except possibly a newline or a null.  */
+	case anychar:
+          DEBUG_PRINT1 ("EXECUTING anychar.\n");
+
+          PREFETCH ();
+
+          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
+              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
+	    goto fail;
+
+          SET_REGS_MATCHED ();
+          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
+          d++;
+	  break;
+
+
+	case charset:
+	case charset_not:
+	  {
+	    register unsigned char c;
+	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
+
+            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
+
+	    PREFETCH ();
+	    c = TRANSLATE (*d); /* The character to match.  */
+
+            /* Cast to `unsigned' instead of `unsigned char' in case the
+               bit list is a full 32 bytes long.  */
+	    if (c < (unsigned) (*p * BYTEWIDTH)
+		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
+	      not = !not;
+
+	    p += 1 + *p;
+
+	    if (!not) goto fail;
+
+	    SET_REGS_MATCHED ();
+            d++;
+	    break;
+	  }
+
+
+        /* The beginning of a group is represented by start_memory.
+           The arguments are the register number in the next byte, and the
+           number of groups inner to this one in the next.  The text
+           matched within the group is recorded (in the internal
+           registers data structure) under the register number.  */
+        case start_memory:
+	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
+
+          /* Find out if this group can match the empty string.  */
+	  p1 = p;		/* To send to group_match_null_string_p.  */
+
+          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
+            REG_MATCH_NULL_STRING_P (reg_info[*p])
+              = group_match_null_string_p (&p1, pend, reg_info);
+
+          /* Save the position in the string where we were the last time
+             we were at this open-group operator in case the group is
+             operated upon by a repetition operator, e.g., with `(a*)*b'
+             against `ab'; then we want to ignore where we are now in
+             the string in case this attempt to match fails.  */
+          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
+                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
+                             : regstart[*p];
+	  DEBUG_PRINT2 ("  old_regstart: %d\n",
+			 POINTER_TO_OFFSET (old_regstart[*p]));
+
+          regstart[*p] = d;
+	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
+
+          IS_ACTIVE (reg_info[*p]) = 1;
+          MATCHED_SOMETHING (reg_info[*p]) = 0;
+
+          /* This is the new highest active register.  */
+          highest_active_reg = *p;
+
+          /* If nothing was active before, this is the new lowest active
+             register.  */
+          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
+            lowest_active_reg = *p;
+
+          /* Move past the register number and inner group count.  */
+          p += 2;
+          break;
+
+
+        /* The stop_memory opcode represents the end of a group.  Its
+           arguments are the same as start_memory's: the register
+           number, and the number of inner groups.  */
+	case stop_memory:
+	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
+
+          /* We need to save the string position the last time we were at
+             this close-group operator in case the group is operated
+             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
+             against `aba'; then we want to ignore where we are now in
+             the string in case this attempt to match fails.  */
+          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
+                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
+			   : regend[*p];
+	  DEBUG_PRINT2 ("      old_regend: %d\n",
+			 POINTER_TO_OFFSET (old_regend[*p]));
+
+          regend[*p] = d;
+	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
+
+          /* This register isn't active anymore.  */
+          IS_ACTIVE (reg_info[*p]) = 0;
+
+          /* If this was the only register active, nothing is active
+             anymore.  */
+          if (lowest_active_reg == highest_active_reg)
+            {
+              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
+              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
+            }
+          else
+            { /* We must scan for the new highest active register, since
+                 it isn't necessarily one less than now: consider
+                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
+                 new highest active register is 1.  */
+              unsigned char r = *p - 1;
+              while (r > 0 && !IS_ACTIVE (reg_info[r]))
+                r--;
+
+              /* If we end up at register zero, that means that we saved
+                 the registers as the result of an `on_failure_jump', not
+                 a `start_memory', and we jumped to past the innermost
+                 `stop_memory'.  For example, in ((.)*) we save
+                 registers 1 and 2 as a result of the *, but when we pop
+                 back to the second ), we are at the stop_memory 1.
+                 Thus, nothing is active.  */
+	      if (r == 0)
+                {
+                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
+                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
+                }
+              else
+                highest_active_reg = r;
+            }
+
+          /* If just failed to match something this time around with a
+             group that's operated on by a repetition operator, try to
+             force exit from the ``loop'', and restore the register
+             information for this group that we had before trying this
+             last match.  */
+          if ((!MATCHED_SOMETHING (reg_info[*p])
+               || (re_opcode_t) p[-3] == start_memory)
+	      && (p + 2) < pend)
+            {
+              boolean is_a_jump_n = false;
+
+              p1 = p + 2;
+              mcnt = 0;
+              switch ((re_opcode_t) *p1++)
+                {
+                  case jump_n:
+		    is_a_jump_n = true;
+                  case pop_failure_jump:
+		  case maybe_pop_jump:
+		  case jump:
+		  case dummy_failure_jump:
+                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+		    if (is_a_jump_n)
+		      p1 += 2;
+                    break;
+
+                  default:
+                    /* do nothing */ ;
+                }
+	      p1 += mcnt;
+
+              /* If the next operation is a jump backwards in the pattern
+	         to an on_failure_jump right before the start_memory
+                 corresponding to this stop_memory, exit from the loop
+                 by forcing a failure after pushing on the stack the
+                 on_failure_jump's jump in the pattern, and d.  */
+              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
+                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
+		{
+                  /* If this group ever matched anything, then restore
+                     what its registers were before trying this last
+                     failed match, e.g., with `(a*)*b' against `ab' for
+                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
+                     against `aba' for regend[3].
+
+                     Also restore the registers for inner groups for,
+                     e.g., `((a*)(b*))*' against `aba' (register 3 would
+                     otherwise get trashed).  */
+
+                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
+		    {
+		      unsigned r;
+
+                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
+
+		      /* Restore this and inner groups' (if any) registers.  */
+                      for (r = *p; r < *p + *(p + 1); r++)
+                        {
+                          regstart[r] = old_regstart[r];
+
+                          /* xx why this test?  */
+                          if ((int) old_regend[r] >= (int) regstart[r])
+                            regend[r] = old_regend[r];
+                        }
+                    }
+		  p1++;
+                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
+
+                  goto fail;
+                }
+            }
+
+          /* Move past the register number and the inner group count.  */
+          p += 2;
+          break;
+
+
+	/* \<digit> has been turned into a `duplicate' command which is
+           followed by the numeric value of <digit> as the register number.  */
+        case duplicate:
+	  {
+	    register const char *d2, *dend2;
+	    int regno = *p++;   /* Get which register to match against.  */
+	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
+
+	    /* Can't back reference a group which we've never matched.  */
+            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
+              goto fail;
+
+            /* Where in input to try to start matching.  */
+            d2 = regstart[regno];
+
+            /* Where to stop matching; if both the place to start and
+               the place to stop matching are in the same string, then
+               set to the place to stop, otherwise, for now have to use
+               the end of the first string.  */
+
+            dend2 = ((FIRST_STRING_P (regstart[regno])
+		      == FIRST_STRING_P (regend[regno]))
+		     ? regend[regno] : end_match_1);
+	    for (;;)
+	      {
+		/* If necessary, advance to next segment in register
+                   contents.  */
+		while (d2 == dend2)
+		  {
+		    if (dend2 == end_match_2) break;
+		    if (dend2 == regend[regno]) break;
+
+                    /* End of string1 => advance to string2. */
+                    d2 = string2;
+                    dend2 = regend[regno];
+		  }
+		/* At end of register contents => success */
+		if (d2 == dend2) break;
+
+		/* If necessary, advance to next segment in data.  */
+		PREFETCH ();
+
+		/* How many characters left in this segment to match.  */
+		mcnt = dend - d;
+
+		/* Want how many consecutive characters we can match in
+                   one shot, so, if necessary, adjust the count.  */
+                if (mcnt > dend2 - d2)
+		  mcnt = dend2 - d2;
+
+		/* Compare that many; failure if mismatch, else move
+                   past them.  */
+		if (translate
+                    ? bcmp_translate (d, d2, mcnt, translate)
+                    : bcmp (d, d2, mcnt))
+		  goto fail;
+		d += mcnt, d2 += mcnt;
+	      }
+	  }
+	  break;
+
+
+        /* begline matches the empty string at the beginning of the string
+           (unless `not_bol' is set in `bufp'), and, if
+           `newline_anchor' is set, after newlines.  */
+	case begline:
+          DEBUG_PRINT1 ("EXECUTING begline.\n");
+
+          if (AT_STRINGS_BEG (d))
+            {
+              if (!bufp->not_bol) break;
+            }
+          else if (d[-1] == '\n' && bufp->newline_anchor)
+            {
+              break;
+            }
+          /* In all other cases, we fail.  */
+          goto fail;
+
+
+        /* endline is the dual of begline.  */
+	case endline:
+          DEBUG_PRINT1 ("EXECUTING endline.\n");
+
+          if (AT_STRINGS_END (d))
+            {
+              if (!bufp->not_eol) break;
+            }
+
+          /* We have to ``prefetch'' the next character.  */
+          else if ((d == end1 ? *string2 : *d) == '\n'
+                   && bufp->newline_anchor)
+            {
+              break;
+            }
+          goto fail;
+
+
+	/* Match at the very beginning of the data.  */
+        case begbuf:
+          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
+          if (AT_STRINGS_BEG (d))
+            break;
+          goto fail;
+
+
+	/* Match at the very end of the data.  */
+        case endbuf:
+          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
+	  if (AT_STRINGS_END (d))
+	    break;
+          goto fail;
+
+
+        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
+           pushes NULL as the value for the string on the stack.  Then
+           `pop_failure_point' will keep the current value for the
+           string, instead of restoring it.  To see why, consider
+           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
+           then the . fails against the \n.  But the next thing we want
+           to do is match the \n against the \n; if we restored the
+           string value, we would be back at the foo.
+
+           Because this is used only in specific cases, we don't need to
+           check all the things that `on_failure_jump' does, to make
+           sure the right things get saved on the stack.  Hence we don't
+           share its code.  The only reason to push anything on the
+           stack at all is that otherwise we would have to change
+           `anychar's code to do something besides goto fail in this
+           case; that seems worse than this.  */
+        case on_failure_keep_string_jump:
+          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
+
+          EXTRACT_NUMBER_AND_INCR (mcnt, p);
+          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
+
+          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
+          break;
+
+
+	/* Uses of on_failure_jump:
+
+           Each alternative starts with an on_failure_jump that points
+           to the beginning of the next alternative.  Each alternative
+           except the last ends with a jump that in effect jumps past
+           the rest of the alternatives.  (They really jump to the
+           ending jump of the following alternative, because tensioning
+           these jumps is a hassle.)
+
+           Repeats start with an on_failure_jump that points past both
+           the repetition text and either the following jump or
+           pop_failure_jump back to this on_failure_jump.  */
+	case on_failure_jump:
+        on_failure:
+          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
+
+          EXTRACT_NUMBER_AND_INCR (mcnt, p);
+          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
+
+          /* If this on_failure_jump comes right before a group (i.e.,
+             the original * applied to a group), save the information
+             for that group and all inner ones, so that if we fail back
+             to this point, the group's information will be correct.
+             For example, in \(a*\)*\1, we need the preceding group,
+             and in \(\(a*\)b*\)\2, we need the inner group.  */
+
+          /* We can't use `p' to check ahead because we push
+             a failure point to `p + mcnt' after we do this.  */
+          p1 = p;
+
+          /* We need to skip no_op's before we look for the
+             start_memory in case this on_failure_jump is happening as
+             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
+             against aba.  */
+          while (p1 < pend && (re_opcode_t) *p1 == no_op)
+            p1++;
+
+          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
+            {
+              /* We have a new highest active register now.  This will
+                 get reset at the start_memory we are about to get to,
+                 but we will have saved all the registers relevant to
+                 this repetition op, as described above.  */
+              highest_active_reg = *(p1 + 1) + *(p1 + 2);
+              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
+                lowest_active_reg = *(p1 + 1);
+            }
+
+          DEBUG_PRINT1 (":\n");
+          PUSH_FAILURE_POINT (p + mcnt, d, -2);
+          break;
+
+
+        /* A smart repeat ends with `maybe_pop_jump'.
+	   We change it to either `pop_failure_jump' or `jump'.  */
+        case maybe_pop_jump:
+          EXTRACT_NUMBER_AND_INCR (mcnt, p);
+          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
+          {
+	    register unsigned char *p2 = p;
+
+            /* Compare the beginning of the repeat with what in the
+               pattern follows its end. If we can establish that there
+               is nothing that they would both match, i.e., that we
+               would have to backtrack because of (as in, e.g., `a*a')
+               then we can change to pop_failure_jump, because we'll
+               never have to backtrack.
+
+               This is not true in the case of alternatives: in
+               `(a|ab)*' we do need to backtrack to the `ab' alternative
+               (e.g., if the string was `ab').  But instead of trying to
+               detect that here, the alternative has put on a dummy
+               failure point which is what we will end up popping.  */
+
+	    /* Skip over open/close-group commands.  */
+	    while (p2 + 2 < pend
+		   && ((re_opcode_t) *p2 == stop_memory
+		       || (re_opcode_t) *p2 == start_memory))
+	      p2 += 3;			/* Skip over args, too.  */
+
+            /* If we're at the end of the pattern, we can change.  */
+            if (p2 == pend)
+	      {
+		/* Consider what happens when matching ":\(.*\)"
+		   against ":/".  I don't really understand this code
+		   yet.  */
+  	        p[-3] = (unsigned char) pop_failure_jump;
+                DEBUG_PRINT1
+                  ("  End of pattern: change to `pop_failure_jump'.\n");
+              }
+
+            else if ((re_opcode_t) *p2 == exactn
+		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
+	      {
+		register unsigned char c
+                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
+		p1 = p + mcnt;
+
+                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
+                   to the `maybe_finalize_jump' of this case.  Examine what
+                   follows.  */
+                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
+                  {
+  		    p[-3] = (unsigned char) pop_failure_jump;
+                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
+                                  c, p1[5]);
+                  }
+
+		else if ((re_opcode_t) p1[3] == charset
+			 || (re_opcode_t) p1[3] == charset_not)
+		  {
+		    int not = (re_opcode_t) p1[3] == charset_not;
+
+		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
+			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
+		      not = !not;
+
+                    /* `not' is equal to 1 if c would match, which means
+                        that we can't change to pop_failure_jump.  */
+		    if (!not)
+                      {
+  		        p[-3] = (unsigned char) pop_failure_jump;
+                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
+                      }
+		  }
+	      }
+	  }
+	  p -= 2;		/* Point at relative address again.  */
+	  if ((re_opcode_t) p[-1] != pop_failure_jump)
+	    {
+	      p[-1] = (unsigned char) jump;
+              DEBUG_PRINT1 ("  Match => jump.\n");
+	      goto unconditional_jump;
+	    }
+        /* Note fall through.  */
+
+
+	/* The end of a simple repeat has a pop_failure_jump back to
+           its matching on_failure_jump, where the latter will push a
+           failure point.  The pop_failure_jump takes off failure
+           points put on by this pop_failure_jump's matching
+           on_failure_jump; we got through the pattern to here from the
+           matching on_failure_jump, so didn't fail.  */
+        case pop_failure_jump:
+          {
+            /* We need to pass separate storage for the lowest and
+               highest registers, even though we don't care about the
+               actual values.  Otherwise, we will restore only one
+               register from the stack, since lowest will == highest in
+               `pop_failure_point'.  */
+            unsigned dummy_low_reg, dummy_high_reg;
+            unsigned char *pdummy;
+            const char *sdummy;
+
+            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
+            POP_FAILURE_POINT (sdummy, pdummy,
+                               dummy_low_reg, dummy_high_reg,
+                               reg_dummy, reg_dummy, reg_info_dummy);
+          }
+          /* Note fall through.  */
+
+
+        /* Unconditionally jump (without popping any failure points).  */
+        case jump:
+	unconditional_jump:
+	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
+          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
+	  p += mcnt;				/* Do the jump.  */
+          DEBUG_PRINT2 ("(to 0x%x).\n", p);
+	  break;
+
+
+        /* We need this opcode so we can detect where alternatives end
+           in `group_match_null_string_p' et al.  */
+        case jump_past_alt:
+          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
+          goto unconditional_jump;
+
+
+        /* Normally, the on_failure_jump pushes a failure point, which
+           then gets popped at pop_failure_jump.  We will end up at
+           pop_failure_jump, also, and with a pattern of, say, `a+', we
+           are skipping over the on_failure_jump, so we have to push
+           something meaningless for pop_failure_jump to pop.  */
+        case dummy_failure_jump:
+          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
+          /* It doesn't matter what we push for the string here.  What
+             the code at `fail' tests is the value for the pattern.  */
+          PUSH_FAILURE_POINT (0, 0, -2);
+          goto unconditional_jump;
+
+
+        /* At the end of an alternative, we need to push a dummy failure
+           point in case we are followed by a `pop_failure_jump', because
+           we don't want the failure point for the alternative to be
+           popped.  For example, matching `(a|ab)*' against `aab'
+           requires that we match the `ab' alternative.  */
+        case push_dummy_failure:
+          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
+          /* See comments just above at `dummy_failure_jump' about the
+             two zeroes.  */
+          PUSH_FAILURE_POINT (0, 0, -2);
+          break;
+
+        /* Have to succeed matching what follows at least n times.
+           After that, handle like `on_failure_jump'.  */
+        case succeed_n:
+          EXTRACT_NUMBER (mcnt, p + 2);
+          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
+
+          assert (mcnt >= 0);
+          /* Originally, this is how many times we HAVE to succeed.  */
+          if (mcnt > 0)
+            {
+               mcnt--;
+	       p += 2;
+               STORE_NUMBER_AND_INCR (p, mcnt);
+               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
+            }
+	  else if (mcnt == 0)
+            {
+              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
+	      p[2] = (unsigned char) no_op;
+              p[3] = (unsigned char) no_op;
+              goto on_failure;
+            }
+          break;
+
+        case jump_n:
+          EXTRACT_NUMBER (mcnt, p + 2);
+          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
+
+          /* Originally, this is how many times we CAN jump.  */
+          if (mcnt)
+            {
+               mcnt--;
+               STORE_NUMBER (p + 2, mcnt);
+	       goto unconditional_jump;
+            }
+          /* If don't have to jump any more, skip over the rest of command.  */
+	  else
+	    p += 4;
+          break;
+
+	case set_number_at:
+	  {
+            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
+
+            EXTRACT_NUMBER_AND_INCR (mcnt, p);
+            p1 = p + mcnt;
+            EXTRACT_NUMBER_AND_INCR (mcnt, p);
+            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
+	    STORE_NUMBER (p1, mcnt);
+            break;
+          }
+
+        case wordbound:
+          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
+          if (AT_WORD_BOUNDARY (d))
+	    break;
+          goto fail;
+
+	case notwordbound:
+          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
+	  if (AT_WORD_BOUNDARY (d))
+	    goto fail;
+          break;
+
+	case wordbeg:
+          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
+	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
+	    break;
+          goto fail;
+
+	case wordend:
+          DEBUG_PRINT1 ("EXECUTING wordend.\n");
+	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
+              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
+	    break;
+          goto fail;
+
+#ifdef emacs
+#ifdef emacs19
+  	case before_dot:
+          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
+ 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
+  	    goto fail;
+  	  break;
+
+  	case at_dot:
+          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
+ 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
+  	    goto fail;
+  	  break;
+
+  	case after_dot:
+          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
+          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
+  	    goto fail;
+  	  break;
+#else /* not emacs19 */
+	case at_dot:
+          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
+	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
+	    goto fail;
+	  break;
+#endif /* not emacs19 */
+
+	case syntaxspec:
+          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
+	  mcnt = *p++;
+	  goto matchsyntax;
+
+        case wordchar:
+          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
+	  mcnt = (int) Sword;
+        matchsyntax:
+	  PREFETCH ();
+	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
+            goto fail;
+          SET_REGS_MATCHED ();
+	  break;
+
+	case notsyntaxspec:
+          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
+	  mcnt = *p++;
+	  goto matchnotsyntax;
+
+        case notwordchar:
+          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
+	  mcnt = (int) Sword;
+        matchnotsyntax:
+	  PREFETCH ();
+	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
+            goto fail;
+	  SET_REGS_MATCHED ();
+          break;
+
+#else /* not emacs */
+	case wordchar:
+          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
+	  PREFETCH ();
+          if (!WORDCHAR_P (d))
+            goto fail;
+	  SET_REGS_MATCHED ();
+          d++;
+	  break;
+
+	case notwordchar:
+          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
+	  PREFETCH ();
+	  if (WORDCHAR_P (d))
+            goto fail;
+          SET_REGS_MATCHED ();
+          d++;
+	  break;
+#endif /* not emacs */
+
+        default:
+          abort ();
+	}
+      continue;  /* Successfully executed one pattern command; keep going.  */
+
+
+    /* We goto here if a matching operation fails. */
+    fail:
+      if (!FAIL_STACK_EMPTY ())
+	{ /* A restart point is known.  Restore to that state.  */
+          DEBUG_PRINT1 ("\nFAIL:\n");
+          POP_FAILURE_POINT (d, p,
+                             lowest_active_reg, highest_active_reg,
+                             regstart, regend, reg_info);
+
+          /* If this failure point is a dummy, try the next one.  */
+          if (!p)
+	    goto fail;
+
+          /* If we failed to the end of the pattern, don't examine *p.  */
+	  assert (p <= pend);
+          if (p < pend)
+            {
+              boolean is_a_jump_n = false;
+
+              /* If failed to a backwards jump that's part of a repetition
+                 loop, need to pop this failure point and use the next one.  */
+              switch ((re_opcode_t) *p)
+                {
+                case jump_n:
+                  is_a_jump_n = true;
+                case maybe_pop_jump:
+                case pop_failure_jump:
+                case jump:
+                  p1 = p + 1;
+                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+                  p1 += mcnt;
+
+                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
+                      || (!is_a_jump_n
+                          && (re_opcode_t) *p1 == on_failure_jump))
+                    goto fail;
+                  break;
+                default:
+                  /* do nothing */ ;
+                }
+            }
+
+          if (d >= string1 && d <= end1)
+	    dend = end_match_1;
+        }
+      else
+        break;   /* Matching at this starting point really fails.  */
+    } /* for (;;) */
+
+  if (best_regs_set)
+    goto restore_best_regs;
+
+  FREE_VARIABLES ();
+
+  return -1;         			/* Failure to match.  */
+} /* re_match_2 */
+
+/* Subroutine definitions for re_match_2.  */
+
+
+/* We are passed P pointing to a register number after a start_memory.
+
+   Return true if the pattern up to the corresponding stop_memory can
+   match the empty string, and false otherwise.
+
+   If we find the matching stop_memory, sets P to point to one past its number.
+   Otherwise, sets P to an undefined byte less than or equal to END.
+
+   We don't handle duplicates properly (yet).  */
+
+static boolean group_match_null_string_p(unsigned char **p,
+                                         unsigned char *end,
+                                         register_info_type *reg_info)
+{
+  int mcnt;
+  /* Point to after the args to the start_memory.  */
+  unsigned char *p1 = *p + 2;
+
+  while (p1 < end)
+    {
+      /* Skip over opcodes that can match nothing, and return true or
+	 false, as appropriate, when we get to one that can't, or to the
+         matching stop_memory.  */
+
+      switch ((re_opcode_t) *p1)
+        {
+        /* Could be either a loop or a series of alternatives.  */
+        case on_failure_jump:
+          p1++;
+          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+
+          /* If the next operation is not a jump backwards in the
+	     pattern.  */
+
+	  if (mcnt >= 0)
+	    {
+              /* Go through the on_failure_jumps of the alternatives,
+                 seeing if any of the alternatives cannot match nothing.
+                 The last alternative starts with only a jump,
+                 whereas the rest start with on_failure_jump and end
+                 with a jump, e.g., here is the pattern for `a|b|c':
+
+                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
+                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
+                 /exactn/1/c
+
+                 So, we have to first go through the first (n-1)
+                 alternatives and then deal with the last one separately.  */
+
+
+              /* Deal with the first (n-1) alternatives, which start
+                 with an on_failure_jump (see above) that jumps to right
+                 past a jump_past_alt.  */
+
+              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
+                {
+                  /* `mcnt' holds how many bytes long the alternative
+                     is, including the ending `jump_past_alt' and
+                     its number.  */
+
+                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3,
+				                      reg_info))
+                    return false;
+
+                  /* Move to right after this alternative, including the
+		     jump_past_alt.  */
+                  p1 += mcnt;
+
+                  /* Break if it's the beginning of an n-th alternative
+                     that doesn't begin with an on_failure_jump.  */
+                  if ((re_opcode_t) *p1 != on_failure_jump)
+                    break;
+
+		  /* Still have to check that it's not an n-th
+		     alternative that starts with an on_failure_jump.  */
+		  p1++;
+                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
+                    {
+		      /* Get to the beginning of the n-th alternative.  */
+                      p1 -= 3;
+                      break;
+                    }
+                }
+
+              /* Deal with the last alternative: go back and get number
+                 of the `jump_past_alt' just before it.  `mcnt' contains
+                 the length of the alternative.  */
+              EXTRACT_NUMBER (mcnt, p1 - 2);
+
+              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
+                return false;
+
+              p1 += mcnt;	/* Get past the n-th alternative.  */
+            } /* if mcnt > 0 */
+          break;
+
+
+        case stop_memory:
+	  assert (p1[1] == **p);
+          *p = p1 + 2;
+          return true;
+
+
+        default:
+          if (!common_op_match_null_string_p (&p1, end, reg_info))
+            return false;
+        }
+    } /* while p1 < end */
+
+  return false;
+} /* group_match_null_string_p */
+
+
+/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
+   It expects P to be the first byte of a single alternative and END one
+   byte past the last. The alternative can contain groups.  */
+
+static boolean alt_match_null_string_p(unsigned char *p,
+                                       unsigned char *end,
+                                       register_info_type *reg_info)
+{
+  int mcnt;
+  unsigned char *p1 = p;
+
+  while (p1 < end)
+    {
+      /* Skip over opcodes that can match nothing, and break when we get
+         to one that can't.  */
+
+      switch ((re_opcode_t) *p1)
+        {
+	/* It's a loop.  */
+        case on_failure_jump:
+          p1++;
+          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+          p1 += mcnt;
+          break;
+
+	default:
+          if (!common_op_match_null_string_p (&p1, end, reg_info))
+            return false;
+        }
+    }  /* while p1 < end */
+
+  return true;
+} /* alt_match_null_string_p */
+
+
+/* Deals with the ops common to group_match_null_string_p and
+   alt_match_null_string_p.
+
+   Sets P to one after the op and its arguments, if any.  */
+
+static boolean common_op_match_null_string_p(unsigned char **p,
+                                             unsigned char *end,
+                                             register_info_type *reg_info)
+{
+  int mcnt;
+  boolean ret;
+  int reg_no;
+  unsigned char *p1 = *p;
+
+  switch ((re_opcode_t) *p1++)
+    {
+    case no_op:
+    case begline:
+    case endline:
+    case begbuf:
+    case endbuf:
+    case wordbeg:
+    case wordend:
+    case wordbound:
+    case notwordbound:
+#ifdef emacs
+    case before_dot:
+    case at_dot:
+    case after_dot:
+#endif
+      break;
+
+    case start_memory:
+      reg_no = *p1;
+      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
+      ret = group_match_null_string_p (&p1, end, reg_info);
+
+      /* Have to set this here in case we're checking a group which
+         contains a group and a back reference to it.  */
+
+      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
+        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
+
+      if (!ret)
+        return false;
+      break;
+
+    /* If this is an optimized succeed_n for zero times, make the jump.  */
+    case jump:
+      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+      if (mcnt >= 0)
+        p1 += mcnt;
+      else
+        return false;
+      break;
+
+    case succeed_n:
+      /* Get to the number of times to succeed.  */
+      p1 += 2;
+      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+
+      if (mcnt == 0)
+        {
+          p1 -= 4;
+          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
+          p1 += mcnt;
+        }
+      else
+        return false;
+      break;
+
+    case duplicate:
+      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
+        return false;
+      break;
+
+    case set_number_at:
+      p1 += 4;
+
+    default:
+      /* All other opcodes mean we cannot match the empty string.  */
+      return false;
+  }
+
+  *p = p1;
+  return true;
+} /* common_op_match_null_string_p */
+
+
+/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
+   bytes; nonzero otherwise.  */
+
+static int bcmp_translate(unsigned char *s1,
+                          unsigned char *s2,
+                          int len,
+                          char *translate)
+{
+  register unsigned char *p1 = s1, *p2 = s2;
+  while (len)
+    {
+      if (translate[*p1++] != translate[*p2++]) return 1;
+      len--;
+    }
+  return 0;
+}
+
+/* Entry points for GNU code.  */
+
+/* re_compile_pattern is the GNU regular expression compiler: it
+   compiles PATTERN (of length SIZE) and puts the result in BUFP.
+   Returns 0 if the pattern was valid, otherwise an error string.
+
+   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
+   are set in BUFP on entry.
+
+   We call regex_compile to do the actual compilation.  */
+
+const char * re_compile_pattern(const char *pattern,
+                                int length,
+                                struct re_pattern_buffer *bufp)
+{
+  reg_errcode_t ret;
+
+  /* GNU code is written to assume at least RE_NREGS registers will be set
+     (and at least one extra will be -1).  */
+  bufp->regs_allocated = REGS_UNALLOCATED;
+
+  /* And GNU code determines whether or not to get register information
+     by passing null for the REGS argument to re_match, etc., not by
+     setting no_sub.  */
+  bufp->no_sub = 0;
+
+  /* Match anchors at newline.  */
+  bufp->newline_anchor = 1;
+
+  ret = regex_compile (pattern, length, re_syntax_options, bufp);
+
+  return re_error_msg[(int) ret];
+}
+
+/* Entry points compatible with 4.2 BSD regex library.  We don't define
+   them if this is an Emacs or POSIX compilation.  */
+
+#if !defined (emacs) && !defined (_POSIX_SOURCE)
+
+/* BSD has one and only one pattern buffer.  */
+static struct re_pattern_buffer re_comp_buf;
+
+char *re_comp(const char *s)
+{
+  reg_errcode_t ret;
+
+  if (!s)
+    {
+      if (!re_comp_buf.buffer)
+	return "No previous regular expression";
+      return 0;
+    }
+
+  if (!re_comp_buf.buffer)
+    {
+      re_comp_buf.buffer = (unsigned char *) malloc (200);
+      if (re_comp_buf.buffer == NULL)
+        return "Memory exhausted";
+      re_comp_buf.allocated = 200;
+
+      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
+      if (re_comp_buf.fastmap == NULL)
+	return "Memory exhausted";
+    }
+
+  /* Since `re_exec' always passes NULL for the `regs' argument, we
+     don't need to initialize the pattern buffer fields which affect it.  */
+
+  /* Match anchors at newlines.  */
+  re_comp_buf.newline_anchor = 1;
+
+  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
+
+  /* Yes, we're discarding `const' here.  */
+  return (char *) re_error_msg[(int) ret];
+}
+
+
+int re_exec(const char *s)
+{
+  const int len = strlen (s);
+  return
+    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
+}
+#endif /* not emacs and not _POSIX_SOURCE */
+
+/* POSIX.2 functions.  Don't define these for Emacs.  */
+
+#ifndef emacs
+
+/* regcomp takes a regular expression as a string and compiles it.
+
+   PREG is a regex_t *.  We do not expect any fields to be initialized,
+   since POSIX says we shouldn't.  Thus, we set
+
+     `buffer' to the compiled pattern;
+     `used' to the length of the compiled pattern;
+     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
+       REG_EXTENDED bit in CFLAGS is set; otherwise, to
+       RE_SYNTAX_POSIX_BASIC;
+     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
+     `fastmap' and `fastmap_accurate' to zero;
+     `re_nsub' to the number of subexpressions in PATTERN.
+
+   PATTERN is the address of the pattern string.
+
+   CFLAGS is a series of bits which affect compilation.
+
+     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
+     use POSIX basic syntax.
+
+     If REG_NEWLINE is set, then . and [^...] don't match newline.
+     Also, regexec will try a match beginning after every newline.
+
+     If REG_ICASE is set, then we considers upper- and lowercase
+     versions of letters to be equivalent when matching.
+
+     If REG_NOSUB is set, then when PREG is passed to regexec, that
+     routine will report only success or failure, and nothing about the
+     registers.
+
+   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
+   the return codes and their meanings.)  */
+
+int regcomp(regex_t *preg, const char *pattern, int cflags)
+{
+  reg_errcode_t ret;
+  unsigned syntax
+    = (cflags & REG_EXTENDED) ?
+      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
+
+  /* regex_compile will allocate the space for the compiled pattern.  */
+  preg->buffer = 0;
+  preg->allocated = 0;
+
+  /* Don't bother to use a fastmap when searching.  This simplifies the
+     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
+     characters after newlines into the fastmap.  This way, we just try
+     every character.  */
+  preg->fastmap = 0;
+
+  if (cflags & REG_ICASE)
+    {
+      unsigned i;
+
+      preg->translate = (char *) malloc (CHAR_SET_SIZE);
+      if (preg->translate == NULL)
+        return (int) REG_ESPACE;
+
+      /* Map uppercase characters to corresponding lowercase ones.  */
+      for (i = 0; i < CHAR_SET_SIZE; i++)
+        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
+    }
+  else
+    preg->translate = NULL;
+
+  /* If REG_NEWLINE is set, newlines are treated differently.  */
+  if (cflags & REG_NEWLINE)
+    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
+      syntax &= ~RE_DOT_NEWLINE;
+      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
+      /* It also changes the matching behavior.  */
+      preg->newline_anchor = 1;
+    }
+  else
+    preg->newline_anchor = 0;
+
+  preg->no_sub = !!(cflags & REG_NOSUB);
+
+  /* POSIX says a null character in the pattern terminates it, so we
+     can use strlen here in compiling the pattern.  */
+  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
+
+  /* POSIX doesn't distinguish between an unmatched open-group and an
+     unmatched close-group: both are REG_EPAREN.  */
+  if (ret == REG_ERPAREN) ret = REG_EPAREN;
+
+  return (int) ret;
+}
+
+
+/* regexec searches for a given pattern, specified by PREG, in the
+   string STRING.
+
+   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
+   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
+   least NMATCH elements, and we set them to the offsets of the
+   corresponding matched substrings.
+
+   EFLAGS specifies `execution flags' which affect matching: if
+   REG_NOTBOL is set, then ^ does not match at the beginning of the
+   string; if REG_NOTEOL is set, then $ does not match at the end.
+
+   We return 0 if we find a match and REG_NOMATCH if not.  */
+
+int regexec(const regex_t *preg,
+            const char *string,
+            size_t nmatch,
+            regmatch_t pmatch[],
+            int eflags)
+{
+  int ret;
+  struct re_registers regs;
+  regex_t private_preg;
+  int len = strlen (string);
+  boolean want_reg_info = !preg->no_sub && nmatch > 0;
+
+  private_preg = *preg;
+
+  private_preg.not_bol = !!(eflags & REG_NOTBOL);
+  private_preg.not_eol = !!(eflags & REG_NOTEOL);
+
+  /* The user has told us exactly how many registers to return
+     information about, via `nmatch'.  We have to pass that on to the
+     matching routines.  */
+  private_preg.regs_allocated = REGS_FIXED;
+
+  if (want_reg_info)
+    {
+      regs.num_regs = nmatch;
+      regs.start = TALLOC (nmatch, regoff_t);
+      regs.end = TALLOC (nmatch, regoff_t);
+      if (regs.start == NULL || regs.end == NULL)
+        return (int) REG_NOMATCH;
+    }
+
+  /* Perform the searching operation.  */
+  ret = re_search (&private_preg, string, len,
+                   /* start: */ 0, /* range: */ len,
+                   want_reg_info ? &regs : (struct re_registers *) 0);
+
+  /* Copy the register information to the POSIX structure.  */
+  if (want_reg_info)
+    {
+      if (ret >= 0)
+        {
+          unsigned r;
+
+          for (r = 0; r < nmatch; r++)
+            {
+              pmatch[r].rm_so = regs.start[r];
+              pmatch[r].rm_eo = regs.end[r];
+            }
+        }
+
+      /* If we needed the temporary register info, free the space now.  */
+      free (regs.start);
+      free (regs.end);
+    }
+
+  /* We want zero return to mean success, unlike `re_search'.  */
+  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
+}
+
+
+/* Returns a message corresponding to an error code, ERRCODE, returned
+   from either regcomp or regexec.   We don't use PREG here.  */
+size_t regerror(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)
+{
+  const char *msg;
+  size_t msg_size;
+
+  if (errcode < 0
+      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
+    /* Only error codes returned by the rest of the code should be passed
+       to this routine.  If we are given anything else, or if other regex
+       code generates an invalid error code, then the program has a bug.
+       Dump core so we can fix it.  */
+    abort ();
+
+  msg = re_error_msg[errcode];
+
+  /* POSIX doesn't require that we do anything in this case, but why
+     not be nice.  */
+  if (! msg)
+    msg = "Success";
+
+  msg_size = strlen (msg) + 1; /* Includes the null.  */
+
+  if (errbuf_size != 0)
+    {
+      if (msg_size > errbuf_size)
+        {
+          strncpy (errbuf, msg, errbuf_size - 1);
+          errbuf[errbuf_size - 1] = 0;
+        }
+      else
+        strcpy (errbuf, msg);
+    }
+
+  return msg_size;
+}
+
+/* Free dynamically allocated space used by PREG.  */
+
+void regfree(regex_t *preg)
+{
+  if (preg->buffer != NULL)
+    free (preg->buffer);
+  preg->buffer = NULL;
+
+  preg->allocated = 0;
+  preg->used = 0;
+
+  if (preg->fastmap != NULL)
+    free (preg->fastmap);
+  preg->fastmap = NULL;
+  preg->fastmap_accurate = 0;
+
+  if (preg->translate != NULL)
+    free (preg->translate);
+  preg->translate = NULL;
+}
+
+#endif /* not emacs  */
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/scanmem.c clamav-release/contrib/msvc/src/scanmem.c
--- clamav-0.91.2/contrib/msvc/src/scanmem.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/scanmem.c	2007-07-12 12:36:19.406250000 +1000
@@ -0,0 +1,448 @@
+/*
+ * Clamav Native Windows Port:
+ *  scan modules/exe loaded by loaded executables
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <osdeps.h>
+#include <exeScanner.h>
+#include <filelist.h>
+
+#include <clamav.h>
+#include <output.h>
+#include <options.h>
+#include <clamscan/manager.h>
+
+#define TIMEOUT_MODULE  30000
+
+extern char *cli_gentemp(const char *dir);
+extern int checkfile(const char *filename, const struct cl_engine *engine, const struct cl_limits *limits, int options, short printclean);
+
+/* Yes, I'm no so polite, but clamscan is single-threaded */
+#include <clamscan/global.h>
+extern struct s_info info;
+
+typedef struct _scanmem_data_t
+{
+    filelist_t *files;
+    int printclean, kill, unload, leave_temps;
+    int res;
+    uint32_t processes, modules;
+
+    /* ClamAV Specific */
+    struct cl_engine *engine;
+    const struct optstruct *opt;
+    const struct cl_limits *limits;
+    int options;
+} scanmem_data;
+
+#define FIXATTRS(filename) \
+{ \
+    DWORD dwAttrs = GetFileAttributes(filename); \
+    SetFileAttributes(filename, dwAttrs & ~ (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN)); \
+}
+
+/* Needed to Scan System Processes */
+int EnablePrivilege(LPCSTR PrivilegeName, DWORD yesno)
+{
+    HANDLE hToken;
+    TOKEN_PRIVILEGES tp;
+    LUID luid;
+
+    if(!memhelpers.OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY | TOKEN_READ, &hToken))
+        return 0;
+
+    if(!memhelpers.LookupPrivilegeValueA(NULL, PrivilegeName, &luid))
+        return 0;
+
+    tp.PrivilegeCount = 1;
+    tp.Privileges[0].Luid = luid;
+    tp.Privileges[0].Attributes = yesno;
+
+    memhelpers.AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);
+    CloseHandle(hToken);
+    return (GetLastError() == ERROR_SUCCESS) ? 1 : 0;
+}
+
+int walkmodules(proc_callback callback, void *data)
+{
+    HANDLE hSnap = INVALID_HANDLE_VALUE, hModuleSnap = INVALID_HANDLE_VALUE;
+    PROCESSENTRY32 ProcStruct;
+    MODULEENTRY32 me32;
+
+    hSnap = memhelpers.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+    if (hSnap == INVALID_HANDLE_VALUE) return -1;
+
+    ProcStruct.dwSize = sizeof(PROCESSENTRY32);
+
+    if (!memhelpers.Process32First(hSnap, &ProcStruct))
+    {
+        CloseHandle(hSnap);
+        return -1;
+    }
+
+    do
+    {
+        /* system process */
+        if (!ProcStruct.th32ProcessID) continue;
+        /* if (strncmp(ProcStruct.szExeFile, "xx", 2)) continue; */ /* DEBUG: Short Circuit */
+        hModuleSnap = memhelpers.CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcStruct.th32ProcessID);
+        if (hModuleSnap == INVALID_HANDLE_VALUE) continue;
+        if (GetCurrentProcessId() == ProcStruct.th32ProcessID) continue; /* Avoid Killing myself */
+
+        me32.dwSize = sizeof(MODULEENTRY32);
+        if(!memhelpers.Module32First(hModuleSnap, &me32))
+        {
+            CloseHandle(hModuleSnap);
+            continue;
+        }
+
+        do if (callback(ProcStruct, me32, data)) break;
+        while (memhelpers.Module32Next(hModuleSnap, &me32));
+
+        CloseHandle(hModuleSnap);
+    }
+    while (memhelpers.Process32Next(hSnap, &ProcStruct));
+    CloseHandle(hSnap);
+    return 0;
+}
+
+int kill_process(DWORD pid)
+{
+    HANDLE hProc;
+    if ((hProc = OpenProcess(SYNCHRONIZE | PROCESS_TERMINATE, FALSE, pid)))
+    {
+        DWORD code;
+        TerminateProcess(hProc, 0);
+        if (WaitForSingleObject(hProc, TIMEOUT_MODULE) != WAIT_OBJECT_0)
+            cli_errmsg("Unable to unload process from memory\n");
+        CloseHandle(hProc);
+    }
+    else
+        cli_errmsg("OpenProcess() failed %d\n", GetLastError());
+    return 1; /* Skip to next process anyway */
+}
+
+/* Not so safe ;) */
+int unload_module(DWORD pid, HANDLE hModule)
+{
+    DWORD rc = 1;
+    HANDLE ht;
+    HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION |
+        PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, pid);
+
+    if (!hProcess)
+    {
+        cli_errmsg("OpenProcess() failed %d\n", GetLastError());
+        return 1; /* Skip to next process */
+    }
+
+    if ((ht = memhelpers.CreateRemoteThread(hProcess, 0, 0, FreeLibrary, hModule, 0, &rc)))
+    {
+        if(WaitForSingleObject(ht, TIMEOUT_MODULE) == WAIT_TIMEOUT)
+        {
+            CloseHandle(ht);
+            CloseHandle(hProcess);
+            logg("The module may trying to trick us, killing the process, please rescan\n");
+            return kill_process(pid);
+        }
+        CloseHandle(ht);
+        rc = 0; /* Continue scanning this process */
+    }
+    else
+    {
+        DWORD res = GetLastError();
+        if (res == ERROR_CALL_NOT_IMPLEMENTED)
+        {
+            cli_errmsg("Module unloading is not supported on this OS\n");
+            rc = -1; /* Don't complain about removing/moving the file */
+        }
+        else
+        {
+            cli_errmsg("CreateRemoteThread() failed %d\n", res);
+            rc = 1; /* Skip to next process */
+        }
+    }
+
+    CloseHandle(hProcess);
+    return rc;
+}
+
+#define FILLBYTES(dst) \
+    if (IsBadReadPtr(seek, sizeof(dst))) \
+    { \
+        cli_errmsg("ScanMem Align: Bad pointer!!!\n"); \
+        return 1; \
+    } \
+    memcpy(&dst, seek, sizeof(dst))
+
+/* PE Realignment - FIXME: a lot of code is copy/paste from exeScanner.c */
+int align_pe(unsigned char *buffer, size_t size)
+{
+    int i = 0;
+    uint16_t e_mz;
+    uint32_t e_lfanew, e_magic;
+    unsigned char *seek = buffer;
+    PIMAGE_FILE_HEADER pehdr;
+    PIMAGE_OPTIONAL_HEADER32 opthdr;
+    PIMAGE_SECTION_HEADER sechdr;
+
+    FILLBYTES(e_mz);
+    if (e_mz != IMAGE_DOS_SIGNATURE)
+    {
+        cli_dbgmsg("ScanMem Align: DOS Signature not found\n");
+        return 0;
+    }
+
+    seek += 0x3c;
+
+    FILLBYTES(e_lfanew);
+    if (!e_lfanew)
+    {
+        cli_dbgmsg("ScanMem Align: Invalid PE offset\n");
+        return 0;
+    }
+    seek = buffer + e_lfanew;
+
+    /* PE Signature 'PE' */
+    FILLBYTES(e_magic);
+    if (e_magic != IMAGE_NT_SIGNATURE)
+    {
+        cli_dbgmsg("ScanMem Align: PE Signature not found\n");
+        return 0;
+    }
+    seek += sizeof(e_magic);
+
+    if (IsBadReadPtr(seek, sizeof(IMAGE_FILE_HEADER))) return 0;
+    pehdr = (PIMAGE_FILE_HEADER) seek;
+    seek += sizeof(IMAGE_FILE_HEADER);
+
+    if (IsBadReadPtr(seek, sizeof(IMAGE_OPTIONAL_HEADER32))) return 0;
+    opthdr = (PIMAGE_OPTIONAL_HEADER32) seek;
+    seek += sizeof(IMAGE_OPTIONAL_HEADER32);
+
+    /* Invalid sections number */
+    if ((pehdr->NumberOfSections < 1) || (pehdr->NumberOfSections > 32))
+    {
+        cli_dbgmsg("ScanMem Align: Invalid sections number\n");
+        return 0;
+    }
+
+    for (i = 0; i < pehdr->NumberOfSections; i++)
+    {
+        if (IsBadWritePtr(seek, sizeof(IMAGE_SECTION_HEADER))) return 0;
+        sechdr = (PIMAGE_SECTION_HEADER) seek;
+        seek += sizeof(IMAGE_SECTION_HEADER);
+        sechdr->PointerToRawData = sechdr->VirtualAddress;
+        sechdr->SizeOfRawData = sechdr->Misc.VirtualSize;
+    }
+    return 1;
+}
+
+int dump_pe(const char *filename, PROCESSENTRY32 ProcStruct, MODULEENTRY32 me32)
+{
+    SIZE_T bytesread = 0;
+    DWORD byteswrite = 0;
+    int ret = -1;
+    HANDLE hFile = INVALID_HANDLE_VALUE, hProc = NULL;
+    unsigned char *buffer = NULL;
+
+    if (!(hProc = OpenProcess(PROCESS_VM_READ, FALSE, ProcStruct.th32ProcessID))) return -1;
+
+    buffer = (unsigned char *) malloc (me32.modBaseSize);
+    if (!ReadProcessMemory(hProc, me32.modBaseAddr, buffer, me32.modBaseSize, &bytesread))
+    {
+        free(buffer);
+        CloseHandle(hProc);
+        return ret;
+    }
+
+    CloseHandle(hProc);
+
+    /* PE Realignment */
+    if (align_pe(buffer, me32.modBaseSize))
+        cli_dbgmsg("ScanMem Align: File aligned\n");
+    else
+        cli_dbgmsg("ScanMem Align: Realign failed\n");
+
+    hFile = CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (hFile == INVALID_HANDLE_VALUE)
+    {
+        logg("Error creating %s\n", filename);
+        free(buffer);
+        return ret;
+    }
+
+    if (WriteFile(hFile, buffer, bytesread, &byteswrite, NULL))
+        ret = _open_osfhandle((intptr_t) hFile, O_RDONLY | O_BINARY);
+    free(buffer);
+    return ret;
+}
+
+int scanmem_cb(PROCESSENTRY32 ProcStruct, MODULEENTRY32 me32, void *data)
+{
+    scanmem_data *scan_data = NULL;
+    DWORD dwAttrs = 0;
+    int rc = 0;
+    int isprocess = 0;
+    unsigned char modulename[MAX_PATH] = "";
+    unsigned char expandmodule[MAX_PATH] = "";
+
+    if (!data) return 0;
+
+    scan_data = (scanmem_data *) data;
+    scan_data->res = CL_CLEAN;
+
+    modulename[0] = 0;
+    /* Special case, btw why I get \SystemRoot\ in process szExePath?
+       There are also other cases? */
+    if ((strlen(me32.szExePath) > 12) && !strncmp(me32.szExePath, "\\SystemRoot\\", 12))
+    {
+        expandmodule[0] = 0;
+        strncat(expandmodule, me32.szExePath, MAX_PATH);
+        snprintf(expandmodule, MAX_PATH, "%%SystemRoot%%\\%s", &me32.szExePath[12]);
+        ExpandEnvironmentStrings(expandmodule, modulename, MAX_PATH);
+    }
+
+    if (!modulename[0])
+        if ((strlen(me32.szExePath) > 4) && PATH_ISUN2(me32.szExePath)) /* \\??\ <-- wtf */
+            strncat(modulename, UNC_OFFSET(me32.szExePath), MAX_PATH);
+        else
+            strncat(modulename, me32.szExePath, MAX_PATH);
+
+    if (insert_file(&scan_data->files, modulename))
+    {
+        isprocess = !stricmp(ProcStruct.szExeFile, modulename) || !stricmp(ProcStruct.szExeFile, me32.szModule);
+
+        if (isprocess) scan_data->processes++;
+        else scan_data->modules++;
+
+        info.files++;
+
+        if (checkfile(modulename, scan_data->engine, scan_data->limits, scan_data->options, scan_data->printclean) == CL_VIRUS)
+            scan_data->res = CL_VIRUS;
+        else if(is_packed(modulename))
+        {
+            const char *virname;
+            char *dumped = cli_gentemp(NULL);
+            int fd = -1;
+            cli_dbgmsg("%s: appears to be compressed, saving from computer memory\n", modulename);
+            if ((fd = dump_pe(dumped, ProcStruct, me32)) > 0)
+            {
+                if (cl_scandesc(fd, &virname, &info.blocks, scan_data->engine, scan_data->limits, scan_data->options) == CL_VIRUS)
+                {
+                    logg("%s: %s FOUND\n", me32.szExePath, virname);
+                    info.ifiles++;
+                    scan_data->res = CL_VIRUS;
+                }
+                close(fd);
+            }
+            if (!scan_data->leave_temps) DeleteFile(dumped);
+            free(dumped);
+        }
+    }
+
+    if (scan_data->res == CL_VIRUS)
+    {
+        if (isprocess && scan_data->kill)
+        {
+            logg("Unloading program %s from memory\n", modulename);
+            rc = kill_process(ProcStruct.th32ProcessID);
+        }
+        else if (scan_data->unload)
+        {
+            logg("Unloading module %s from %s\n", me32.szModule, modulename);
+            if ((rc = unload_module(ProcStruct.th32ProcessID, me32.hModule)) == -1)
+                /* CreateProcessThread() is not implemented */
+                return 0;
+        }
+        else return 0;
+
+        /* First of all remove read-only flag if it's set */
+        FIXATTRS(modulename);
+
+        /* Check if I need to remove/move the infected file, filters are ignored here */
+        if (opt_check(scan_data->opt, "remove"))
+        {
+            if (!DeleteFile(modulename))
+            {
+                logg("%s: Cannot be deleted (%d)\n", modulename, GetLastError());
+                info.notremoved++;
+            }
+        }
+        else if (opt_check(scan_data->opt, "move"))
+        {
+            unsigned char destfile[MAX_PATH];
+            unsigned char *last = strrchr(modulename, '\\');
+            if (last) last++; /* unlikely */
+            snprintf(destfile, MAX_PATH, "%s\\%s", opt_arg(scan_data->opt, "move"), (last && *last) ? last : modulename);
+            FIXATTRS(destfile);
+            if (!MoveFileEx(modulename, destfile, MOVEFILE_REPLACE_EXISTING))
+            {
+                logg("%s: Cannot be moved (%d)\n", modulename, GetLastError());
+                info.notmoved++;
+            }
+        }
+        return rc;
+    }
+
+    return rc;
+}
+
+int scanmem(struct cl_engine *engine, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options)
+{
+    scanmem_data data;
+    data.files = NULL;
+    data.printclean = 1;
+    data.kill = 0;
+    data.unload = 0;
+    data.leave_temps = 0;
+    data.res = CL_CLEAN;
+    data.processes = 0;
+    data.modules = 0;
+
+    if (!memhelpers.ok)
+    {
+        logg(" *** Memory Scanning is not supported on this OS ***\n\n");
+        return -1;
+    }
+
+    if (opt_check(opt, "infected")) data.printclean = 0;
+    if (opt_check(opt, "kill")) data.kill = 1;
+    if (opt_check(opt, "unload")) data.unload = 1;
+    if (opt_check(opt, "leave-temps")) data.leave_temps = 1;
+
+    /* ClamAV Specific */
+    data.engine = engine;
+    data.limits = limits;
+    data.opt = opt;
+    data.options = options;
+
+    logg(" *** Scanning Programs in Computer Memory ***\n\n");
+
+    if (!isWin9x() && !EnablePrivilege(SE_DEBUG_NAME, SE_PRIVILEGE_ENABLED))
+        logg("---Please login as an Administrator to scan System processes loaded in computer memory---\n");
+
+    walkmodules(scanmem_cb, (void *) &data);
+    freelist(&data.files);
+
+    logg("\n *** Scanned %d processes - %d modules ***\n", data.processes, data.modules);
+    logg(" *** Computer Memory Scan Completed ***\n\n");
+    return data.res;
+}
+
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/src/winstat.c clamav-release/contrib/msvc/src/winstat.c
--- clamav-0.91.2/contrib/msvc/src/winstat.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/src/winstat.c	2007-07-12 12:36:19.421875000 +1000
@@ -0,0 +1,107 @@
+/*
+ * Clamav Native Windows Port :
+ * stat replacement with one that can handle unc paths
+ * plain stat doesn't support unc paths, also it returns strange results
+ * when called on invalid paths like c:\com7.ppd
+ *
+ * Copyright (c) 2005-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <osdeps.h>
+
+#if _MSC_VER > 1200
+#undef _stat64 /* I really don't want to loop here */
+int win32_stat(const char *path, struct _stat64 *buf)
+#else
+#undef _stati64
+int win32_stat(const char *path, struct _stati64 *buf)
+#endif
+{
+    int res = 0;
+    size_t i = 0;
+    ULARGE_INTEGER ft;
+    char cpath[MAX_PATH], unc_path[MAX_PATH];
+    HANDLE hFile = INVALID_HANDLE_VALUE;
+    BY_HANDLE_FILE_INFORMATION FileInformation;
+
+    unc_path[0] = 0;
+    cpath[0] = 0;
+    memset(buf, 0, sizeof(struct _stat64));
+
+    /* Save some cpu cycles :P */
+    if (!GetFullPathName(path, MAX_PATH, cpath, NULL)) return -1;
+
+    /* yes, yes complain m$ about converting c:\up\com7.dll to \\.\com7 when using GetFullPathName */
+    if (PATH_ISDEV(cpath))
+    {
+        cpath[0] = 0;
+        strncat(cpath, path, MAX_PATH);
+    }
+
+    if (PATH_ISNET(cpath))
+    {
+        strncat(unc_path, cpath, MAX_PATH);
+        if (PATH_ISUNC(cpath))
+            res = _stat64(UNC_OFFSET(cpath), buf);
+        else /* Networks shares need trailing \, network paths not */
+        {
+            char *p = cpath + 2;
+            int slashes = 0;
+            strip_trailing_slashes(cpath);
+            unixpath_to_win32(cpath);
+            while (*p && slashes < 2)
+            {
+                if (*p == '\\') slashes++;
+                p++;
+            }
+            if (slashes < 2) strncat(unc_path, "\\", MAX_PATH);
+            res = _stat64(unc_path, buf);
+        }
+    }
+    else
+    {
+        res = _stat64(cpath, buf);
+        snprintf(unc_path, MAX_PATH, "%s%s", unc_prefix(cpath), cpath);
+    }
+
+    if ((res < 0) || (buf->st_size > 0) || ((buf->st_mode & S_IFMT) == S_IFDIR)) return res; /* Save some I/O */
+
+    /* Calling stat on files with invalid names like com7.dll st_size is zero,
+       so we need to use native Windows API functions to retrieve the correct size */
+
+    if ((hFile = CreateFile(unc_path,
+        GENERIC_READ,
+        FILE_SHARE_READ,
+        NULL,
+        OPEN_EXISTING,
+        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
+        NULL)) == INVALID_HANDLE_VALUE)
+        return -1;
+
+    memset(&FileInformation, 0, sizeof(FileInformation));
+    if (!GetFileInformationByHandle(hFile, &FileInformation))
+        res = -1;
+    else
+    {
+        buf->st_size = FileInformation.nFileSizeHigh;
+        buf->st_size = buf->st_size << 32;
+        buf->st_size = buf->st_size | FileInformation.nFileSizeLow;
+    }
+
+    CloseHandle(hFile);
+    return res;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/tools/exeScanner.h clamav-release/contrib/msvc/tools/exeScanner.h
--- clamav-0.91.2/contrib/msvc/tools/exeScanner.h	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/tools/exeScanner.h	2007-07-12 12:36:19.625000000 +1000
@@ -0,0 +1,54 @@
+/*
+ * executable modules analyzer
+ *
+ * Copyright (c) 2006-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _EXESCANNER_H_
+#define _EXESCANNER_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <windows.h>
+
+#define ENTROPY_THRESHOLD   4.0
+#define EP_SIGNATURE_SIZE   16
+#define DUMP_SIGNATURE
+
+#ifndef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#endif
+
+#define cli_errmsg printf
+#define cli_dbgmsg printf
+
+typedef unsigned __int8  uint8_t;
+typedef unsigned __int16 uint16_t;
+typedef unsigned __int32 uint32_t;
+typedef __int16 int16_t;
+
+typedef struct _sigs_t
+{
+    int16_t sig[16];
+    const char *name;
+    uint8_t packed;
+} sigs_t;
+
+extern int is_packed(const char *filename);
+
+#endif /* _EXESCANNER_H_ */
\ No newline at end of file
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/tools/exeScanner.rc clamav-release/contrib/msvc/tools/exeScanner.rc
--- clamav-0.91.2/contrib/msvc/tools/exeScanner.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/tools/exeScanner.rc	2007-07-12 12:36:19.671875000 +1000
@@ -0,0 +1,3 @@
+#define __MODULE__	"exeScanner.exe"
+#define __DESC__	"Executables Detection Tools"
+#include <tools.rc>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/tools/exeScanner_app.c clamav-release/contrib/msvc/tools/exeScanner_app.c
--- clamav-0.91.2/contrib/msvc/tools/exeScanner_app.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/tools/exeScanner_app.c	2007-07-12 12:36:19.656250000 +1000
@@ -0,0 +1,39 @@
+/*
+ * executable modules analyzer
+ *
+ * Copyright (c) 2006-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <exeScanner.h>
+
+int main(int argc, char *argv[])
+{
+    int packed = 0;
+    if (argc != 2)
+    {
+        printf("Usage: %s filename\n", argv[0]);
+        return -1;
+    }
+
+    SetLastError(ERROR_SUCCESS); /* A bit ugly but who cares here? */
+    packed = is_packed(argv[1]);
+    if (GetLastError() == ERROR_SUCCESS)
+        printf("exeScanner: %s -> %s\n", argv[1], (packed ? "Packed" : "Not Packed"));
+    return 0;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/tools/tools.ico clamav-release/contrib/msvc/tools/tools.ico
--- clamav-0.91.2/contrib/msvc/tools/tools.ico	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/tools/tools.ico	2007-07-12 12:36:19.656250000 +1000
@@ -0,0 +1,41 @@
+        h  F        h  ®        ¨  
+         ¨  ¾  (                                          ,   -   % & 8   4  3 4 5 
+ 3 G   3 2 ; T  
+
+ 1 2 ( E 3 1  > ? A		 D		 C #2  ] I &  W     S  T  t  6 u   P     u!  |#  5   v# 2!! L /"" /
+R L F!! L!! /%% ;$$ +&& #'' G## B$$ -(( 7'' 8'' 8(( 9(( 1)) *** D'' <(( /** '++ 1++ :** *,, 7,, H** :,, WA S)) A,, /// ;.. 000 011 }1 622 722 A11 G11 :33 644 [00 J34 566 777 G66 I77 a53 M88 †= L:: L;; ?>> R>> ÀC ¿E ¾E ¿E ¿F HBB ¿F ÀG ÀF ÀG ÌJ GGG mDA dDE HHH gED nIE MMM qMG iMN sNI tOJ :t XTT kRR pRQ sXP X[[ Ä\2 uYY s[\ uaa |aa a\ …c\ ea phg Òn9 vjk ‰le nnn rnn og ‹mm ‡pl yuu ts …ww zyy €€€ –}~  „„ ‰‡† ‰ˆˆ ‘ˆˆ ’ ‘‘ ‘““ ˜–– ™™ ›œœ ¦   §   §§§ ­«« ®«¯ °®­ ®¯² ±±± ²²¶ µµµ ¹¸· ¸·º ¸ºº ººº ¼ºº »º½ ½¼¼ ÁÁÄ ËÁÁ ÁÃÃ ÆÄÄ ÆÆÉ ÉÉÌ ÏÎÒ ×ÏÏ ÔÑÑ ÓÒÕ ÛÕÕ ØÕÙ ×ÖØ ÚØØ éèç éêê ôìä şıı                                                                                                                                                                                                             
+
+ R^YWKB=1*&"‘| @AeDTLC<8#,¢ )­Î O¯?;‰ 	‡º·Zu7ŸˆÀ›š‚ ©JXbI§`SÉ¤’„ ™ªZ[°n¨E£Æƒ—… 
+]Á¡µ2f~«a®jœ€ ‹»~%({˜J>F/–}   !'+-NQM$” 59GPH_hglmod“i c¬¦±¼¥ÂÍ³Ç¸Ì¾Ğ V²´¶¹½¿ÃÄÅÈËÊÏŠ 6zwtqysrxvpŒ•†:  430000000.\kU  ÿÿ                                            €  (                                        2   Z   U   U   U   U   V   V   V   V   V   W   W   U   ]   =&‰3Ø1Ì1Ì1Ì2Ë2Ì2Ì3Ë3Ê4Ê4Ê4 É5Î%Ç  dD		²7,,ÿ722í;..éA,,åD''áG##ŞL!!ÛPÏS½W®]œT ƒa\ÚmDAğ   [?®+&&ş#''æ566ã-((Ş:,,Ú<((ÖB$$ÑF!!ÌLÁI®TœG  €–}~ÖuYYì   [>® ÿ›œœöéêêızyyì1++ß§  ï;$$Õuaaß|aaÜLÄC­E”tsİpRQë   [3­XTTÿ¸ººúMMMğµµµö000âHBBâ2!!Ø…wwåkRRÚËÁÁò‹mmÔ5¤ogãqMGê   [-  ­yuuÿ‘‘øí***ì///ç644ä1))Ş‘ˆˆêG11×H**ÔÛÕÕø„„×…c\åsNIé   [,  ­rnnÿ‘““ûó000ñ011í§§§õ?>>å’ì7''Ùæ×ÏÏõiMNÕ‰leîtOJç   [4­622ÿÁÃÃş€€€û±±±ú   ï777íHHHê˜––ğ:33ß¦  ïM88Ø(Ê‡plônIEç   [;­ÿX[[ÿºººÿHHHùôïGGGînnní***à/%%Û8''Ø6ÒvjkõdDEæ   \8  ­
+ÿ   ÿ   ÿ
+
+ıûøóï'++í*,,ë/**ç&áphgúgEDæ   \A		­5  ÿ/""ÿ8((ÿ:**ÿ9((şA11şI77üG66üL::ûL;;úR>>øJ34÷eaÿa53ä   \[00­™™ÿ‰ˆˆÿ­««ÿ¼ººÿ‰‡†ÿÆÄÄÿéèçÿ°®­ÿÔÑÑÿ¹¸·ÿÚØØÿ½¼¼ÿşııÿs[\ä   \S))­®«¯ÿ®¯²ÿ²²¶ÿ¸·ºÿ»º½ÿÁÁÄÿÆÆÉÿÉÉÌÿÏÎÒÿÓÒÕÿ×ÖØÿØÕÙÿôìäÿsXPä   ]v#³ÌJÿÀGÿ¿Fÿ¿EÿÀGÿ¿Eÿ¾EÿÀFÿ¿FÿÀCÿÄ\2ÿÒn9ÿ:tÿ/
+Rî _N }|# Æu! Àu  Àu  Àu  Àu  Àu  Àu  Àu  Àt À}1À†=ÀWAÅ#2¡ &ÿÿ  ÿÿ  ¿ÿ  ÿÿ  ¿ÿ  ¿ÿ  ¿ÿ  ¿ÿ  ¿ÿ  ÿ  ÿ  ‡û  €  €  €  ÿÿ  (       @                                          !  *   %  %  
+ 3  8 8  M  =  a   ?	 0	 +	 P ]  ^  f   Z
+ Z U C  J ? 5 W	 ; W
+  C S T 5 D  P R 4  0 C ( O I ) O 7 .   =  ! B '  M : 5  - " "$" 8 " 4"! F! &#% %% G" ,%$ ?!& D## *&( &(& !(( 8&% ='" A&# <%' ;)) ?(* *,+ 3+* J(( /+- 8,( &-- F*( B,' 9+. ,/- ;.+ H*/ 7/. ¦2  •+ 402 020 ¥7  X0- 751 q'8 S02 857 Q43 a22 ?77 N58 J77 = F8; 9;: /š = C;: |7/ \9: ¦> ]9; ›@ l1J =@> Å ™=%  Ğ –@) ÕJ  VBB ÑD [BD ”D- bDC EHF r@H KIE jFE {DH °M# ÎQ †JI ¬O3 hMP QTR \W Ïf- ia` ¡^Y Ëg< dfe ’a_ ieg jmk knl ÎoF •ih £jh ‰mq ‡rr svt ¯qj ¬rq ­sr x{y }x “}} Œ‚‚ ²z ‰…‡ ‹‡Š ‡Šˆ œ‡‡ ôX ó’f –’” ¥•˜ Ÿ› š› ¾œ˜ — ¡ ¼¡ ­¤  ¥¨¦ ¶¬« Ç«¨ ¥®¯ ²°« º°¯ À±­ ¯³± ¶²´ ¬´µ ´·µ ¯µ¾ º¶¸ Ã¼¬ ¾»¶ ³¼½ Ç¾¹ µ¼Å ¼¿½ °¿Ã Ä¿Â ÁÄÂ ÕÇ» ĞÇ¿ ÊÇÂ ÀÇĞ ÌÈÊ ÈÍÃ ÈËÉ ÇÎÖ ÚĞÏ ÏÒĞ ×ÓÕ ÒÓÙ ÍÖ× Ô×Õ ãØØ İÙÛ ØÛÙ ÒÙá Üàİ Ùàè âåã îãã âãé åæì çëè íéë õôç õñó òõó ùüú üÿı                                                                     ïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïïï        ïïïï(#((%%%%ïï#[_flle^TTURLLF?454)))##ï!¾—ïï[V[lfbYbTPSaKFIF?454))#ï$Ö¦ïï%OVeVGVbb^]P@R;F'+?47.-)ï$Ü«ïïOMGV›‹Mbb`sqSLImŒ=544.)#$à«ïï#H0‰Ûíë²NbBÈÒAS*»¹$2+?44#"Ü«ïï#<NÛìºæí™GJÅÈEP@Î¢=¯h44)"È ïï›í¬
+tîÆGios^PUÚ’;éå¡!."Ğ¤ïï´ì~>C²VlYWeE„ßp*©ëîÀh ;Ç¤ïïÁèY:MG:__GCbB–ÔQR*k³íånÑ¥ïïÄéM:::V_Gœ£e>¬»9UAˆéîŒ	Ñ¥ïï
+´ç_&NG&G:ÛßN:¾´9P„»îì©=/Ğ¤ïï ¬î‹²£:C²´VGÒ¬>ZÚîÎ†=/Ğ¤ïï
+fîÌCœîÂGC:Vlæ›>sÖªD8\L/Ê ïï
+­îëîçl&GNGG“é‹MowEPQUK1½šïïËÂw::GN0–º__eMb`^PD1ÃŸïï :0:GGNV:_lf_b^^PQ9½šïï
+
+&&&&,:::GGNVVYeiV`^P6·š	ïï 
+
+
+
+&&&,00<:CCHVGMG>3Ê ïïAAK8L;;LLKXRLLXmaXymkk{hX”xïïµªªªªÈÔ²¬¬¹ÚÚÚÂ­ŞŞ­¿åÎ­ØåŞ¶ïï·§¬§¨ÅÙ®§¨µâàèÂ§àä¨ÁîÏ£İíî¼ïïÉ¾¾ÄÈÌÈÒÒÒÕÚÒÚÚÙÚæÛâââäèçì¸ïïŠÍÅÅÅËÅËËÓÓÓÓ×××áááãããæççéê¶ïïdv€€|||€||€€€||€||€vv‚‡‚‡‚}jïïƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ…±•°˜"ïïdgggggggggggggggggggcz‘urïïïïïïïÿÿÿÿÿÿÿÿ€           ƒ   ƒ   ƒ                                                                        (       @                                                                                                                                                                    2   9   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   7   8   4      )   v   ‰   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   …   ‹   ‚   4  8  œ  «  £  £  £  £  £  £  £  £  £  ¤  ¤  ¤  ¤  ¤  ¤  ¤  ¤  ¤  ¥  ¥  ¦  ¦  ¦  ¥  ¢  ¤  ¢      9*  jcöQõSóTóTòTòUòVòVñWñX
+
+ñX		ñX		ñY		ñZğ[ï[î\í\ì]ë^ë^é^é^è`æ]ëZòfô+  ¿   „   90  pZÿ'//û.00ó233ë433é611æ800ä:--ã<++à=))ß?((İC%%ÚD##ØE""×H  ÓKÍNÄNºP²R«T¢V™W‘X‰\uB¥³©ÿŸ_Yÿ&  Ä   …   9.  nWÿ%++ø,--ï.//æ233ã533á711Ş7//İ9..Û;**Ø<))×@((ÔB&&ÒC$$ÏE!!ÍFÊJÁL¶M°N§PS“UŠU‚Yl>ŸÉÌÅÿªtqÿ"  Â   …   9/  nWÿ$))ù+++ñ///é+++æ%&&ã+((á5//à7//Ş:++Ü<))Ú7""×9!!ÕB&&ÓD""ĞF!!ÏAÊBÁL¼M´O«R S—TV|>¨ÕÚÚÿ²€ÿ!  Â   …   9/  nVÿ!''û)))ó   ê000é[\\ëLKKç)''á3--ß8//Ş9++ÜH88ÜJ77Ú>%%ÖB%%Ò@Ï[::ÔeCCÒFÃJ»N´P©Q R—U„<­ÖÛÛÿ±€€ÿ"  Â   …   9/  nUÿ%%ûóGFFïÑÑÑûÿÿÿÿüüüÿ•••ñ+))á4..ß/%%Û¾¹¹ôËÆÆô5Ö>%%Ó4Î¹­­î±¡¡é9ÈBÃFºN³O©P SŒ<´ÏÖÖÿ­{{ÿ"  Â   …   9/  nTÿ  ü&&&öÖÖÖüúúúÿ¬¬¬÷ÛÛÛüşşşÿdddê&$$à.((Şµ³³óÂ¾¾ô4##Ø;&&Ö7ÓÆ¿¿òˆrrß@Í‡‡ãX00Ê<¶J°O©Q—9¹½¼´ÿ¢jfÿ$  Â   …   9/  nTÿıfffúÿÿÿÿ………÷é@@@ìûûûÿ···ö"!!á422á<66á@77ß:,,Û7##Ø@++ÖÖÑÑögNNÚ>Îíêêúïëëú‹nnØA¸B¯O 9¾ÒÇ¹ÿ­qiÿ"  Â   …   90  nR		ÿ	ş›››ıöööş>>>òí"""ë”””õtttğ(((ä322ã0--á2++ß8//Ş2!!ØSBBİÜÙÙøN66Ö7Ï’~~äïììûÿÿÿÿ¾°°é\00ÁH¨8ÄÒÇºÿ¬qjÿ"  Â   …   90  nQÿş²²²şèèèş...óï(((í!!!ë   é///ç000æ&&&ã'%%á711ß-  Ùk``ãÒÌÌö;%%Õ>%%Ó6ÏS33Ô¦••èüüüÿëææød55»/
+	ÈÒÈ»ÿ¬qjÿ"  Â   …   9/  nOÿÿ´´´ÿåååş(((öó$$$ñ$$$ï(((í+++ë)))énnnîuuuí0..ã&  İ‡‡ë·²²ñ.Ö>**×7Ô,
+
+ÍaDD×ìççúÿÿÿÿnIIÇ*ÍÓÈ»ÿ¬qjÿ"  Â   …   90  nPÿ		ÿ¦¦¦ÿìììş,,,øõ###óñï(((í   êÎÎÎùİÜÜû(((ä$##ß°¯¯ò ››î)×7&&ÙUCCİ´««îÿÿÿÿóññı‘}}äFÆ2ÖÓÇºÿ¬qjÿ"  Â   …   90  nPÿ ÿ}||ÿıııÿJJJûöô›››úuuuöî!!!ëõ›››ô(((å)((âÇÆÆ÷Š……ë&Ù:,,Ú×ÔÔ÷ÿÿÿÿÉÂÂôZBBØ2ÍBÉ4ÜÕÉ¼ÿ­slÿ"  Â   …   90  nPÿ
+
+ÿ877ÿÿÿÿÿ½½½ş%%%úhhhúÿÿÿÿ¤¤¤úğ(((î###ì%$$ê+,,è444æİÜÜûiffè&ÜB88ŞÍÊÊõŒ‚‚é6  Õ5ÑA&&ÒC  Ì2ŞÆ¼°ÿ¥keÿ#  Â   …   90  nNÿ
+ÿÿ‡‡‡ÿÿÿÿÿñññÿÿÿÿÿèèèş;;;öó&&&ñ%%%ï(((í###êPPPëîîîıIHHæ*''á:55àC;;ß.Ù9&&Ù>((×?((ÕA##Ğ1á§®­ÿ”cbÿ&  Â   …   90  nNÿÿÿÿmmmÿ¿¿¿ÿ«««ıEEEú÷   ö"""ô$$$ò'''ğ   ìWWWî¬¬¬õ222å///ã300á0))Ş9//İ;--Û;**Ù<((Ø?%%Ñ/á«´µÿ—hhÿ%  Â   …   90  nMÿÿÿÿÿ
+
+
+ÿ			ıüúøö"""ô$$$ò&&&ğ'''ì###ê---è000å122ä311ã5//á8..Ş:,,Ü:))Û=&&Õ,ä¤®®ÿ”ddÿ&  Â   …   90  nLÿ
+
+ÿÿÿÿÿÿÿıüû   ù"""÷$$$ö&&&ó'''ó+++ñ---ğ.//ï111î2//ì4..ê5--é6++è9&&ä*í¤¤ÿ^]ÿ'  Â   …   91  nI  ÿ ÿ ÿÿÿÿ	ÿÿÿşııüúùù!!ø ##÷"$$ô#&&ô%((ó(''ó)$$ñ*$$ñ)îôÀ»¯ÿ¤kdÿ$  Ã   …   9.  nY		ÿ6ÿ:ÿ:ÿ>  ÿ>!!ÿ;ÿ:ÿ@$$ÿE''şG((şF&&ş@##şD$$ıE&&ıJ,,üQ22üJ++ûJ**ûU66ûR33úN..úS22ù[99ùT00øM((û~\Xÿz74ÿ*  Ã   …   9%  n†JJÿÿ‡ÿŒƒƒÿ‹„„ÿŠ‚‚ÿº´´ÿÏÈÈÿ˜’’ÿŒ……ÿŠƒƒÿ¨¡¡ÿÚÓÓÿÚÓÓÿáÚÚÿµ®®ÿˆˆÿÜÓÓÿáØØÿ‘ŠŠÿ¸±±ÿïääÿÈÀÀÿˆˆÿÖÌÌÿòææÿéßàÿ½˜˜ÿ$Ã   …   9%  n‡NNÿ”ÿxyyÿ~€€ÿ}ÿy{{ÿ·¹¹ÿÑÓÓÿŠŒŒÿ{}}ÿxzzÿŸŸÿŞààÿÛŞŞÿåèèÿ­¯¯ÿz{{ÿİßßÿãååÿ|}}ÿ®°°ÿışşÿÂÄÄÿvyyÿÔ××ÿışşÿÿÿÿÿÇªªÿ"Ã   …   9'  n}EEÿ³¼¼ÿ°±°ÿ²³²ÿµ¶¶ÿ¸¹¸ÿ¼½½ÿ¿¿¿ÿÀÁÀÿÂÃÂÿÃÄÄÿÇÉÈÿËÌÌÿÍÏÏÿĞÑĞÿÑÓÒÿÓÓÓÿ×××ÿÙÚÚÿÚÛÛÿİŞİÿáââÿãääÿäääÿçèèÿêëëÿòö÷ÿ¼  ÿ#Ã   …   9%  ntAFÿ°¾Äÿ°´»ÿ²·½ÿµºÁÿ¸½Äÿ¸½Äÿº¿Åÿ¾ÄÊÿÁÆÍÿÄÉĞÿÅËÑÿÆÌÑÿÉÏÔÿÌĞØÿÏÓÚÿÓØŞÿÓØßÿÕÛáÿÚßæÿÛáçÿİáçÿâãçÿææìÿääèÿæåêÿøôèÿÁ —ÿ!Ã   …   9, n•,ÿœ=ÿ˜:ÿ™;ÿ™<ÿ™<ÿš=ÿš<ÿ™<ÿš=ÿ›= ÿ›= ÿ›= ÿ›>!ÿ›>!ÿœ="ÿœ>!ÿœ>"ÿœ?#ÿ>#ÿ>#ÿ™?%ÿ‘D/ÿ”?&ÿ”D.ÿ•A)ÿn0Jÿr'8ÿ1Ã   …   9.
+ nÏI ÿÙN ÿÔK ÿÔK ÿÔK ÿÓK ÿÓK ÿÓJ ÿÓJ ÿÓJ ÿÓJ ÿÓJ ÿÓJ ÿÓJ ÿÒJ ÿÒJ ÿÒI ÿÒI ÿÒI ÿÒI ÿÒE ÿÎRÿò’gÿÏf3ÿòYÿÉfAÿ Ñÿ Äÿ4
+Ç   ˆ   9, h¢1 ÿª9 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥6 ÿ¥7 ÿ¥7 ÿ¥7 ÿ¥7 ÿ¥3 ÿ§>ÿÏpNÿ®N'ÿÍmCÿ¬P/ÿ.šÿ<ÿ1	¼   [   !  &< ; —; •; •; •; •; •; •; •; •; •; •; •; •; •; •; •; •; •; •; •: •5•9 •6•9 •@–@• L      ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ¿ÿÿç¿ÿÿç¿ÿÿç¿ÿÿç¼ÿÿç»ÿç·ÿç¿ÿıç¿ÿşçÿÿgÿıç‡ÿûç‡ÿç€ÿÿçÿÿçÿÿç€ÿç€?ÿç€?ÿç€  €  €  €  €  €  €  ÿÿÿÿ
\ No newline at end of file
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/tools/tools.rc clamav-release/contrib/msvc/tools/tools.rc
--- clamav-0.91.2/contrib/msvc/tools/tools.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/tools/tools.rc	2007-07-12 12:36:19.656250000 +1000
@@ -0,0 +1,37 @@
+#include <windows.h>
+
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+
+VS_VERSION_INFO VERSIONINFO
+	FILEVERSION 1,0,0,0
+	PRODUCTVERSION 1,0,0,0
+	FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+	FILEFLAGS 0x1L
+#else
+	FILEFLAGS 0x0L
+#endif
+	FILEOS 0x4L
+	FILETYPE 0x2L
+	FILESUBTYPE 0x0L
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "00000409"
+		BEGIN
+			VALUE "FileDescription", __DESC__
+			VALUE "FileVersion", "1, 0, 0, 0"
+			VALUE "InternalName", __MODULE__
+			VALUE "LegalCopyright", "Copyright (C) 2007 Gianluigi Tiesi"
+			VALUE "OriginalFilename", __MODULE__
+			VALUE "ProductName", "ClamWin Antivirus"
+			VALUE "ProductVersion", "1, 0, 0, 0"
+		END
+	END
+	BLOCK "VarFileInfo"
+	BEGIN
+		VALUE "Translation", 0x0, 1033
+	END
+END
+
+100	ICON	"tools.ico"
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/tools/unscrambler.c clamav-release/contrib/msvc/tools/unscrambler.c
--- clamav-0.91.2/contrib/msvc/tools/unscrambler.c	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/tools/unscrambler.c	2007-07-12 12:36:19.671875000 +1000
@@ -0,0 +1,78 @@
+/*
+ * Clamav Native Windows Port : Mini Dump file unscrambler
+ *
+ * Copyright (c) 2006-2007 Gianluigi Tiesi <sherpya@netfarm.it>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this software; if not, write to the
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <windows.h>
+
+int main(int argc, char *argv[])
+{
+    HANDLE hFile, hMapFile;
+    LPBYTE lpMapAddress;
+    size_t i = 0;
+
+    if (argc != 2)
+    {
+        fprintf(stderr, "Usage %s scrambled.dmp\n", argv[0]);
+        return -1;
+    }
+
+    hFile = CreateFileA(argv[1], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+
+    if (hFile == INVALID_HANDLE_VALUE )
+    {
+        fprintf(stderr, "CreateFile() failed error code %d\n", GetLastError());
+        return -1;
+    }
+
+    hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, "ClamWinDumper");
+
+    if (!hMapFile)
+    {
+        fprintf(stderr, "CreateFileMapping() failed error code %d\n", GetLastError());
+        CloseHandle(hFile);
+        return -1;
+    }
+
+    lpMapAddress = (LPBYTE) MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
+
+    if (!lpMapAddress)
+    {
+        fprintf(stderr, "MapViewOfFile() failed error code %d\n", GetLastError());
+        CloseHandle(hFile);
+        CloseHandle(hMapFile);
+        return -1;
+    }
+
+    if (memcmp(lpMapAddress, "gngz", 4))
+        fprintf(stderr, "Invalid signature, maybe already unscrambled?\n");
+    else
+    {
+        for (i = 0; i < GetFileSize(hFile, NULL); i++)
+            lpMapAddress[i] ^= 42;
+        FlushViewOfFile(lpMapAddress, 0);
+        fprintf(stderr, "%s unscrambed\n", argv[1]);
+    }
+
+    UnmapViewOfFile(lpMapAddress);
+    CloseHandle(hMapFile);
+    CloseHandle(hFile);
+    return 0;
+}
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/tools/unscrambler.rc clamav-release/contrib/msvc/tools/unscrambler.rc
--- clamav-0.91.2/contrib/msvc/tools/unscrambler.rc	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/tools/unscrambler.rc	2007-07-12 12:36:19.625000000 +1000
@@ -0,0 +1,3 @@
+#define __MODULE__	"unscrambler.exe"
+#define __DESC__	"ClamWin Antivirus Dump File Unscrambler"
+#include <tools.rc>
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/unscrambler.dsp clamav-release/contrib/msvc/unscrambler.dsp
--- clamav-0.91.2/contrib/msvc/unscrambler.dsp	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/unscrambler.dsp	2007-07-12 12:36:20.000000000 +1000
@@ -0,0 +1,108 @@
+# Microsoft Developer Studio Project File - Name="unscrambler" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=unscrambler - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "unscrambler.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "unscrambler.mak" CFG="unscrambler - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "unscrambler - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "unscrambler - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "unscrambler - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "unscrambler - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "unscrambler - Win32 Release"
+# Name "unscrambler - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\tools\unscrambler.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\tools\unscrambler.rc
+# End Source File
+# End Group
+# End Target
+# End Project
diff -auprbN -x.svn -xdoc -xdatabase -xRelease -xDebug -x'*.ncb' -x'*.suo' -x'*.user' clamav-0.91.2/contrib/msvc/unscrambler.vcproj clamav-release/contrib/msvc/unscrambler.vcproj
--- clamav-0.91.2/contrib/msvc/unscrambler.vcproj	1970-01-01 10:00:00.000000000 +1000
+++ clamav-release/contrib/msvc/unscrambler.vcproj	2007-07-12 12:36:19.890625000 +1000
@@ -0,0 +1,201 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="unscrambler"
+	ProjectGUID="{0B19CBAF-D36F-48F0-A35B-BB5F73E662AD}"
+	RootNamespace="unscrambler"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\tools\unscrambler.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\tools\unscrambler.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
